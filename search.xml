<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Krenz构成笔记-后知后觉的构成总结</title>
    <url>/2020/11/17/Krenz%E6%9E%84%E6%88%90%E7%AC%94%E8%AE%B0-%E5%90%8E%E7%9F%A5%E5%90%8E%E8%A7%89%E7%9A%84%E6%9E%84%E6%88%90%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="前言（Introduce）"><a href="#前言（Introduce）" class="headerlink" title="前言（Introduce）"></a>前言（Introduce）</h1><p>Krenz是我很喜欢的画师，其主要在台湾从事绘画教育活动，也是我绘画入门的老师，逻辑思维严谨，我个人觉得这和k大的性格和还有工学经历有关，其讲课的方式浅显易懂，容易让学生所接受，K大的课总是喜欢用类比的方法让一些比较难的概念变得浅显易懂，其价格也比较便宜实惠，和一些乱七八糟的教学相比拥有很高的性价比，其三门课循序渐进，让不会绘画，从零开始的初学者有了一个比较好的入手点，因为看了看K大的课件在电脑里堆得时间实在太长，因此想趁此机会做一下总结。</p>
<p>我个人并非专业画师，只是基于业余爱好的经验来写这些东西，其中大部分总结也是看了k大课件里的部分总结来的，如果专业人士看了之后觉得哪里理解有误或者不妥的地方还请不吝指出。</p>
<p>笔者所说的话可能不是特别正确，因为我个人也是一个嘴上的巨人，绘画群和老师经常称没画就一大堆问题的人叫嘴上的巨人，用嘴画画等等，因为绘画的主观性，导致所有观众都能插一嘴，也不像数学那样有门槛，因此请各位问老师问题的时候带着自己的画，这样一方面老师可以看出画中的错误对症下药，一方面不会因为理解有偏差导致隔空抓药。绘画一方面是实力的问题，另一方面你也得画啊() ，所以不要全相信我总结的东西。</p>
<h1 id="第一章-主角-焦点Focus"><a href="#第一章-主角-焦点Focus" class="headerlink" title="第一章:主角(焦点Focus)"></a>第一章:主角(焦点Focus)</h1><p>一般来讲，绘画的画面所表示的必有一个(至少有一个)主题或者主角，就像写小说一样，要让别人(观众)的视线往主角看，那么画家面对一张白纸的时候就要考虑主角在白纸的哪个位置，之后的所有表现手法都是为了表现主角服务的，一般来讲，我们把画面中观众第一眼看到的事物作为主角，就如同刀剑神域动画开始的时候也是从主角桐人开始的，而不是从别的角色开始，但是这一部分并非是浑然天成的，动画有剧本的安排让主角第一个出场，所有作品的角色，其出场顺序是经过可以安排的，绘画也是同理，小说家写作的时候要确定下这部小说的背景历史作为框架(十字线)，剧本有着主线任务和支线任务，明线(十字线和集中线)和暗线(点景)，正面描写，集中线太过直白，我们需要一个隐晦的表达来让集中线表达出来，但又不让观众察觉出来，集中这个概念不一定要用直线。甚至不一定必须用线，使用几何图形暗示也可以。</p>
<p>知道了这个概念就让我们看下面几幅画。</p>
<p><img src="/images/huihuabiji/image-20201117111048806.png" alt="image-20201117111048806"></p>
<p>看一下这个空白的长方形框，如果你不是闲的蛋疼，一般来讲不会多看它一眼，因为画面里什么都没有。</p>
<p><img src="/images/huihuabiji/image-20201117111537712.png" alt="image-20201117111537712"></p>
<p>试试放个点进去，我们的注意力会移动到右上角。</p>
<p><img src="/images/huihuabiji/image-20201117111649608.png" alt="image-20201117111649608"></p>
<p>再加个比他大的点进去，这回我们不会先看右上角,而会先看左下角之后才会注意到右上角，这个新来者(Focus2)胜过了前者(Focus1)，成了画面新的焦点(Focus)。</p>
<p><img src="/images/huihuabiji/image-20201117111958956.png" alt="image-20201117111958956"></p>
<p>再画一个比较大的点(Focus3)，你的眼睛会首先看更大的点，然后移动到第二大的点(Focus2)，紧接着是第三大的点(Focus1)。依据这个原理，画师可以四处移动他们的焦点，让你在画面中绕啊绕，就像在画面中旅行一样。</p>
<h2 id="焦点非点"><a href="#焦点非点" class="headerlink" title="焦点非点"></a>焦点非点</h2><p><img src="/images/huihuabiji/image-20201117113751884.png" alt="image-20201117113751884"></p>
<p>在一幅画中，任意一个眼神聚集的地方叫做“焦点”。每幅画都有一个或者多个焦点，或分散或集中，它们不一定是字面意义上的点，也可以是线条(图6)、二维的形状(图7)，或者是三维的立体结构(图8)，图8和图9中的<strong>“团”焦点</strong>是由暗色和淡色阶所表示的,当然它们也可以是彩色的。正确地处理这些焦点,不论是将其单独呈现还是合并使用,都会在创作优秀画作时起到重要作用。</p>
<p><img src="/images/huihuabiji/image-20201117114100003.png" alt="image-20201117114100003"></p>
<p><img src="/images/huihuabiji/image-20201117114153731.png" alt="image-20201117114153731"></p>
<p>这是 <a href="https://www.pixiv.net/users/19389056" target="_blank" rel="noopener">XilmO@夕末</a>(PixivID=19389056)的两幅画，我觉得不用我说明，我们一眼就能看出来焦点是女孩，同时我们的视线也会朝向焦点。</p>
]]></content>
      <categories>
        <category>构成课</category>
      </categories>
      <tags>
        <tag>Krenz</tag>
        <tag>构成课</tag>
      </tags>
  </entry>
  <entry>
    <title>绘画笔记-漫画的势与集中线</title>
    <url>/2020/11/14/%E7%BB%98%E7%94%BB%E7%AC%94%E8%AE%B0-%E6%BC%AB%E7%94%BB%E7%9A%84%E5%8A%BF%E4%B8%8E%E9%9B%86%E4%B8%AD%E7%BA%BF/</url>
    <content><![CDATA[<p><img src="/images/huihuabiji/image-20201114201405568.png" alt="image-20201114201405568"></p>
<p>怎么说呢。。</p>
<p>这群漫画家真的是在那命换作品。</p>
<p><img src="/images/huihuabiji/image-20201114201440869.png" alt="image-20201114201440869"></p>
<p>势</p>
<p><img src="/images/huihuabiji/image-20201114201456255.png" alt="image-20201114201456255"></p>
<p>来自漫画<strong>镖人</strong></p>
]]></content>
      <categories>
        <category>绘画笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>思考</tag>
        <tag>构成</tag>
        <tag>投影</tag>
      </tags>
  </entry>
  <entry>
    <title>读书札记-镖人漫画</title>
    <url>/2020/11/12/%E8%AF%BB%E4%B9%A6%E6%9C%AD%E8%AE%B0-%E9%95%96%E4%BA%BA%E6%BC%AB%E7%94%BB/</url>
    <content><![CDATA[<p><img src="/images/dushubiji/image-20201112194821041.png" alt="image-20201112194821041"></p>
]]></content>
      <categories>
        <category>读书札记</category>
      </categories>
      <tags>
        <tag>读书札记</tag>
      </tags>
  </entry>
  <entry>
    <title>重装系统软件备份</title>
    <url>/2020/11/12/%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%E8%BD%AF%E4%BB%B6%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h1 id="系统重装要安装的软件"><a href="#系统重装要安装的软件" class="headerlink" title="系统重装要安装的软件:"></a>系统重装要安装的软件:</h1><p>驱动精灵 <a href="https://www.huorong.cn/" target="_blank" rel="noopener">火绒 </a> V2Ray-core 网易有道词典  向日葵</p>
<p><a href="https://www.jianguoyun.com/s/downloads" target="_blank" rel="noopener">坚果云</a> <a href="https://pan.baidu.com/download" target="_blank" rel="noopener">百度网盘</a> MEGA 小米云服务 WPS office  <a href="http://www.potplayer.org/" target="_blank" rel="noopener">potplayer(网页)</a></p>
<p><a href="https://www.typora.io/#windows" target="_blank" rel="noopener">typora</a> <a href="https://music.163.com/#/download" target="_blank" rel="noopener">网易云音乐</a> </p>
<p><a href="https://cn.eagle.cool/" target="_blank" rel="noopener">Eagle</a> <a href="https://www.jam-software.com/treesize_free/" target="_blank" rel="noopener">Treesize free</a>  <a href="https://store.steampowered.com/about/" target="_blank" rel="noopener">Steam</a> blender Bandizip(类似的有Winrar)</p>
<p> <a href="https://im.qq.com/pcqq/" target="_blank" rel="noopener">QQ(网页或者TIM)</a> <a href="https://weixin.qq.com/cgi-bin/readtemplate?uin=&amp;stype=&amp;promote=&amp;fr=&amp;lang=zh_CN&amp;ADTAG=&amp;check=false&amp;nav=download&amp;t=weixin_download_list&amp;loc=readtemplate,weixin,body,6" target="_blank" rel="noopener">微信</a> 腾讯文档 腾讯桌面整理Lite </p>
<p>NVIDIA GEForce Expericence everything</p>
<p><a href="https://visualstudio.microsoft.com/zh-hans/vs/" target="_blank" rel="noopener">VisualStudio</a> <a href="https://git-scm.com/downloads" target="_blank" rel="noopener">Git</a> <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Nodejs</a> <a href="https://desktop.github.com/" target="_blank" rel="noopener">Desktop Github</a> Cmake-gui </p>
<p><a href="https://www.jijidown.com/" target="_blank" rel="noopener">bilibilijj</a>  <a href="http://www.internetdownloadmanager.com/download.html" target="_blank" rel="noopener">IDM</a> </p>
<p>Anaconda（Python） 论文-Zotero</p>
<h1 id="主机额外安装"><a href="#主机额外安装" class="headerlink" title="主机额外安装:"></a>主机额外安装:</h1><p><a href="http://hs.blizzard.cn/download" target="_blank" rel="noopener">炉石传说</a>以及官方插件 <a href="https://www.battlenet.com.cn/account/download/index.xml?show=bnetapp" target="_blank" rel="noopener">战网</a> <a href="http://lushi.163.com/" target="_blank" rel="noopener">炉石传说盒子</a></p>
<p>Ubisoft Game Launcher Epic Game Launcher  <a href="https://www.unrealengine.com/zh-CN/feed?sessionInvalidated=true" target="_blank" rel="noopener">UE4</a></p>
<p><a href="https://sai.yufan.me/" target="_blank" rel="noopener">SAI2破解</a></p>
<h1 id="替代品"><a href="#替代品" class="headerlink" title="替代品"></a>替代品</h1><h2 id="下载器"><a href="#下载器" class="headerlink" title="下载器"></a>下载器</h2><table>
<thead>
<tr>
<th>图片下载器</th>
<th>文件下载器</th>
</tr>
</thead>
<tbody>
<tr>
<td><em>[gitHub]</em>ArtStationDownloader 下载A站图片</td>
<td>mangacon 漫画控 漫画下载器</td>
</tr>
<tr>
<td>[gitHub]Pixivutil 下载P站图片</td>
<td>Pinterst Downloaders</td>
</tr>
<tr>
<td>Libgen Desktop 电子书英文书下载</td>
</tr>
</tbody>
</table>
<h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><table>
<thead>
<tr>
<th><a href="https://code.visualstudio.com//" target="_blank" rel="noopener">Visual Studio Code</a></th>
<th><a href="https://www.jetbrains.com/pycharm/download/#section=windows" target="_blank" rel="noopener">PyCharm Community Edition</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>codeblocks</td>
<td><a href="https://www.jetbrains.com/clion/" target="_blank" rel="noopener">JetBrains Clion(C++IDE)(不用)</a></td>
</tr>
<tr>
<td><a href="https://wingware.com/" target="_blank" rel="noopener">Wing IDE</a></td>
<td><a href="https://www.jetbrains.com/phpstorm/" target="_blank" rel="noopener">JetBrains phpStorm(不用)</a></td>
</tr>
<tr>
<td>(不用) <a href="https://ide.atom.io/" target="_blank" rel="noopener">Atom</a></td>
<td><a href="https://www.perfare.net/1194.html" target="_blank" rel="noopener">AssetStudio</a> <a href="https://7daystodie.com/forums/showthread.php?22675-Unity-Assets-Bundle-Extractor" target="_blank" rel="noopener">Unity Assets Bundle Extractor</a></td>
</tr>
</tbody>
</table>
<h2 id="办公软件"><a href="#办公软件" class="headerlink" title="办公软件"></a>办公软件</h2><table>
<thead>
<tr>
<th>局域网同步 goodsync</th>
<th>数据库 Sybase PowerDesigner 生成ER图</th>
<th><a href="https://otp.landian.vip/zh-cn/" target="_blank" rel="noopener">office tool</a></th>
</tr>
</thead>
<tbody>
<tr>
<td>PSD Codec</td>
<td><a href="https://dl.pconline.com.cn/download/1610934.html" target="_blank" rel="noopener">略缩图显示工具mysticthumbs</a></td>
<td><a href="http://blog.sina.com.cn/s/blog_89a729a40102wjwk.html" target="_blank" rel="noopener">截图软件faststone</a></td>
</tr>
<tr>
<td>Markdown <a href="https://maxiang.io/" target="_blank" rel="noopener">马克飞象(暂存)</a> <a href="https://pandoc.org/" target="_blank" rel="noopener">pandoc标记语言转换工具</a></td>
<td>openoffice Xnview <a href="https://calibre-ebook.com/" target="_blank" rel="noopener">Calibre(阅读)</a> WinDjview</td>
<td><a href="https://www.gimp.org/" target="_blank" rel="noopener">GIMP(网站备份)</a></td>
</tr>
<tr>
<td><a href="https://obsproject.com/download" target="_blank" rel="noopener">OBS Studio(录屏不用)</a></td>
<td>W3Cschool离线版</td>
<td>Psiphon3</td>
</tr>
<tr>
<td>笔记 wordpress 易码 Anki OCR</td>
<td>虾米音乐 <a href="https://www.image-line.com/downloads/flstudiodownload.html" target="_blank" rel="noopener">FL</a></td>
<td>mySpeed</td>
</tr>
<tr>
<td>漫画 漫画控 Kindle Comic Converter</td>
<td><a href="https://www.cctalk.com/download" target="_blank" rel="noopener">CCtalk</a> 哔哩哔哩压制工具</td>
<td><a href="http://www.pcgeshi.com/" target="_blank" rel="noopener">格式工厂</a>(网页)</td>
</tr>
<tr>
<td>RSS  Feed Demon mozilla thunder</td>
<td>数学 MathType 7 Mathpix Snipping Tool Axmath</td>
</tr>
</tbody>
</table>
<h2 id="树莓派有关软件"><a href="#树莓派有关软件" class="headerlink" title="树莓派有关软件"></a>树莓派有关软件</h2><table>
<thead>
<tr>
<th>SD card Formatter</th>
<th><a href="https://www.netsarang.com/zh/xftp/" target="_blank" rel="noopener">Xftp</a></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>putty</td>
<td><a href="https://www.realvnc.com/en/connect/download/viewer/" target="_blank" rel="noopener">vncviewer</a></td>
<td><a href="http://shumeipai.nxez.com/2013/09/07/no-screen-unknow-ip-login-pi.html" target="_blank" rel="noopener">ipscanner</a></td>
</tr>
</tbody>
</table>
<h2 id="绘画软件"><a href="#绘画软件" class="headerlink" title="绘画软件"></a>绘画软件</h2><table>
<thead>
<tr>
<th><a href="http://www.gfxcamp.com/photoshop-cc-2018/" target="_blank" rel="noopener">PS CC(网站备份)</a> PS CS6</th>
<th><a href="https://saier.me/group-buy-sai/" target="_blank" rel="noopener">SAI2</a></th>
<th><a href="http://www.dayanzai.me/pscs6.html" target="_blank" rel="noopener">PS精简版</a></th>
<th>designdoll</th>
</tr>
</thead>
<tbody>
<tr>
<td>SAI2 茶绘 <a href="https://www.pureref.com/download.php" target="_blank" rel="noopener">pureref(网站)</a></td>
<td>clip studio</td>
<td>Pose studio</td>
<td>恋活</td>
</tr>
</tbody>
</table>
<h1 id="3D软件"><a href="#3D软件" class="headerlink" title="3D软件"></a>3D软件</h1><table>
<thead>
<tr>
<th><a href="http://www.gfxcamp.com/sketchup-pro-2017/" target="_blank" rel="noopener">Sketchup (MEGA/</a><a href="http://www.gfxcamp.com/maya-2018/" target="_blank" rel="noopener">3D软件安装包</a><a href="http://www.gfxcamp.com/sketchup-pro-2017/" target="_blank" rel="noopener">)</a></th>
<th><a href="https://www.bilibili.com/video/av26974958?from=search&amp;seid=1692464848749500013" target="_blank" rel="noopener">daz STUDIO安装教程(哔哩哔哩MEGA/DAZ/附有基础包同步)</a></th>
<th><a href="https://www.daz3d.com/customer/account/getstudio/" target="_blank" rel="noopener">DAZ官网安装包(MEGA)</a></th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="http://www.gfxcamp.com/maya-2018/" target="_blank" rel="noopener">Maya (MEGA同步/3D软件安装包)</a></td>
<td><a href="http://www.gfxcamp.com/marvelous-designer-7/" target="_blank" rel="noopener">marvelous-designer</a></td>
<td>Substance Designer(MEGA)</td>
</tr>
<tr>
<td>Substance Painter(未备份见官网)</td>
<td>ZBrush 3DMax <a href="https://unity3d.com/cn/get-unity/download" target="_blank" rel="noopener">Unity</a></td>
<td><a href="https://www.autodesk.com/products/fbx/fbx-review" target="_blank" rel="noopener">FBX Review(MEGA/小工具)</a></td>
</tr>
</tbody>
</table>
<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><table>
<thead>
<tr>
<th>Daz to Maya(MEGA/DAZ文件夹)</th>
<th><a href="https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hans" target="_blank" rel="noopener">vscode-language-pack-zh-hans</a></th>
<th>unity Hub</th>
<th>xnormal(烘焙纹理贴图)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>美食  美食天下 下厨房 网上厨房</td>
<td>健康医学</td>
<td>丁香医生 丁香智汇 用药助手</td>
</tr>
</tbody>
</table>
<h1 id="学习教育"><a href="#学习教育" class="headerlink" title="学习教育"></a>学习教育</h1><table>
<thead>
<tr>
<th>网易云课堂</th>
<th>网易公开课</th>
<th>coursera</th>
<th>codenza(编码学习 算法动画图解(简单易懂的算法</th>
</tr>
</thead>
<tbody>
<tr>
<td>公考通</td>
<td>W3cschool</td>
<td>Udemy</td>
<td>Gitter( gitbook pocket</td>
</tr>
</tbody>
</table>
<h1 id="语言学习"><a href="#语言学习" class="headerlink" title="语言学习"></a>语言学习</h1><table>
<thead>
<tr>
<th>Aboboo</th>
<th>Anki划词助手</th>
<th>简明日语</th>
<th>NHK日本语</th>
</tr>
</thead>
<tbody>
<tr>
<td>Anki朗读器</td>
<td>ankidroid</td>
<td>可可英语</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>重装</tag>
        <tag>系统</tag>
        <tag>备份</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101-Lecture02 Review of Linear Algebra笔记</title>
    <url>/2020/11/10/GAMES101-Lecture02-Review-of-Linear-Algebra%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>旋转的例子</p>
<p><img src="/images/Games101/image-20201111124722150.png" alt="image-20201111124722150"></p>
<p>图形学中向量的默认形式是<strong>列向量</strong></p>
<h1 id="叉乘公式"><a href="#叉乘公式" class="headerlink" title="叉乘公式"></a>叉乘公式</h1><p>$$<br>\vec{a} \times \vec{b}=\left(\begin{array}{l}<br>y_{a} z_{b}-y_{b} z_{a} \\<br>z_{a} x_{b}-x_{a} z_{b} \\<br>x_{a} y_{b}-y_{a} x_{b}<br>\end{array}\right)<br>$$</p>
<p>$$<br>\vec{a} \times \vec{b}=A^{*} b=\left(\begin{array}{ccc}<br>0 &amp; -z_{a} &amp; y_{a} \\<br>z_{a} &amp; 0 &amp; -x_{a} \\<br>-y_{a} &amp; x_{a} &amp; 0<br>\end{array}\right)\left(\begin{array}{l}<br>x_{b} \\<br>y_{b} \\<br>z_{b}<br>\end{array}\right)<br>$$</p>
<p>$$<br>\begin{array}{l}<br>\vec{x} \times \vec{y}=+\vec{z} \\<br>\vec{y} \times \vec{x}=-\vec{z} \\<br>\vec{y} \times \vec{z}=+\vec{x} \\<br>\vec{z} \times \vec{y}=-\vec{x} \quad \vec{a} \times(\vec{b}+\vec{c})=\vec{a} \times \vec{b}+\vec{a} \times \vec{c} \\<br>\vec{z} \times \vec{x}=+\vec{y} &amp; \vec{a} \times(k \vec{b})=k(\vec{a} \times \vec{b}) \\<br>\vec{x} \times \vec{z}=-\vec{y}<br>\end{array}<br>$$<br>叉乘可以定义左右和形状的内外两侧信息，起到定向的作用</p>
<p><img src="/images/Games101/image-20201115202556394.png" alt="image-20201115202556394"><br>$$<br>\begin{array}{l}<br>\vec{a} \times \vec{b}=+\vec{z} \quad \quad a在b的左侧  \\<br>\vec{b} \times \vec{a}=-\vec{z} \quad \quad a在b的右侧\\<br>\vec{AB} \times \vec{AP}=+ \\<br>\vec{BC} \times \vec{BP}=+ \\<br>\vec{CA} \times \vec{CP}=+ \quad \quad 如P点在AC右侧,则\vec{CA} \times \vec{CP} 为负值 \\<br>如三角行逆时针,只要所有的叉乘值都为正值或都为负值就可判断在三角形内部，从而忽略给定的三角形的顺序 \\<br>在边上的情况被称为 corner case 这时候开发者自己说了算\<br>\\<br>\end{array}<br>$$</p>
<h1 id="虚拟机安装问题"><a href="#虚拟机安装问题" class="headerlink" title="虚拟机安装问题"></a>虚拟机安装问题</h1><p>Not in a hypervisor partition (HVP=0) (VERR_NEM_NOT_AVAILABLE).</p>
<p>AMD-V is disabled in the BIOS (or by the host OS) (VERR_SVM_DISABLED).</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>1.Windows设置 - 更新和安全 - 回复 - 立即重新启动</p>
<p><strong>2.Troubleshoot -&gt; Advanced option – &gt; UEFI Firmware Settings -&gt; Restart</strong></p>
<p>3.在<strong>BIOS</strong>中找到<strong>Virtualization</strong> 选项，它常位于<strong>Advanced 或 System Configuration</strong> 选项卡下</p>
<p>4.设置<strong>Virtualization</strong> 的状态为<strong>Enabled。</strong></p>
<p>AMD和Intel的设置不一样</p>
<h1 id="Eigen库的使用问题"><a href="#Eigen库的使用问题" class="headerlink" title="Eigen库的使用问题"></a>Eigen库的使用问题</h1><p><img src="/images/Games101/image-20201121230206966.png" alt="image-20201121230206966"></p>
]]></content>
      <categories>
        <category>Games101现代计算机图形学入门</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>闫令琪</tag>
        <tag>线性代数</tag>
      </tags>
  </entry>
  <entry>
    <title>GAMES101-Lecture01 Overview of Computer Graphics笔记</title>
    <url>/2020/11/10/GAMES101-Lecture01-Overview-of-Computer-Graphics%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>判断渲染的一个简单标准:画面是否明亮</p>
<h1 id="游戏-Video-Game"><a href="#游戏-Video-Game" class="headerlink" title="游戏(Video Game)"></a>游戏(Video Game)</h1><h2 id="只狼"><a href="#只狼" class="headerlink" title="只狼"></a>只狼</h2><p><img src="/images/Games101/image-20201110103745003.png" alt="image-20201110103745003"></p>
<h2 id="卡通NPR——无主之地3"><a href="#卡通NPR——无主之地3" class="headerlink" title="卡通NPR——无主之地3"></a>卡通NPR——无主之地3</h2><p><img src="/images/Games101/image-20201110103820530.png" alt="image-20201110103820530"></p>
<a id="more"></a>
<h1 id="电影-Movie"><a href="#电影-Movie" class="headerlink" title="电影(Movie)"></a>电影(Movie)</h1><h2 id="特效"><a href="#特效" class="headerlink" title="特效"></a>特效</h2><p><img src="/images/Games101/image-20201110103859699.png" alt="image-20201110103859699"></p>
<h2 id="动作捕捉-阿凡达"><a href="#动作捕捉-阿凡达" class="headerlink" title="动作捕捉:阿凡达"></a>动作捕捉:阿凡达</h2><p><img src="/images/Games101/image-20201110103340277.png" alt="image-20201110103340277"></p>
<h1 id="动画-Animation"><a href="#动画-Animation" class="headerlink" title="动画(Animation)"></a>动画(Animation)</h1><h2 id="疯狂动物城"><a href="#疯狂动物城" class="headerlink" title="疯狂动物城"></a>疯狂动物城</h2><p><img src="/images/Games101/image-20201110103413753.png" alt="image-20201110103413753"></p>
<p>毛发的渲染和显示，复杂的过程如何去显示几何和计算光线的传播</p>
<h2 id="冰雪奇缘——模拟simulation"><a href="#冰雪奇缘——模拟simulation" class="headerlink" title="冰雪奇缘——模拟simulation"></a>冰雪奇缘——模拟simulation</h2><p><img src="/images/Games101/image-20201110103514682.png" alt="image-20201110103514682"></p>
<p>头发的渲染（头发的执念），发光粒子</p>
<h1 id="工业设计（Design）"><a href="#工业设计（Design）" class="headerlink" title="工业设计（Design）"></a>工业设计（Design）</h1><h2 id="特斯拉车子的渲染效果"><a href="#特斯拉车子的渲染效果" class="headerlink" title="特斯拉车子的渲染效果"></a>特斯拉车子的渲染效果</h2><p><img src="/images/Games101/image-20201110103953593.png" alt="image-20201110103953593"></p>
<p>虚拟世界模拟车的碰撞检测</p>
<h2 id="室内装修"><a href="#室内装修" class="headerlink" title="室内装修"></a>室内装修</h2><p><img src="/images/Games101/image-20201110104126551.png" alt="image-20201110104126551"></p>
<h1 id="可视化（Visualization）"><a href="#可视化（Visualization）" class="headerlink" title="可视化（Visualization）"></a>可视化（Visualization）</h1><p><img src="/images/Games101/image-20201110104225900.png" alt="image-20201110104225900"></p>
<p>医学</p>
<h1 id="虚拟现实（Virtual-Reality）"><a href="#虚拟现实（Virtual-Reality）" class="headerlink" title="虚拟现实（Virtual Reality）"></a>虚拟现实（Virtual Reality）</h1><p><img src="/images/Games101/image-20201110104311033.png" alt="image-20201110104311033"></p>
<p>可交互的虚拟现实</p>
<h1 id="数字绘画（Digital-Illustration）"><a href="#数字绘画（Digital-Illustration）" class="headerlink" title="数字绘画（Digital Illustration）"></a>数字绘画（Digital Illustration）</h1><p><img src="/images/Games101/image-20201110104430115.png" alt="image-20201110104430115"></p>
<h1 id="模拟-Simulation"><a href="#模拟-Simulation" class="headerlink" title="模拟(Simulation)"></a>模拟(Simulation)</h1><p><img src="/images/Games101/image-20201110104509808.png" alt="image-20201110104509808"></p>
<p>风，黑洞，沙尘暴物理模拟的效果</p>
<h1 id="GUI-Graphical-User-Interfaces"><a href="#GUI-Graphical-User-Interfaces" class="headerlink" title="GUI(Graphical User Interfaces)"></a>GUI(Graphical User Interfaces)</h1><p><img src="/images/Games101/image-20201110104621919.png" alt="image-20201110104621919"></p>
<h1 id="Typography（排版）"><a href="#Typography（排版）" class="headerlink" title="Typography（排版）"></a>Typography（排版）</h1><p><img src="/images/Games101/image-20201110104654967.png" alt="image-20201110104654967"></p>
<h1 id="课程主题-主要四部分"><a href="#课程主题-主要四部分" class="headerlink" title="课程主题(主要四部分)"></a>课程主题(主要四部分)</h1><p>-光栅化(Rasterization) 栅格化</p>
<p>-曲线和网格(Curves and Meshes)</p>
<p>-光线追踪(Ray Tracing)</p>
<p>-动画/模拟(Animation / Simulation)</p>
<h2 id="光栅化-Rasterization"><a href="#光栅化-Rasterization" class="headerlink" title="光栅化(Rasterization)"></a>光栅化(Rasterization)</h2><p>课外补充:</p>
<p>光栅化就是把矢量图形转化成像素点儿的过程。我们屏幕上显示的画面都是由像素组成，而三维物体都是点线面构成的。要让点线面，变成能在屏幕上显示的像素，就需要Rasterize这个过程。就是从矢量的点线面的描述，变成像素的描述，这个过程就是Rasterize。</p>
<p><img src="/images/Games101/image-20201110105739804.png" alt="image-20201110105739804"></p>
<p><img src="/images/Games101/image-20201110105754703.png" alt="image-20201110105754703"></p>
<h2 id="曲线和网格-Curves-and-Meshes"><a href="#曲线和网格-Curves-and-Meshes" class="headerlink" title="曲线和网格(Curves and Meshes)"></a>曲线和网格(Curves and Meshes)</h2><p>如何在计算机中表示曲面与曲线</p>
<p><img src="/images/Games101/image-20201110105829046.png" alt="image-20201110105829046"></p>
<h2 id="光线追踪-Ray-Tracing"><a href="#光线追踪-Ray-Tracing" class="headerlink" title="光线追踪(Ray Tracing)"></a>光线追踪(Ray Tracing)</h2><p><img src="/images/Games101/image-20201110105905968.png" alt="image-20201110105905968"></p>
<p><img src="/images/Games101/image-20201110105941599.png" alt="image-20201110105941599"></p>
<h1 id="Not-About"><a href="#Not-About" class="headerlink" title="Not About"></a>Not About</h1><h2 id="计算机建模软件"><a href="#计算机建模软件" class="headerlink" title="计算机建模软件"></a>计算机建模软件</h2><p><img src="/images/Games101/image-20201110110905088.png" alt="image-20201110110905088"></p>
<h2 id="计算机视觉"><a href="#计算机视觉" class="headerlink" title="计算机视觉"></a>计算机视觉</h2><p><img src="/images/Games101/image-20201110110922567.png" alt="image-20201110110922567"></p>
<h1 id="Differences-between-CG-amp-CV"><a href="#Differences-between-CG-amp-CV" class="headerlink" title="Differences between CG&amp;CV"></a>Differences between CG&amp;CV</h1><p><img src="/images/Games101/image-20201110111020693.png" alt="image-20201110111020693"></p>
<h1 id="Final-Project"><a href="#Final-Project" class="headerlink" title="Final Project"></a>Final Project</h1><p>最后的大作业是最有精华的部分</p>
]]></content>
      <categories>
        <category>Games101现代计算机图形学入门</category>
      </categories>
      <tags>
        <tag>计算机图形学</tag>
        <tag>闫令琪</tag>
      </tags>
  </entry>
  <entry>
    <title>绘画笔记-透视课的思考</title>
    <url>/2020/11/09/%E7%BB%98%E7%94%BB%E7%AC%94%E8%AE%B0-%E9%80%8F%E8%A7%86%E8%AF%BE%E7%9A%84%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<p>高中的时候喜欢画画，然后看到K大的视频 ，大学的时候K大开班就报班当兴趣了</p>
<p>透视课并不是本末倒置让人钻进透视的坑里</p>
<p>而是建立何为画的正确的，也可以说是看起来是对的偏差不大的基本观念</p>
<p>即便正确的看起来很丑 但是他的确是对的，既然它是对那么就可以了，基本上达到了K大透视课的教学目的</p>
<p>(补充一句画对与画漂亮不冲突，柯一正，林冉的，但是这是后话了，不对也漂亮的也有，例如下面这幅，但是不建议这么画，其视觉上构图是Ok的但是你非要细究的话，比例可能有些问题，腿部伸出来的地方有点不对劲，当然这可能是我主观感受.我也没仔细量过，但是差不多是这个意思，但是 瑕不掩瑜，所谓的画有其主要方面和次要方面，这幅画的主要方面就在其构成)</p>
<p><img src="/images/huihuabiji/image-20201109112443100.png" alt="image-20201109112443100"></p>
<p>画师DOM pixivID=3393042 </p>
<p>卡通二次元绘画的一个标准人物就是河CY，在我看来其兼顾了构成和色彩，可以成为一个初学画师学习的范本人物</p>
<p><img src="/images/huihuabiji/image-20201109112557829.png" alt="image-20201109112557829"></p>
<p>河CY pixivID=3869665</p>
<p>而从画对到画的漂亮，怎说呢 就可以想成是写实到二次元的过渡 </p>
<p>比例 结构也是重要的内容</p>
<p>并且我个人感觉绘画重视的是..逻辑能力 </p>
<p>一些思考</p>
<p>骨点应该是增加信息量的一种手段 非必需</p>
<p>简单</p>
<p>素描的区间</p>
]]></content>
      <categories>
        <category>绘画笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>思考</tag>
        <tag>透视</tag>
      </tags>
  </entry>
  <entry>
    <title>ligal High杂感</title>
    <url>/2020/11/09/ligal-High%E6%9D%82%E6%84%9F/</url>
    <content><![CDATA[<p>今天突然想起了lagel high 里有一集是讲新旧世纪交替时候的人们的</p>
<p>为国家建设时期付出努力的人 现在倒成了被人欺骗的对象 是非常可笑又可悲的一件事</p>
<p>保健品，电信欺诈，保险金欺诈等等 仿佛那个时期没有发生过一样的被遗忘</p>
<p>新世纪的孩童觉得一切的是理所当然的，</p>
<p>油腻大叔，顽固不化，不去学习新的知识仿佛是旧时代父母的通病</p>
<p>可是现今确实已经不是那个时代了</p>
<p>但是我觉得我们应该谅解他们</p>
<p>毕竟他们带你成长，教育儿女，让人走上了正确的道路。这就足够伟大了  </p>
<p>——2018-12-8 沈阳航空航天大学教室</p>
]]></content>
      <categories>
        <category>读书札记</category>
      </categories>
      <tags>
        <tag>杂感</tag>
      </tags>
  </entry>
  <entry>
    <title>绘画笔记-冷暖</title>
    <url>/2020/11/08/%E7%BB%98%E7%94%BB%E7%AC%94%E8%AE%B0-%E5%86%B7%E6%9A%96/</url>
    <content><![CDATA[<h1 id="Alena-Aenami"><a href="#Alena-Aenami" class="headerlink" title="Alena Aenami"></a>Alena Aenami</h1><p>A站一个冷暖的画家</p>
<p><img src="/images/huihuabiji/1546086573718.png" alt="1546086573718"></p>
<h1 id="BATO-DUGARZHAPOV"><a href="#BATO-DUGARZHAPOV" class="headerlink" title="BATO DUGARZHAPOV"></a><a href="http://artrussia.ru/en/bato_dugarzhapov" target="_blank" rel="noopener">BATO DUGARZHAPOV</a></h1><p><img src="/images/huihuabiji/bato-dugarzhapov-untitled.jpg" alt="bato-dugarzhapov-untitled"></p>
<h1 id="冷暖-饱和度-的一个高级作用——表现体积-而不用明度表现体积"><a href="#冷暖-饱和度-的一个高级作用——表现体积-而不用明度表现体积" class="headerlink" title="冷暖(饱和度)的一个高级作用——表现体积(而不用明度表现体积)"></a>冷暖(饱和度)的一个高级作用——表现体积(而不用明度表现体积)</h1><p>其实本质来讲就是<strong>有对比</strong> 和之前投影的笔记一个样子，投影使用明度对比塑造体积感，而冷暖用饱和度塑造体积感，这两者在素描的层面上都是明度发生了变化</p>
<p><img src="/images/huihuabiji/冷暖和饱和度对比出体积-1546513659128.png" alt="冷暖和饱和度对比出体积-1546513659128"></p>
]]></content>
      <categories>
        <category>绘画笔记</category>
      </categories>
      <tags>
        <tag>色彩</tag>
        <tag>笔记</tag>
        <tag>思考</tag>
        <tag>冷暖</tag>
      </tags>
  </entry>
  <entry>
    <title>绘画笔记-投影</title>
    <url>/2020/11/08/%E7%BB%98%E7%94%BB%E7%AC%94%E8%AE%B0-%E6%8A%95%E5%BD%B1/</url>
    <content><![CDATA[<h1 id="投影的对比感出来就算不是变暗也可以体现出投影的感觉"><a href="#投影的对比感出来就算不是变暗也可以体现出投影的感觉" class="headerlink" title="投影的对比感出来就算不是变暗也可以体现出投影的感觉"></a>投影的对比感出来就算不是变暗也可以体现出投影的感觉</h1><p><img src="/images/huihuabiji/1550383518656.png" alt="1550383518656"></p>
<p>▽Omutatsu<br><a href="https://twitter.com/omrice4869" target="_blank" rel="noopener">https://twitter.com/omrice4869</a><br><a href="https://omutatsu.work" target="_blank" rel="noopener">https://omutatsu.work</a></p>
<p><strong>投影的对比也算是一种增加插画丰富性的表现手法</strong></p>
<h1 id="投影与苹果"><a href="#投影与苹果" class="headerlink" title="投影与苹果"></a>投影与苹果</h1><p><img src="/images/huihuabiji/1578665865201.png" alt="1578665865201"></p>
]]></content>
      <categories>
        <category>绘画笔记</category>
      </categories>
      <tags>
        <tag>色彩</tag>
        <tag>笔记</tag>
        <tag>思考</tag>
        <tag>投影</tag>
      </tags>
  </entry>
  <entry>
    <title>hexoNext的设置备份</title>
    <url>/2020/11/08/hexoNext%E7%9A%84%E8%AE%BE%E7%BD%AE%E5%A4%87%E4%BB%BD/</url>
    <content><![CDATA[<h1 id="base-styl设置字体大小"><a href="#base-styl设置字体大小" class="headerlink" title="base.styl设置字体大小"></a>base.styl设置字体大小</h1><p>在 <code>themes\next\source\css\_variables\base.styl</code> 中修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Font size</span><br><span class="line">$font-size-base           = (hexo-config(&apos;font.enable&apos;) and hexo-config(&apos;font.global.size&apos;) is a &apos;unit&apos;) ? unit(hexo-config(&apos;font.global.size&apos;), em) : .875em;</span><br><span class="line">$font-size-smallest       = .75em;</span><br><span class="line">$font-size-smaller        = .8125em;</span><br><span class="line">$font-size-small          = .875em;</span><br><span class="line">$font-size-medium         = 1em;</span><br><span class="line">$font-size-large          = 1.125em;</span><br><span class="line">$font-size-larger         = 1.25em;</span><br><span class="line">$font-size-largest        = 1.5em;</span><br></pre></td></tr></table></figure>
<h1 id="主题-config-yml"><a href="#主题-config-yml" class="headerlink" title="主题_config.yml"></a>主题_config.yml</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">font:</span><br><span class="line">  enable: true</span><br><span class="line">  # Uri of fonts host. E.g. //fonts.googleapis.com (Default)</span><br><span class="line">  # 亲测这个可用，如果不可用，自己搜索 [Google 字体 国内镜像]，找个能用的就行</span><br><span class="line">  host: https://fonts.cat.net</span><br><span class="line">  # Global font settings used on &lt;body&gt; element.</span><br><span class="line">    # 全局字体，应用在 body 元素上</span><br><span class="line">  global:</span><br><span class="line">    external: true</span><br><span class="line">    family: Lato</span><br><span class="line">    size: 16</span><br><span class="line">    #csdn上就是16看着舒服多了</span><br></pre></td></tr></table></figure>
<h1 id="custom-styl"><a href="#custom-styl" class="headerlink" title="custom.styl"></a>custom.styl</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 标题，修改成你期望的字体族</span><br><span class="line">$font-family-headings = Georgia, sans</span><br><span class="line"> </span><br><span class="line">// 修改成你期望的字体族</span><br><span class="line">$font-family-base = &quot;Microsoft YaHei&quot;, Verdana, sans-serif</span><br><span class="line"> </span><br><span class="line">// 代码字体</span><br><span class="line">$code-font-family = &quot;Input Mono&quot;, &quot;PT Mono&quot;, Consolas, Monaco, Menlo, monospace</span><br><span class="line"> </span><br><span class="line">// 正文字体的大小</span><br><span class="line">$font-size-base = 16px</span><br><span class="line"> </span><br><span class="line">// 代码字体的大小</span><br><span class="line">$code-font-size = 13px</span><br></pre></td></tr></table></figure>
<p>第一个字体变量是题目的字体，第二个是其余部分的字体。<br>因为我们是中文博客，所以肯定希望能改成一些比较漂亮的中文字体，但是显而易见，你改成<code>宋体</code>是不合理的，因为第一会出现乱码情况，第二Hexo也不接受中文名字的字体。所以我们需要使用中文字体的英文名称。下面是中文字体对应的英文名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">新细明体：PMingLiU </span><br><span class="line">细明体：MingLiU </span><br><span class="line">标楷体：DFKai-SB </span><br><span class="line">黑体：SimHei </span><br><span class="line">宋体：SimSun </span><br><span class="line">新宋体：NSimSun </span><br><span class="line">仿宋：FangSong </span><br><span class="line">楷体：KaiTi </span><br><span class="line">仿宋_GB2312：FangSong_GB2312 </span><br><span class="line">楷体_GB2312：KaiTi_GB2312 </span><br><span class="line">微软正黑体：Microsoft JhengHei </span><br><span class="line">微软雅黑体：Microsoft YaHei </span><br><span class="line"></span><br><span class="line">装Office会多出来的一些字体： </span><br><span class="line">隶书：LiSu </span><br><span class="line">幼圆：YouYuan </span><br><span class="line">华文细黑：STXihei </span><br><span class="line">华文楷体：STKaiti </span><br><span class="line">华文宋体：STSong </span><br><span class="line">华文中宋：STZhongsong </span><br><span class="line">华文仿宋：STFangsong </span><br><span class="line">方正舒体：FZShuTi </span><br><span class="line">方正姚体：FZYaoti </span><br><span class="line">华文彩云：STCaiyun </span><br><span class="line">华文琥珀：STHupo </span><br><span class="line">华文隶书：STLiti </span><br><span class="line">华文行楷：STXingkai </span><br><span class="line">华文新魏：STXinwei </span><br><span class="line"></span><br><span class="line">苹果电脑中的字体： </span><br><span class="line">华文细黑：STHeiti Light [STXihei] </span><br><span class="line">华文黑体：STHeiti </span><br><span class="line">华文楷体：STKaiti </span><br><span class="line">华文宋体：STSong </span><br><span class="line">华文仿宋：STFangsong </span><br><span class="line">丽黑 Pro：LiHei Pro Medium </span><br><span class="line">丽宋 Pro：LiSong Pro Light </span><br><span class="line">标楷体：BiauKai </span><br><span class="line">苹果丽中黑：Apple LiGothic Medium </span><br><span class="line">苹果丽细宋：Apple LiSung Light</span><br></pre></td></tr></table></figure>
<h1 id="字体大小不变的问题"><a href="#字体大小不变的问题" class="headerlink" title="字体大小不变的问题"></a>字体大小不变的问题</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello, I have changed: source/css/_variables/custom.styl</span><br><span class="line">$font-size-base = 20px; and when $ hexo s the font is bigger, but $ hexo -g d , </span><br><span class="line">it not worked, how can i do that?thanks</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>
<h1 id="hexo升级"><a href="#hexo升级" class="headerlink" title="hexo升级"></a>hexo升级</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm i hexo-cli -g</span><br><span class="line">hexo version 查看是否升级成功。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>博客</tag>
        <tag>Blog</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/09/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>点集拓扑学(1)--度量空间</title>
    <url>/2020/09/20/%E7%82%B9%E9%9B%86%E6%8B%93%E6%89%91%E5%AD%A6-1-%E5%BA%A6%E9%87%8F%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="1-同构"><a href="#1-同构" class="headerlink" title="1.同构"></a>1.同构</h2><p><img src="/images/20200920095825119.png" alt="在这里插入图片描述"><br><img src="/images/20200920095846638.png" alt="在这里插入图片描述"></p>
<a id="more"></a>
<h3 id="1-1图的同构"><a href="#1-1图的同构" class="headerlink" title="1.1图的同构"></a>1.1图的同构</h3><p><img src="/images/20200920095959833.png" alt="在这里插入图片描述"><br><img src="/images/20200920100010531.png" alt="在这里插入图片描述"><br><img src="/images/20200920100016544.png" alt="在这里插入图片描述"></p>
<h2 id="2-距离的概念"><a href="#2-距离的概念" class="headerlink" title="2.距离的概念"></a>2.距离的概念</h2><p>度量:度量就是距离,但是空间本来没有距离。比如我构造一个空间A-(题主,答主,回复者,知乎管理员},这个空间一开始就没有距离的概念。同样的,我们生活的3维空间一开始也没有距离的概念,每个点都可以看做孤立的点,整个空间可以看做这些点的集合。<br>那距离是什么呢?距离是人类加在空间上的一种关系:任意两个点映射到一个实数。任何满足条件的这种映射都可以叫距离(正定性,对称性,三角不等式)。比如对于刚才的空间A,我定义一个距离:同一个人距离等于0,不同人的距离等于1。这就构成了一个有距离的空间(度量空间),A空间中,以题主为球心,半径为1的球面就是(答主,回复者,知乎管理员)<br>那么, n维欧氏空间中两点的距离是什么呢?和3维的情形一样:坐标相减,平方和,开根号。反过来, n=3时的球面就和我们通常见到的球面一样。</p>
<p>距离是用于表示两个物体间的远近,是存在于两个物体之间的一种关系,我们就可以对集合中的每一对元素指定一个数字,这个数字就代表两个物体之间的距离。<br>需要注意的是,在现实生活中,距离都是有米、厘米之类的单位,而度量空间中则不存在这些单位,所有的距离都是实数。</p>
<h2 id="3-度量空间"><a href="#3-度量空间" class="headerlink" title="3.度量空间"></a>3.度量空间</h2><p><img src="/images/20200920100343262.png" alt="在这里插入图片描述"></p>
<h3 id="3-1-度量空间两点之间的距离"><a href="#3-1-度量空间两点之间的距离" class="headerlink" title="3.1 度量空间两点之间的距离"></a>3.1 度量空间两点之间的距离</h3><p><img src="/images/20200920103341237.png" alt="在这里插入图片描述"></p>
<h3 id="3-2-度量空间等距-同构"><a href="#3-2-度量空间等距-同构" class="headerlink" title="3.2 度量空间等距(同构)"></a>3.2 度量空间等距(同构)</h3><p><img src="/images/20200920103502909.png" alt="在这里插入图片描述"><br><img src="/images/20200920103522710.png" alt="在这里插入图片描述"></p>
<h3 id="3-3-集合间的距离"><a href="#3-3-集合间的距离" class="headerlink" title="3.3 集合间的距离"></a>3.3 集合间的距离</h3><h3 id="3-4-集合间的靠近与不靠近"><a href="#3-4-集合间的靠近与不靠近" class="headerlink" title="3.4 集合间的靠近与不靠近"></a>3.4 集合间的靠近与不靠近</h3><p><img src="/images/20200920104550774.png" alt="在这里插入图片描述"></p>
<p><img src="/images/20200920104625115.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>拓扑学</category>
      </categories>
      <tags>
        <tag>拓扑</tag>
        <tag>度量空间</tag>
      </tags>
  </entry>
  <entry>
    <title>基础拓扑学笔记(6)--射影平面</title>
    <url>/2020/09/20/%E5%9F%BA%E7%A1%80%E6%8B%93%E6%89%91%E5%AD%A6%E7%AC%94%E8%AE%B0-6-%E5%B0%84%E5%BD%B1%E5%B9%B3%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="1-射影平面定义"><a href="#1-射影平面定义" class="headerlink" title="1.射影平面定义"></a>1.射影平面定义</h2><p><img src="/images/2020091817210749.png" alt="在这里插入图片描述"></p>
<a id="more"></a>
<h2 id="2-摄像机与地面上的三角形"><a href="#2-摄像机与地面上的三角形" class="headerlink" title="2.摄像机与地面上的三角形"></a>2.摄像机与地面上的三角形</h2><p>图1。摄像机为投影中心，在地面上拍摄三角形ABC。这个地面是一个完美的平面。淡绿色的区域是从相机上看到的。从相机发出的黑色光线表示取景器的立体区域(金字塔)。在黑色光线上安装的方形板是为了显示我们可以通过相机看到的东西。让我们把这个正方形的板子叫做屏幕。三角形ABC在地面上的照片被拍成屏幕上的三角形A’ b ’ c`。白光是三角形顶点的投影线。<br><img src="/images/20200918172127605.png" alt="在这里插入图片描述"><br>依旧，图2是俯视图的情况，而图3是侧视图。<br>图4是拍摄视角的试视图，而根据图可以看出经过射影变换之后的直线是不变的。虽然经过射影变换之后三角形的形状和大小会变化，但是直线依旧是直线。<br><img src="/images/20200918172138658.png" alt="在这里插入图片描述"><br>图6是平行线的投影。面板屏幕上的平行线看起来有端点，并在地平线上相遇。<br>图7画了两对平行线，将它们投射到面板屏幕上。同时，蓝色平行直线也在水平线上相交。</p>
<h2 id="3-摄影机视角的平行线"><a href="#3-摄影机视角的平行线" class="headerlink" title="3.摄影机视角的平行线"></a>3.摄影机视角的平行线</h2><p><img src="/images/20200918172158706.png" alt="在这里插入图片描述"><br>图8显示了面板屏幕上的两对平行线。右下角是它们构成的平行四边形。数学家把平板屏幕上的视界称为<strong>无穷远处的一条线</strong>。然而，没有这样的物理线存在。这个名字很不合适。它混淆了初学者。它不是一条无限远的直线。我们只能在面板屏幕上捕捉到它作为地面和天空的边界。换句话说，<strong>无穷远处的线是人造的</strong>，那条线其实在现实中并不存在。</p>
<h2 id="4-180°摄影机"><a href="#4-180°摄影机" class="headerlink" title="4.180°摄影机"></a>4.180°摄影机</h2><p><img src="/images/20200918173812224.png" alt="在这里插入图片描述"><br>图9显示了180°相机与矩形平面的拍摄。平面形成半圆柱体。帮助我们得到整个平行线范围的全图。地面上的平行线看起来像铁路，但在屏幕上则不然。</p>
<p>图10显示了图9的展开面板屏幕。点P和P’在无穷远处(视界)线上。面板屏幕是全景的，很好的看到一对平行线。但对于平行线间距大的情况就不方便了。它不能覆盖不同方向的直线。</p>
<p>图11显示了球面上的两对平行线。它们从地面投射到一个半球。半球的中心是投影中心。<strong>半球的边缘(赤道的周长)现在是一条无限远的线</strong>。</p>
<p>吐槽:有一说一,射影平面确实是由摄影来的(</p>
<h2 id="5-莫比乌斯环-Mobius-Strip"><a href="#5-莫比乌斯环-Mobius-Strip" class="headerlink" title="5.莫比乌斯环( Mobius Strip)"></a>5.莫比乌斯环( Mobius Strip)</h2><p>球面直径两端相对的两点称为对跖点。在一个半球的边缘有无数对映点。所有由地面中心投影形成的半球边缘对映点都必须被识别出来。也就是说，无限展开的地面有一些类似于对映点的东西。这个平面就是射影平面。<br><img src="/images/20200919220216702.png" alt="在这里插入图片描述"><br><img src="/images/20200919220254308.png" alt="在这里插入图片描述"><br>其经过变化<br><img src="/images/20200919220625321.png" alt="在这里插入图片描述"><br>经过简化<br><img src="/images/20200919220715596.png" alt="在这里插入图片描述"><br><img src="/images/20200919220810582.png" alt="在这里插入图片描述"></p>
<h2 id="6-不可定向曲面包含莫比乌斯环"><a href="#6-不可定向曲面包含莫比乌斯环" class="headerlink" title="6.不可定向曲面包含莫比乌斯环"></a>6.不可定向曲面包含莫比乌斯环</h2><p><img src="/images/20200919220800878.png" alt="在这里插入图片描述"></p>
<h2 id="7-投影平面上的线与莫比乌斯环的比较"><a href="#7-投影平面上的线与莫比乌斯环的比较" class="headerlink" title="7.投影平面上的线与莫比乌斯环的比较"></a>7.投影平面上的线与莫比乌斯环的比较</h2><p><img src="/images/20200919220839855.png" alt="在这里插入图片描述"><br><img src="/images/20200919220848956.png" alt="在这里插入图片描述"></p>
<p>参考:<br><a href="http://web1.kcn.jp/hp28ah77/us27_infi.htm" target="_blank" rel="noopener">Projective Geometry (1)</a><br>M335 TV3 The Projective Plane RP2 (with Colin Rourke) (Geometric Topology)</p>
]]></content>
      <categories>
        <category>拓扑学</category>
      </categories>
      <tags>
        <tag>拓扑</tag>
        <tag>射影平面</tag>
      </tags>
  </entry>
  <entry>
    <title>基础拓扑学笔记(5)--欧拉示性数</title>
    <url>/2020/09/20/%E5%9F%BA%E7%A1%80%E6%8B%93%E6%89%91%E5%AD%A6%E7%AC%94%E8%AE%B0-5-%E6%AC%A7%E6%8B%89%E7%A4%BA%E6%80%A7%E6%95%B0/</url>
    <content><![CDATA[<h2 id="1-欧拉示性数与剖分无关，因此可以随意选择剖分"><a href="#1-欧拉示性数与剖分无关，因此可以随意选择剖分" class="headerlink" title="1.欧拉示性数与剖分无关，因此可以随意选择剖分"></a>1.欧拉示性数与剖分无关，因此可以随意选择剖分</h2><p><img src="/images/20200917211859895.png" alt="在这里插入图片描述"><br><img src="/images/20200917211917737.png" alt="在这里插入图片描述"></p>
<a id="more"></a>
<p><img src="/images/20200917211941733.png" alt="在这里插入图片描述"><br><img src="/images/20200917211953545.png" alt="在这里插入图片描述"></p>
<h2 id="2-计算欧拉示性数"><a href="#2-计算欧拉示性数" class="headerlink" title="2.计算欧拉示性数"></a>2.计算欧拉示性数</h2><p><img src="/images/20200917212147758.png" alt="在这里插入图片描述"><br><img src="/images/20200917212244772.png" alt="在这里插入图片描述"><br><img src="/images/20200917212300374.png" alt="在这里插入图片描述"><br><img src="/images/20200917212310334.png" alt="在这里插入图片描述"><br>2-2*洞的个数<br><img src="/images/20200917212337358.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>拓扑学</category>
      </categories>
      <tags>
        <tag>拓扑</tag>
        <tag>欧拉示性数</tag>
      </tags>
  </entry>
  <entry>
    <title>基础拓扑学笔记(4)--同胚映像</title>
    <url>/2020/09/20/%E5%9F%BA%E7%A1%80%E6%8B%93%E6%89%91%E5%AD%A6%E7%AC%94%E8%AE%B0-4-%E5%90%8C%E8%83%9A%E6%98%A0%E5%83%8F/</url>
    <content><![CDATA[<h2 id="1-”叠合”映射"><a href="#1-”叠合”映射" class="headerlink" title="1.”叠合”映射"></a>1.”叠合”映射</h2><p><img src="/images/20200916213946626.png" alt="在这里插入图片描述"><br><img src="/images/20200916214007860.png" alt="在这里插入图片描述"></p>
<p><img src="/images/20200916214012890.png" alt="在这里插入图片描述"></p>
<a id="more"></a>
<h2 id="2-同胚映像"><a href="#2-同胚映像" class="headerlink" title="2.同胚映像"></a>2.同胚映像</h2><p><img src="/images/20200916214659835.png" alt="在这里插入图片描述"><br>同胚映射满足单射和漫射<br><img src="/images/20200916215013323.png" alt="在这里插入图片描述"><br><img src="/images/20200916215615635.png" alt="在这里插入图片描述"></p>
<h2 id="3-不能直接看出同胚的莫比乌斯环和环带"><a href="#3-不能直接看出同胚的莫比乌斯环和环带" class="headerlink" title="3.不能直接看出同胚的莫比乌斯环和环带"></a>3.不能直接看出同胚的莫比乌斯环和环带</h2><p><img src="/images/20200916215723649.png" alt="在这里插入图片描述"><br><img src="/images/20200916215757570.png" alt="在这里插入图片描述"></p>
<h2 id="4-同胚的例子"><a href="#4-同胚的例子" class="headerlink" title="4.同胚的例子"></a>4.同胚的例子</h2><p><img src="/images/20200916220325832.png" alt="在这里插入图片描述"></p>
<h3 id="直线同胚于开线段"><a href="#直线同胚于开线段" class="headerlink" title="直线同胚于开线段"></a>直线同胚于开线段</h3><p><img src="/images/20200916220332736.png" alt="在这里插入图片描述"></p>
<h2 id="5-不同胚的例子"><a href="#5-不同胚的例子" class="headerlink" title="5.不同胚的例子"></a>5.不同胚的例子</h2><p><img src="/images/20200916220355440.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>拓扑学</category>
      </categories>
      <tags>
        <tag>拓扑</tag>
        <tag>同胚</tag>
      </tags>
  </entry>
  <entry>
    <title>基础拓扑学笔记(3)--连续映像</title>
    <url>/2020/09/20/%E5%9F%BA%E7%A1%80%E6%8B%93%E6%89%91%E5%AD%A6%E7%AC%94%E8%AE%B0-3-%E8%BF%9E%E7%BB%AD%E6%98%A0%E5%83%8F/</url>
    <content><![CDATA[<h2 id="1-问题-什么叫连续？什么叫连续映射，研究拓扑为什么需要连续映射？"><a href="#1-问题-什么叫连续？什么叫连续映射，研究拓扑为什么需要连续映射？" class="headerlink" title="1.问题:什么叫连续？什么叫连续映射，研究拓扑为什么需要连续映射？"></a>1.问题:什么叫连续？什么叫连续映射，研究拓扑为什么需要连续映射？</h2><p>每门学科都建立在一些基础概念上，而拓扑学中贯穿着一个概念，就是<strong>连续性</strong>的概念。</p>
<p><img src="/images/20200916205900761.png" alt="在这里插入图片描述"><br>要说明连续的概念，要从函数连续的概念类比。</p>
<a id="more"></a>
<h2 id="2-函数-一个量依赖于另一个量"><a href="#2-函数-一个量依赖于另一个量" class="headerlink" title="2.函数=一个量依赖于另一个量"></a>2.函数=一个量依赖于另一个量</h2><p><img src="/images/20200916210124992.png" alt="在这里插入图片描述"></p>
<h2 id="3-量的取值要有意义"><a href="#3-量的取值要有意义" class="headerlink" title="3.量的取值要有意义"></a>3.量的取值要有意义</h2><p>这些有意义的所有值的集合起了个名字叫做<strong>定义域</strong><br><img src="/images/20200916210208393.png" alt="在这里插入图片描述"><br><img src="/images/20200916210247760.png" alt="在这里插入图片描述"><br><img src="/images/20200916210302261.png" alt="在这里插入图片描述"></p>
<h2 id="4-集合并非只有实数组成"><a href="#4-集合并非只有实数组成" class="headerlink" title="4.集合并非只有实数组成"></a>4.集合并非只有实数组成</h2><p><img src="/images/20200916210436861.png" alt="在这里插入图片描述"></p>
<h2 id="5-f-x-在x0处连续"><a href="#5-f-x-在x0处连续" class="headerlink" title="5.f(x)在x0处连续"></a>5.f(x)在x0处连续</h2><p><img src="/images/20200916210611617.png" alt="在这里插入图片描述"><br>连续的定义表达需要用到极限，极限需要用到距离的概念，也就是说只有先定义了距离，才能有极限，才能定义连续，连续可以用极限来表示，也可以用文本的概念来表述。</p>
<h4 id="极限定义的连续如下"><a href="#极限定义的连续如下" class="headerlink" title="极限定义的连续如下:"></a>极限定义的连续如下:</h4><p><img src="/images/2020091621073340.png" alt="在这里插入图片描述"><br><img src="/images/20200916210854280.png" alt="在这里插入图片描述"></p>
<h2 id="6-由距离引出邻域的概念"><a href="#6-由距离引出邻域的概念" class="headerlink" title="6.由距离引出邻域的概念"></a>6.由距离引出邻域的概念</h2><p><img src="/images/20200916211039750.png" alt="在这里插入图片描述"><br><img src="/images/20200916211426343.png" alt="在这里插入图片描述"></p>
<h2 id="7-邻域引出连续映射的概念"><a href="#7-邻域引出连续映射的概念" class="headerlink" title="7.邻域引出连续映射的概念"></a>7.邻域引出连续映射的概念</h2><p>将邻域从实数域扩展出来，邻域概念是连续映射概念的基础，就如同只有定义了距离才能定义连续函数一样。<br><img src="/images/2020091621175450.png" alt="在这里插入图片描述"><br>对比之前函数连续的定义，将函数域中的距离概念用邻域来替代，范围更加广阔，距离是邻域概念在实数域的一个小名，对于实数域来说，邻域就是距离概念，距离就是邻域，而现在要扩展到更广阔的空间，而这个空间没有距离的概念。<br><img src="/images/20200916211810190.png" alt="在这里插入图片描述"></p>
<h2 id="8-不是函数但是是映射"><a href="#8-不是函数但是是映射" class="headerlink" title="8.不是函数但是是映射"></a>8.不是函数但是是映射</h2><p>函数是一一对应的，但是映射并不一定。<br>下面是连续映像出现叠合的情况。</p>
<p><img src="/images/20200916212133216.png" alt="在这里插入图片描述"><br><img src="/images/20200916213305325.png" alt="在这里插入图片描述"><br><img src="/images/2020091621331782.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>拓扑学</category>
      </categories>
      <tags>
        <tag>拓扑</tag>
        <tag>连续</tag>
      </tags>
  </entry>
  <entry>
    <title>基础拓扑学笔记(2)--拓扑不变量</title>
    <url>/2020/09/20/%E5%9F%BA%E7%A1%80%E6%8B%93%E6%89%91%E5%AD%A6%E7%AC%94%E8%AE%B0-2-%E6%8B%93%E6%89%91%E4%B8%8D%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="1-拓扑是一门怎么样的学科"><a href="#1-拓扑是一门怎么样的学科" class="headerlink" title="1.拓扑是一门怎么样的学科"></a>1.拓扑是一门怎么样的学科</h2><p><img src="/images/20200916183934174.png" alt="在这里插入图片描述"><br>拓扑学本质来讲是<strong>分类学</strong></p>
<a id="more"></a>
<h2 id="2-如何分类，标准是什么"><a href="#2-如何分类，标准是什么" class="headerlink" title="2.如何分类，标准是什么?"></a>2.如何分类，标准是什么?</h2><p><img src="/images/20200916184033120.png" alt="在这里插入图片描述"><br>日常生活中，一般通过对比两个事物来辨别两个物体是否是同一类，如水果和香蕉都属于水果，而电脑属于电子产品。</p>
<p>数学中要说明事物相同则需要满足所有条件，而证明不同则只需要提出一个条件，也就是说证明相同困难，而判断不同比较容易。</p>
<h2 id="3-使用拓扑不变量作为标准进行分类"><a href="#3-使用拓扑不变量作为标准进行分类" class="headerlink" title="3.使用拓扑不变量作为标准进行分类"></a>3.使用拓扑不变量作为标准进行分类</h2><p><img src="/images/20200916184854732.png" alt="在这里插入图片描述"><br><img src="/images/20200916184917682.png" alt="在这里插入图片描述"><br><img src="/images/20200916184937481.png" alt="在这里插入图片描述"><br><img src="/images/2020091622061225.png" alt="在这里插入图片描述"><br><img src="/images/20200916220619163.png" alt="在这里插入图片描述"><br>定点数并不是不变量，拓扑学不研究。</p>
<p><img src="/images/20200917094830126.png" alt="在这里插入图片描述"></p>
<h2 id="4-一些拓扑不变量"><a href="#4-一些拓扑不变量" class="headerlink" title="4.一些拓扑不变量"></a>4.一些拓扑不变量</h2><h3 id="4-1联通区数目"><a href="#4-1联通区数目" class="headerlink" title="4.1联通区数目"></a>4.1联通区数目</h3><p><img src="/images/20200917165940385.png" alt="在这里插入图片描述"></p>
<h3 id="4-2-分点"><a href="#4-2-分点" class="headerlink" title="4.2 分点"></a>4.2 分点</h3><p><img src="/images/20200917170012245.png" alt="在这里插入图片描述"><br><img src="/images/20200917170024987.png" alt="在这里插入图片描述"></p>
<h3 id="4-3-点的指数"><a href="#4-3-点的指数" class="headerlink" title="4.3 点的指数"></a>4.3 点的指数</h3><p><img src="/images/20200917170134797.png" alt="在这里插入图片描述"></p>
<h3 id="4-4-一笔画成"><a href="#4-4-一笔画成" class="headerlink" title="4.4 一笔画成"></a>4.4 一笔画成</h3><p><img src="/images/20200917170201812.png" alt="在这里插入图片描述"></p>
<h3 id="4-5-图形是”平的”"><a href="#4-5-图形是”平的”" class="headerlink" title="4.5 图形是”平的”"></a>4.5 图形是”平的”</h3><p><img src="/images/20200917170251795.png" alt="在这里插入图片描述"><br><img src="/images/20200917170306580.png" alt="在这里插入图片描述"><br><img src="/images/20200917170333463.png" alt="在这里插入图片描述"><br><img src="/images/20200917170345898.png" alt="在这里插入图片描述"></p>
<h3 id="4-6-约当定理"><a href="#4-6-约当定理" class="headerlink" title="4.6 约当定理"></a>4.6 约当定理</h3><p><img src="/images/20200917170537679.png" alt="在这里插入图片描述"><br><img src="/images/20200917170551568.png" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>拓扑学</category>
      </categories>
      <tags>
        <tag>拓扑</tag>
        <tag>拓扑不变量</tag>
      </tags>
  </entry>
  <entry>
    <title>基础拓扑学笔记(1)--欧拉定理</title>
    <url>/2020/09/20/%E5%9F%BA%E7%A1%80%E6%8B%93%E6%89%91%E5%AD%A6%E7%AC%94%E8%AE%B0-1-%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>基本拓扑学=1/3点集拓扑+2/3 代数拓扑<br>微分几何 微分流形</p>
<h2 id="1-顶点数-棱数-面数-2"><a href="#1-顶点数-棱数-面数-2" class="headerlink" title="1.顶点数-棱数+面数 = 2"></a>1.顶点数-棱数+面数 = 2</h2><p><img src="/images/VEF1.png" alt="在这里插入图片描述"><br><strong>V</strong>=Vertex 顶点数 <strong>E</strong>= Edge 边数 <strong>F</strong>=Face 面数</p>
<a id="more"></a>
<h2 id="2-凹多面体与凸多面体"><a href="#2-凹多面体与凸多面体" class="headerlink" title="2.凹多面体与凸多面体"></a>2.凹多面体与凸多面体</h2><p>多面体:若干个多边形沿着边粘出来的曲面所围成的立体、</p>
<p><img src="/images/image-20200920161940825.png" alt="image-20200920161940825"></p>
<p>凸多面体的任何截面都是凸多边形，与凹多面体相反。</p>
<p>把凸多面体的任何一个面伸展成平面，它的所有其他各面都在这个平面的同侧。</p>
<p><img src="\images\watermar00.png" alt="在这里插入图片描述"></p>
<h2 id="3-欧拉定理的弱化版本-凸多面体"><a href="#3-欧拉定理的弱化版本-凸多面体" class="headerlink" title="3.欧拉定理的弱化版本(凸多面体)"></a>3.欧拉定理的弱化版本(凸多面体)</h2><p><img src="/images/20200915104904603.png" alt="在这里插入图片描述"><br><strong>最后一个计算没有意义因为顶面的形状不算是多边形，也就说其形状并非多面体。为满足多面体的定义当然不满足欧拉定理</strong></p>
<p>但是如果加几条边的话，使得围成的图形都是多边形在进行计算则满足欧拉定理<br><img src="/images/20200915105113586.png" alt="在这里插入图片描述"></p>
<h2 id="4-挖穿的洞"><a href="#4-挖穿的洞" class="headerlink" title="4.挖穿的洞"></a>4.挖穿的洞</h2><p>如果把上面的正方体所凿出的洞挖透会如何？<br><img src="/images/20200915105947861.png" alt="图5"><br>结果会变成V-e+f=0</p>
<h2 id="5-问题"><a href="#5-问题" class="headerlink" title="5.问题"></a>5.问题</h2><p>例1-4 为何v-e+f相同？</p>
<p>例5为何v-e+f与1-4不同，其本质区别是什么？</p>
<p>答案:<br><img src="/images/20200915110231188.png" alt="在这里插入图片描述"><br><img src="/images/20200915110345216.png" alt="在这里插入图片描述"><br>例1-4可连续变化为球面<br>例5可变化为轮胎面</p>
<p>也就是说欧拉定理与具体的几何形状无关，而更深层的几何结构有关</p>
<h2 id="6-推广为更一般的定理-n个洞"><a href="#6-推广为更一般的定理-n个洞" class="headerlink" title="6.推广为更一般的定理(n个洞)"></a>6.推广为更一般的定理(n个洞)</h2><p><img src="/images/20200915155542166.png" alt="在这里插入图片描述"><br><img src="/images/20200915155806298.png" alt="在这里插入图片描述"><br><img src="/images/20200916183519130.png" alt="在这里插入图片描述"></p>
<h2 id="7-另一个特性-闭形式与恰当形式"><a href="#7-另一个特性-闭形式与恰当形式" class="headerlink" title="7.另一个特性 闭形式与恰当形式"></a>7.另一个特性 闭形式与恰当形式</h2><p><strong>光滑函数（smooth function）:在其定义域内无穷阶数连续可导的函数。</strong><br><img src="/images/20200915165746709.png" alt="在这里插入图片描述"><br>例如，指数函数显然是光滑的，因为指数函数的导数是指数函数本身。</p>
<p>因为没学过这个闭形式是否为恰当形式 ，有点听不懂，之后补上笔记。</p>
<p>参考:</p>
<iframe id="nJsf0wRl-1600252630632" src="https://player.bilibili.com/player.html?aid=92141490" allowfullscreen="true" data-mediaembed="bilibili" style="box-sizing: border-box; outline: 0px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; margin: 0px; padding: 0px; font-weight: normal; overflow-wrap: break-word; display: block; width: 660px; height: 330px;"></iframe>

<p>基础拓扑学(a first course in topology)</p>
]]></content>
      <categories>
        <category>拓扑学</category>
      </categories>
      <tags>
        <tag>欧拉</tag>
        <tag>拓扑</tag>
      </tags>
  </entry>
  <entry>
    <title>U-Net与胰腺分割学习（1）</title>
    <url>/2020/08/29/U-Net%E4%B8%8E%E8%83%B0%E8%85%BA%E5%88%86%E5%89%B2%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p><strong>怕什么真理无穷 进一寸有一寸的欢喜 - -胡适</strong></p>
<h1 id="TCIA-The-Cancer-Imaging-Archive"><a href="#TCIA-The-Cancer-Imaging-Archive" class="headerlink" title="TCIA (The Cancer Imaging Archive)"></a><strong>TCIA (The Cancer Imaging Archive)</strong></h1><p>TCIA是一个包含常见肿瘤（肺癌、前列腺癌等）医学图像及相应临床信息（治疗方案细节、基因、病理等）的大规模公用数据库，其影像模态包括MRI、CT等，图像格式均为DICOM，并且网站内数据在持续增加。所有数据都是由TCIA整理并管理。</p>
<p><strong>网址：<a href="http://www.cancerimagingarchive.net/" target="_blank" rel="noopener">http://www.cancerimagingarchive.net/</a></strong></p>
<p><strong>通过点击Download下载，在电脑上得到后缀名为’.tcia’的文件，注意该文件必须通过‘NBIA DATA Retriever’软件打开，打开后就可以通过选择保存路径，开始下载数据集；</strong>(需要VPN)</p>
<p><img src="/images/image-20200829081625498.png" alt="image-20200829081625498"></p>
<a id="more"></a>
<h1 id="管理conda"><a href="#管理conda" class="headerlink" title="管理conda"></a>管理conda</h1><p>conda添加到环境变量</p>
<p><img src="/images/image-20200906175024434.png" alt="image-20200906175024434"></p>
<h2 id="1-验证conda已被安装"><a href="#1-验证conda已被安装" class="headerlink" title="1. 验证conda已被安装"></a>1. 验证conda已被安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda --version</span><br></pre></td></tr></table></figure>
<h2 id="2-获取当前环境中已安装的包信息"><a href="#2-获取当前环境中已安装的包信息" class="headerlink" title="2. 获取当前环境中已安装的包信息"></a>2. 获取当前环境中已安装的包信息</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">list</span></span><br></pre></td></tr></table></figure>
<h2 id="Python包安装错误的解决办法"><a href="#Python包安装错误的解决办法" class="headerlink" title="Python包安装错误的解决办法"></a>Python包安装错误的解决办法</h2><p>EnvironmentNotWritableError: The current user does not have write permissions to the target environment.<br>  environment location: C:\ProgramData\Anaconda3</p>
<p><strong>无法写入错误：当前的用户没有写入到该路径文件的权限</strong></p>
<p>以管理员身份启动Anaconda（Anaconda Navigator或者Anaconda Prompt）</p>
<h1 id="安装Pydicom"><a href="#安装Pydicom" class="headerlink" title="安装Pydicom"></a>安装Pydicom</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge pydicom</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20200829085508826.png" alt="image-20200829085508826"></p>
<p>安装完毕</p>
<p><img src="/images/image-20200829090259936.png" alt="image-20200829090259936"></p>
<p>ImportError:通过“import dicom”的Pydicom已经在Pydicom 1.0版本中被删除，请安装dicom包来恢复依赖于Pydicom 0.9的代码的功能或更早。例如，pip install dicom交替，大多数代码可以轻松转换为pydicom&gt;1.0通过改变import 1ines从import dicom到import pydicomiSee过渡指南</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install dicom</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20200829091543359.png" alt="image-20200829091543359"></p>
<p><img src="/images/image-20200829091629383.png" alt="image-20200829091629383"></p>
<h1 id="DICOM转换为Numpy数组数据"><a href="#DICOM转换为Numpy数组数据" class="headerlink" title="DICOM转换为Numpy数组数据"></a>DICOM转换为Numpy数组数据</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python dicom2npy.py</span><br></pre></td></tr></table></figure>
<p>执行Python文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pydicom</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">N = <span class="number">82</span></span><br><span class="line">W = <span class="number">512</span></span><br><span class="line">H = <span class="number">512</span></span><br><span class="line">path1 = <span class="string">'DOI'</span></span><br><span class="line">path2 = <span class="string">'images'</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path2):</span><br><span class="line">    os.makedirs(path2)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(N):</span><br><span class="line">    volumeID = <span class="string">'&#123;:0&gt;4&#125;'</span>.format(n + <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 宽度 ：后带填充的字符 0001~0082</span></span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'Processing File '</span> + volumeID)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'正在处理文件'</span> + volumeID)</span><br><span class="line">    <span class="comment"># Processing File 0001 ~0082</span></span><br><span class="line">    filename1 = <span class="string">'PANCREAS_'</span> + volumeID</span><br><span class="line">    <span class="comment"># PANCREAS_0001 ~PANCREAS_0082</span></span><br><span class="line">    directory1 = os.path.join(path1, filename1)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">'directory1:'</span> + directory1)</span><br><span class="line">    <span class="comment"># 把目录和文件名合成一个路径 directory1 = DOI/PANCREAS_0001/</span></span><br><span class="line">    filename2 = volumeID + <span class="string">'.npy'</span></span><br><span class="line">    <span class="comment"># filename2 = 0001.npy ~0082.npy</span></span><br><span class="line">    <span class="keyword">for</span> path_, _, file_ <span class="keyword">in</span> os.walk(directory1):</span><br><span class="line">    <span class="comment">#for dirpath, _dirnames,filenames in os.walk(path):</span></span><br><span class="line">        <span class="keyword">print</span> (path_,_,file_)</span><br><span class="line">    <span class="comment"># 文件夹的绝对路径，dirpath  文件夹下的子文件夹的名字，dirnames 文件夹的文件的名字，filenames</span></span><br><span class="line">    <span class="comment">#注意，函数会自动改变root的值使得遍历所有的子文件夹。、</span></span><br><span class="line">    <span class="comment">#所以返回的三元元组的个数为所有子文件夹（包括子子文件夹，子子子文件夹等等）加上1（根文件夹）。</span></span><br><span class="line">        L = len(file_)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 文件夹内文件的个数 files 同样是 list , 内容是该文件夹中所有的文件(不包括子目录)</span></span><br><span class="line">        <span class="keyword">if</span> L &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'  '</span> + str(L) + <span class="string">' slices along the axial view.'</span>)</span><br><span class="line">            <span class="comment">#沿轴向视图切片</span></span><br><span class="line">            data = np.zeros((W, H, L), dtype = np.int16)</span><br><span class="line">            <span class="keyword">for</span> f <span class="keyword">in</span> sorted(file_):</span><br><span class="line">                file1 = os.path.abspath(os.path.join(path_, f)) <span class="comment">#绝对路径</span></span><br><span class="line">                <span class="keyword">print</span> (<span class="string">'file1:'</span> + file1)</span><br><span class="line"></span><br><span class="line">                image = pydicom.read_file(file1)</span><br><span class="line">                sliceID = image.data_element(<span class="string">"InstanceNumber"</span>).value - <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> image.pixel_array.shape[<span class="number">0</span>] != <span class="number">512</span> <span class="keyword">or</span> image.pixel_array.shape[<span class="number">1</span>] != <span class="number">512</span>:</span><br><span class="line">                    exit(<span class="string">'  Error: DICOM image does not fit '</span> + str(W) + <span class="string">'x'</span> + str(H) + <span class="string">' size!'</span>)</span><br><span class="line">                data[:, :, sliceID] = image.pixel_array</span><br><span class="line">            file2 = os.path.join(path2, filename2)</span><br><span class="line">            np.save(file2, data)</span><br><span class="line">            <span class="keyword">print</span>  (<span class="string">'File '</span> + volumeID + <span class="string">' is saved in '</span> + file2 + <span class="string">' .'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20200829124210777.png" alt="image-20200829124210777"></p>
<h1 id="Nibabel"><a href="#Nibabel" class="headerlink" title="Nibabel"></a>Nibabel</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install -c conda-forge nibabel</span><br></pre></td></tr></table></figure>
<p><strong>然后我发现他这个执行脚本是Linux的…</strong></p>
<p>在VMware安装Ubuntu的时候发现下载异常的慢，然后上网搜要跳过SKIP（- -）换源</p>
<h2 id="在Ubuntu里安装Anaconda"><a href="#在Ubuntu里安装Anaconda" class="headerlink" title="在Ubuntu里安装Anaconda"></a>在Ubuntu里安装Anaconda</h2><p><img src="/images/image-20200831131826360.png" alt="image-20200831131826360"></p>
<p><img src="/images/image-20200831141406162.png" alt="image-20200831141406162"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /mnt/hgfs/UbuntuSharedFolder</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash Anaconda3-2020.07-Linux-x86_64.sh</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20200831142210489.png" alt="image-20200831142210489"></p>
<p>Anaconda3的安装目录</p>
<p>退出终端，重新进来就出现了<code>（base）</code>，则安装成功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~/anaconda3/bin/activate root</span><br><span class="line">anaconda-navigator</span><br></pre></td></tr></table></figure>
<p>出现anaconda图形界面加载一会儿，就可以将其添加到任务栏或收藏夹上，下次可直接点击该图标即可实现可视化anaconda图形界面的操作。</p>
<p><img src="/images/image-20200831143804721.png" alt="image-20200831143804721"></p>
<p>然后安装Pydicom和上面步骤一样</p>
<p>更改脚本里的文件夹路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DIR=&quot;/mnt/hgfs/UbuntuSharedFolder/images&quot;</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20200831150621669.png" alt="image-20200831150621669"></p>
<h1 id="CUDA安装"><a href="#CUDA安装" class="headerlink" title="CUDA安装"></a>CUDA安装</h1><p>不知道为什么CUDA安装完虚拟机就崩了，崩溃中…虚拟机方案失败，接下来试试子系统</p>
<p>网上搜索了一下好像虚拟机不能用CUDA加速，难道真的要安装双系统了吗..</p>
<p>先来试一试Windows的Ubuntu子系统看能不能使用物理显卡加速深度学习计算</p>
<p>先试试结果怎么样，真要用服务器计算的话就之后再说</p>
<h2 id="Win10安装Ubuntu子系统"><a href="#Win10安装Ubuntu子系统" class="headerlink" title="Win10安装Ubuntu子系统"></a>Win10安装Ubuntu子系统</h2><p><img src="/images/image-20200831171018968.png" alt="image-20200831171018968"></p>
<p><img src="/images/image-20200831171032146.png" alt="image-20200831171032146"></p>
<p><img src="/images/image-20200831171449706.png" alt="image-20200831171449706"></p>
<h3 id="关于Linux的安装位置"><a href="#关于Linux的安装位置" class="headerlink" title="关于Linux的安装位置"></a>关于Linux的安装位置</h3><p><img src="/images/image-20200831172440951.png" alt="image-20200831172440951"></p>
<h3 id="WindowsAPP拒绝访问的解决办法"><a href="#WindowsAPP拒绝访问的解决办法" class="headerlink" title="WindowsAPP拒绝访问的解决办法"></a>WindowsAPP拒绝访问的解决办法</h3><p><img src="/images/image-20200831172922907.png" alt="image-20200831172922907"></p>
<p><img src="/images/image-20200831172952822.png" alt="image-20200831172952822"></p>
<p><img src="/images/image-20200831173004117.png" alt="image-20200831173004117"></p>
<p>其中我把Administrator换为了Everyone</p>
<p><img src="/images/image-20200831173013623.png" alt="image-20200831173013623"></p>
<p><img src="/images/image-20200831173021885.png" alt="image-20200831173021885"></p>
<h3 id="找到了Ubuntu安装位置"><a href="#找到了Ubuntu安装位置" class="headerlink" title="找到了Ubuntu安装位置"></a>找到了Ubuntu安装位置</h3><p><img src="/images/image-20200831173346443.png" alt="image-20200831173346443"></p>
<h3 id="换源"><a href="#换源" class="headerlink" title="换源"></a>换源</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /etc/apt</span><br><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list_b</span><br><span class="line">sudo nano sources.list</span><br></pre></td></tr></table></figure>
<p>Ctrl+K全删完</p>
<ul>
<li>中科大镜像</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="——————————-废弃"><a href="#——————————-废弃" class="headerlink" title="——————————-废弃"></a>——————————-废弃</h3><h3 id="安装VcXsrv"><a href="#安装VcXsrv" class="headerlink" title="安装VcXsrv"></a>安装VcXsrv</h3><p><a href="https://sourceforge.net/projects/vcxsrv/" target="_blank" rel="noopener">https://sourceforge.net/projects/vcxsrv/</a></p>
<p><img src="/images/image-20200831174918176.png" alt="image-20200831174918176"></p>
<p>其余默认下一步</p>
<p><img src="/images/image-20200831175232910.png" alt="image-20200831175232910"></p>
<p>保存设置到桌面直接启动</p>
<p><img src="/images/image-20200831175252286.png" alt="image-20200831175252286"></p>
<h3 id="Ubuntu内安装桌面环境"><a href="#Ubuntu内安装桌面环境" class="headerlink" title="Ubuntu内安装桌面环境"></a>Ubuntu内安装桌面环境</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ubuntu-desktop unity compizconfig-settings-manager</span><br></pre></td></tr></table></figure>
<h3 id="——————————————废弃"><a href="#——————————————废弃" class="headerlink" title="——————————————废弃"></a>——————————————废弃</h3><p>尝试之后发现XcXsrv并不好用，还报了很多错，放弃。</p>
<h2 id="通过本机远程桌面"><a href="#通过本机远程桌面" class="headerlink" title="通过本机远程桌面"></a>通过本机远程桌面</h2><p><strong>安装xorg（</strong>包括显卡驱动、图形环境库等等一系列软件包<strong>）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install xorg</span><br></pre></td></tr></table></figure>
<p><strong>安装xfce4（</strong>运行在类Unix操作系统上，提供轻量级桌面环境<strong>）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install xfce4</span><br></pre></td></tr></table></figure>
<p><strong>安装xrdp（</strong>一种开源的远程桌面协议（RDP）服务器<strong>）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install xrdp</span><br></pre></td></tr></table></figure>
<p><strong>配置xrdp（</strong>配置端口<strong>）</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo sed -i &apos;s/port=3389/port=3390/g&apos; /etc/xrdp/xrdp.ini</span><br></pre></td></tr></table></figure>
<p><strong>向.xsession中写入xfce4-session</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo echo xfce4-session &gt;~/.xsession</span><br></pre></td></tr></table></figure>
<p><strong>重启xrdp服务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service xrdp restart</span><br></pre></td></tr></table></figure>
<p>在Cortana中搜索远程桌面连接，点击进入，计算机栏输入【本机IP:端口】，用户名栏输入子系统用户名，点击连接。</p>
<p>127.0.0.1:<strong>3390</strong></p>
<p><img src="/images/image-20200831185502855.png" alt="image-20200831185502855"></p>
<h1 id="PiP设置"><a href="#PiP设置" class="headerlink" title="PiP设置"></a>PiP设置</h1><p>临时使用 加参数-i <a href="https://pypi.tuna.tsinghua.edu.cn/simple" target="_blank" rel="noopener">https://pypi.tuna.tsinghua.edu.cn/simple</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pyspider</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir ~/.pip</span><br><span class="line">cd .pip</span><br><span class="line">touch pip.conf</span><br><span class="line">nano pip.conf</span><br></pre></td></tr></table></figure>
<p>pip.conf内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure>
<h1 id="Tensenflow安装"><a href="#Tensenflow安装" class="headerlink" title="Tensenflow安装"></a>Tensenflow安装</h1><p>安完Ubuntu没有pip,先安装pip</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python3-dev python-scipy python-numpy python-matplotlib python-pandas python-nose</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Requires the latest pip 升级pip</span><br><span class="line">pip install --upgrade pip</span><br><span class="line"># Current stable release for CPU and GPU</span><br><span class="line">pip install tensorflow</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python-pip</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install tensorflow</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 系统升级</span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt upgrade</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 安装python基础开发包</span><br><span class="line">sudo apt install -y python-dev python-pip python-nose gcc g++ git gfortran vim</span><br></pre></td></tr></table></figure>
<ul>
<li>安装运算加速库 打开<code>终端</code>输入：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install -y libopenblas-dev liblapack-dev libatlas-base-dev</span><br></pre></td></tr></table></figure>
<h2 id="CUDA开发环境的搭建"><a href="#CUDA开发环境的搭建" class="headerlink" title="CUDA开发环境的搭建"></a>CUDA开发环境的搭建</h2><p><a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-downloads</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1604/x86_64/cuda-ubuntu1604.pin</span><br><span class="line">sudo mv cuda-ubuntu1604.pin /etc/apt/preferences.d/cuda-repository-pin-600</span><br><span class="line">wget https://developer.download.nvidia.com/compute/cuda/11.0.3/local_installers/cuda-repo-ubuntu1604-11-0-local_11.0.3-450.51.06-1_amd64.deb</span><br><span class="line">sudo dpkg -i cuda-repo-ubuntu1604-11-0-local_11.0.3-450.51.06-1_amd64.deb</span><br><span class="line">sudo apt-key add /var/cuda-repo-ubuntu1604-11-0-local/7fa2af80.pub</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install cuda</span><br></pre></td></tr></table></figure>
<ul>
<li>将CUDA路径添加至环境变量 在<code>终端</code>输入：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/profile</span><br></pre></td></tr></table></figure>
<p>在<code>profile</code>文件中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CUDA_HOME=/usr/local/cuda-11.0</span><br><span class="line">export PATH=/usr/local/cuda-11.0/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;</span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-11.0/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>之后<code>source /etc/profile</code>即可</p>
<ul>
<li>测试 在<code>终端</code>输入：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvcc -V</span><br></pre></td></tr></table></figure>
<p>会得到相应的nvcc编译器相应的信息，那么CUDA配置成功了。(<strong>记得重启系统</strong>)</p>
<p>如果要进行<code>cuda性能测试</code>，可以进行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local/cuda/samples</span><br><span class="line">sudo make -j8</span><br></pre></td></tr></table></figure>
<p>编译完成后，可以进<code>samples/bin/.../.../...</code>的底层目录，运行各类实例。</p>
<h2 id="no-CUDA-capable-device-is-detected"><a href="#no-CUDA-capable-device-is-detected" class="headerlink" title="no CUDA-capable device is detected"></a>no CUDA-capable device is detected</h2><p><a href="https://www.zhihu.com/question/349262900" target="_blank" rel="noopener">请问win10下的ubuntu子系统可以配置gpu深度学习环境吗？</a></p>
<p>win10下使用Ubuntu子系统调用GPU失败，下一个方案，docker调用GPU搭建深度学习环境</p>
<h1 id="Keras安装"><a href="#Keras安装" class="headerlink" title="Keras安装"></a>Keras安装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip install keras</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/daybreak222/article/details/87968078" target="_blank" rel="noopener">Win10安装Ubuntu子系统及图形化界面详细教程</a></p>
<p><a href="http://www.xitongcheng.com/jiaocheng/win10_article_45151.html" target="_blank" rel="noopener">Win10系统下WindowsApps文件夹拒绝访问如何获取权限</a></p>
<p><a href="https://www.cnblogs.com/raisok/p/10847869.html" target="_blank" rel="noopener">win10 linux Ubuntu 18.04更换国内源</a></p>
]]></content>
      <tags>
        <tag>CNN</tag>
        <tag>前馈神经网络</tag>
        <tag>图像识别</tag>
        <tag>U-Net</tag>
        <tag>胰腺分割</tag>
      </tags>
  </entry>
  <entry>
    <title>CNN FCN U-Net 卷积神经网络学习（1）</title>
    <url>/2020/08/24/CNN-FCN-U-Net-%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前馈神经网络"><a href="#前馈神经网络" class="headerlink" title="前馈神经网络"></a>前馈神经网络</h1><h2 id="图像的表示和数字长方体"><a href="#图像的表示和数字长方体" class="headerlink" title="图像的表示和数字长方体"></a>图像的表示和数字长方体</h2><p>图像在计算机中是一堆按顺序排列的数字,数值为0到255,0表示最暗, 255表示最亮。你可以把这堆数字用一个长长的向量来表示。然而这样会失去平面结构的信息,为保留该结构信息,通常选择矩阵的表示方式: 28x28的矩阵。</p>
<p>上图是只有黑白颜色的灰度图,而更普遍的图片表达方式是RGB颜色模型,即红(Red)、绿(Green) 、蓝(Blue)三原色的色光以不同的比例相加,以产生多种多样的色光。</p>
<p>在电脑中,一张图片是数字构成的”长方体” 。可用宽width,高height,深depth来描述,如图。</p>
<p><img src="/images/image-20200824172554595.png" alt="image-20200824172554595"></p>
<h2 id="画面不变性"><a href="#画面不变性" class="headerlink" title="画面不变性"></a>画面不变性</h2><p>在决定如何处理”数字长方体”之前,需要清楚所建立的网络拥有什么样的特点。我们知道一个物体不管在画面左侧还是右侧,都会被识别为同一物体,这一特点就是不变性(invariance) ,如下图所示。</p>
<p><img src="/images/image-20200824172638285.png" alt="image-20200824172638285"></p>
<p>我们希望所建立的网络可以尽可能的满足这些不变性特点。为了理解卷积神经网络对这些不变性特点的贡献,我们将用不具备这些不变性特点的前馈神经网络来进行比较。</p>
<h2 id="前馈神经网络的图像识别"><a href="#前馈神经网络的图像识别" class="headerlink" title="前馈神经网络的图像识别"></a>前馈神经网络的图像识别</h2><p>方便起见,我们用depth只有1的灰度图来举例。想要完成的任务是:在宽长为4x4的图片中识别是否有下图所示的”横折”。图中,黄色圆点表示值为0的像素,深色圆点表示值为1的像素。我们知道不管这个横折在图片中的什么位置,都会被认为是相同的横折。</p>
<p><img src="/images/image-20200824172855849.png" alt="image-20200824172855849"></p>
<p>若训练前馈神经网络来完成该任务,那么表达图像的三维张量将会被摊平成一个向量,作为网络的输入,即(width, height, depth)为(4, 4, 1)的图片会被展成维度为16的向量作为网络的输入层。再经过几层不同节点个数的隐藏层,最终输出两个节点,分别表示“有横折的概率”和”没有横折的概率” ,如下图所示。</p>
<p><img src="/images/image-20200824172944449.png" alt="image-20200824172944449"></p>
<p>下面我们用数字(16进制)对图片中的每一个像素点(pixel)进行编号。当使用右侧那种物体位于中间的训练数据来训练网络时,网络就只会对编号为5,6,9,a的节点的权重进行调节。若让该网络识别位于右下角的”横折”时,则无法识别。</p>
<p><img src="/images/image-20200824173118513.png" alt="image-20200824173118513"></p>
<p>解决办法是用大量物体位于不同位置的数据训练,同时增加网络的隐藏层个数从而扩大网络学习这些变体的能力。</p>
<h2 id="前馈神经网络的缺点"><a href="#前馈神经网络的缺点" class="headerlink" title="前馈神经网络的缺点"></a>前馈神经网络的缺点</h2><p>然而这样做十分不效率,因为我们知道在左侧的“横折”也好,还是在右侧的”横折”也罢,大家都是”横折”。为什么相同的东西在位置变了之后要重新学习?有没有什么方法可以将中间所学到的规律也运用在其他的位置?换句话说,也就是让不同位置用相同的权重。</p>
<p>卷积神经网络CNN就是让权重在不同位置共享的神经网络。</p>
<h2 id="CNN的局部扫描"><a href="#CNN的局部扫描" class="headerlink" title="CNN的局部扫描"></a>CNN的局部扫描</h2><p>在卷积神经网络中,我们先选择一个局部区域,用这个局部区域去扫描整张图片。局部区域所圈起来的所有节点会被连接到下一层的一个节点上。</p>
<p><img src="/images/image-20200824173504606.png" alt="image-20200824173504606"></p>
<p><img src="/images/image-20200824173541949.png" alt="image-20200824173541949"></p>
<p><img src="/images/image-20200824173605600.png" alt="image-20200824173605600"></p>
<h2 id="CNN的输出"><a href="#CNN的输出" class="headerlink" title="CNN的输出"></a>CNN的输出</h2><p><img src="/images/image-20200824173623590.png" alt="image-20200824173623590"></p>
<p><img src="/images/image-20200824173650926.png" alt="image-20200824173650926"></p>
<h2 id="深度为复数的情况"><a href="#深度为复数的情况" class="headerlink" title="深度为复数的情况"></a>深度为复数的情况</h2><p>现在我们已经知道了depth维度只有1的灰度图是如何处理的。但前文提过,图片的普遍表达方式是下图这样有3个channels的RGB颜色模型。当depth为复数的时候,每个feature detector是如何卷积的?</p>
<p><img src="/images/image-20200824173812745.png" alt="image-20200824173812745"></p>
<p>在输入depth为1时:被filter size为2x2所圈中的4个输入节点连接到1个输出节点上。</p>
<p>在输入depth为3时:被filter size为2x2,但是贯串3个channels后,所圈中的12个输入节点连接到1个输出节点上。</p>
<p>在输入depth为n时: 2x2xn个输入节点连接到1个输出节点上。</p>
<p><img src="/images/image-20200824173747971.png" alt="image-20200824173747971"></p>
<h1 id="CNN（卷积神经网络）"><a href="#CNN（卷积神经网络）" class="headerlink" title="CNN（卷积神经网络）"></a>CNN（卷积神经网络）</h1><p>Facebook 将神经网络用于自动标注算法、谷歌将它用于图片搜索、亚马逊将它用于商品推荐、Pinterest 将它用于个性化主页推送、Instagram 将它用于搜索架构。</p>
<p>然而，应用神经网络网络最经典最流行的案例是进行图像处理。在图像处理任务中，使用卷积神经网络进行<strong>图像分类</strong>。</p>
<p>图像分类是对输入图像的操作，最终输出一组最好地描述了图像内容的分类（如猫、狗等）或分类的概率。对人类来说，识别是打出生便开始学习的技能之一，对成人来说更是信手拈来，毫不费力。我们只需一眼便能快速识别我们所处的环境以及环绕在我们身边的物体。当我们看到一张图片或是环看四周的时候，无需刻意观察，多数时候也能立即描述出场景特征并标记出每一个对象。快速识别不同模式、根据早前知识进行归纳、以及适应不同的图像环境一直都是人类的专属技能，机器尚未享有。</p>
<p><img src="/images/image-20200824163735498.png" alt="image-20200824163735498"></p>
<p>当计算机看到一张图像（输入一张图像）时，它看的是一大堆像素值。根据图片的分辨率和尺寸，它将看到一个 32 x 32 x 3 的数组（3 指代的是 RGB 值）。假设我们有一张 JPG 格式的 480 x 480 大小的彩色图片，那么它对应的数组就有 480 x 480 x 3 个元素。其中每个数字的值从 0 到 255 不等，其描述了对应那一点的像素灰度。当我们人类对图像进行分类时，这些数字毫无用处，可它们却是计算机可获得的唯一输入。其中的思想是：当你提供给计算机这一数组后，它将输出描述该图像属于某一特定分类的概率的数字（比如：80% 是猫、15% 是狗、5% 是鸟）。</p>
<p>我们想要计算机能够区分开所有提供给它的图片，以及搞清楚猫猫狗狗各自的特有特征。这也是我们人类的大脑中不自觉进行着的过程。当我们看到一幅狗的图片时，如果有诸如爪子或四条腿之类的明显特征，我们便能将它归类为狗。同样地，计算机也可以通过寻找诸如边缘和曲线之类的低级特点来分类图片，继而通过一系列卷积层级建构出更为抽象的概念。这是 CNN（卷积神经网络）工作方式的大体概述，</p>
<p>挑一张图像，让它历经一系列卷积层、非线性层、池化（下采样（downsampling））层和完全连接层，最终得到输出。输出可以是最好地描述了图像内容的一个单独分类或一组分类的概率。</p>
<h2 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h2><p>CNN 的第一层通常是卷积层（Convolutional Layer）。首先需要了解卷积层的输入内容是什么。输入内容为一个 32 x 32 x 3 的像素值数组。现在，解释卷积层的最佳方法是想象有一束手电筒光正从图像的左上角照过。假设手电筒光可以覆盖 5 x 5 的区域，想象一下手电筒光照过输入图像的所有区域。</p>
<p>在机器学习术语中，这束手电筒被叫做过滤器（filter，有时候也被称为神经元（neuron）或核（kernel）），被照过的区域被称为感受野（receptive field）。过滤器同样也是一个数组（其中的数字被称作权重或参数）。重点在于过滤器的深度必须与输入内容的深度相同（这样才能确保可以进行数学运算），因此过滤器大小为 5 x 5 x 3。</p>
<p>现在，以过滤器所处在的第一个位置为例，即图像的左上角。当筛选值在图像上滑动（卷积运算）时，过滤器中的值会与图像中的原始像素值相乘（又称为计算点积）。这些乘积被加在一起（从数学上来说，一共会有 75 个乘积）。现在你得到了一个数字。切记，该数字只是表示过滤器位于图片左上角的情况。我们在输入内容上的每一位置重复该过程。（下一步将是将过滤器右移 1 单元，接着再右移 1 单元，以此类推。）输入内容上的每一特定位置都会产生一个数字。</p>
<p>过滤器滑过所有位置后将得到一个 28 x 28 x 1 的数组，我们称之为激活映射（activation map）或特征映射（feature map）。之所以得到一个 28 x 28 的数组的原因在于，在一张 32 x 32 的输入图像上，5 x 5 的过滤器能够覆盖到 784 个不同的位置。这 784 个位置可映射为一个 28 x 28 的数组。</p>
<p>当我们使用两个而不是一个 5 x 5 x 3 的过滤器时，输出总量将会变成  28 x 28 x 2。采用的过滤器越多，空间维度（ spatial dimensions）保留得也就越好。</p>
<p><img src="/images/image-20200824164140102.png" alt="image-20200824164140102"></p>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>不过，从高层次角度而言卷积是如何工作的？每个过滤器可以被看成是特征标识符（ feature identifiers）。这里的特征指的是例如直边缘、原色、曲线之类的东西。想一想所有图像都共有的一些最简单的特征。假设第一组过滤器是 7 x 7 x 3 的曲线检测器。（在这一节，为了易于分析，暂且忽略该过滤器的深度为 3 个单元，只考虑过滤器和图像的顶层层面。）作为曲线过滤器，它将有一个像素结构，在曲线形状旁时会产生更高的数值（切记，我们所讨论的过滤器不过是一组数值！）</p>
<p><img src="/images/image-20200824164751404.png" alt="image-20200824164751404"></p>
<p>回到数学角度来看这一过程。当我们将过滤器置于输入内容的左上角时，它将计算过滤器和这一区域像素值之间的点积。拿一张需要分类的照片为例，将过滤器放在它的左上角。</p>
<p><img src="/images/image-20200824164819642.png" alt="image-20200824164819642"></p>
<p>简单来说，如果输入图像上某个形状看起来很像过滤器表示的曲线，那么所有点积加在一起将会得出一个很大的值！让我们看看移动过滤器时会发生什么。</p>
<p><img src="/images/image-20200824164837169.png" alt="image-20200824164837169"></p>
<p>这个值小了很多！这是因为图像的这一部分和曲线检测器过滤器不存在对应。记住，这个卷积层的输出是一个激活映射（activation map）。因此，在这个带有一个过滤器卷积的例子里（当筛选值为曲线检测器），激活映射将会显示出图像里最像曲线的区域。在该例子中，28 x 28 x 1 的激活映射的左上角的值为 6600。高数值意味着很有可能是输入内容中的曲线激活了过滤器。激活地图右上角的值将会是 0，因为输入内容中没有任何东西能激活过滤器（更简单地说，原始图片中的这一区域没有任何曲线）。</p>
<p>这仅仅是一组检测右弯曲线的过滤器。还有其它检测左弯曲线或直线边缘的过滤器。过滤器越多，激活映射的深度越大，我们对输入内容的了解也就越多。</p>
<p><img src="/images/image-20200824165644252.png" alt="image-20200824165644252"></p>
<p>为了预测出图片内容的分类，网络需要识别更高级的特征，例如手、爪子与耳朵的区别。第一个卷积层的输出将会是一个 28 x 28 x 3 的数组（假设我们采用三个 5 x 5 x 3 的过滤器）。当我们进入另一卷积层时，第一个卷积层的输出便是第二个卷积层的输入。</p>
<p>第一层的输入是原始图像，而第二卷积层的输入正是第一层输出的激活映射。也就是说，这一层的输入大体描绘了低级特征在原始图片中的位置。在此基础上再采用一组过滤器（让它通过第 2 个卷积层），输出将是表示了更高级的特征的激活映射。这类特征可以是半圆（曲线和直线的组合）或四边形（几条直线的组合）。随着进入网络越深和经过更多卷积层后，将得到更为复杂特征的激活映射。</p>
<h3 id="形状的抓取"><a href="#形状的抓取" class="headerlink" title="形状的抓取"></a>形状的抓取</h3><p>知道了每个filter在做什么之后,我们再来思考这样的一个filter会抓取到什么样的信息。我们知道不同的形状都可由细小的”零件”组合而成的。</p>
<p>比如下图中,用2x2的范围所形成的16种形状可以组合成格式各样的”更大”形状。卷积的每个filter可以探测特定的形状。又由于Feature Map保持了抓取后的空间结构。若将探测到细小图形的Feature Map作为新的输入再次卷积后,则可以由此探测到”更大”的形状概念。比如下图的第一个“大”形状可由2,3,4,5基础形状拼成。第二个可由2,4,5,6组成。第三个可由6,1组成。</p>
<p><img src="/images/image-20200824174111970.png" alt="image-20200824174111970"></p>
<p>除了基础形状之外,颜色、对比度等概念对画面的识别结果也有影响。卷积层也会根据需要去探测特定的概念。</p>
<p>可以从下面这张图中感受到不同数值的filters所卷积过后的Feature Map可以探测边缘,棱角,模糊,突出等概念。</p>
<p><img src="/images/image-20200824174134995.png" alt="image-20200824174134995"></p>
<p>而filter内的权重矩阵W是网络根据数据学习得到的,也就是说,我们让神经网络自己学习以什么样的方式去观察图片。</p>
<p>拿老妇与少女的那幅图片举例,当标签是少女时,卷积网络就会学习抓取可以成少女的形状、概念。当标签是老妇时,卷积网络就会学习抓取可以成老妇的形状、概念。</p>
<h3 id="多个过滤器"><a href="#多个过滤器" class="headerlink" title="多个过滤器"></a>多个过滤器</h3><p>每个过滤器可以抓取探测特定的形状的存在。假如我们要探测下图的长方框形状时,可以用4个过滤器去探测4个基础”零件”</p>
<p><img src="/images/image-20200824175040587.png" alt="image-20200824175040587"></p>
<p>因此我们自然而然的会选择用多个不同的filters对同一个图片进行多次抓取。如下图(动态图过大,如果显示不出,请看到该链接观看) ,同一个图片,经过两个(红色、绿色)不同的filters扫描过后可得到不同特点的Feature Maps,每增加一个filter,就意味着你想让网络多抓取一个特征。</p>
<p><img src="/images/image-20200824175208570.png" alt="image-20200824175208570"></p>
<p><img src="/images/image-20200824175222522.png" alt="image-20200824175222522"></p>
<p>这样卷积层的输出也不再是depth为1的一个平面,而是和输入一样是depth为复数的长方体。</p>
<p>如下图所示,当我们增加一个filter (紫色表示)后,就又可以得到一个Feature Map。将不同filters所卷积得到的Feature Maps按顺序堆叠后,就得到了一个卷积层的最终输出。</p>
<p><img src="/images/image-20200824175255843.png" alt="image-20200824175255843"></p>
<p>这样卷积后输出的长方体可以作为新的输入送入另一个卷积层中处理。</p>
<h3 id="加入非线性"><a href="#加入非线性" class="headerlink" title="加入非线性"></a>加入非线性</h3><p>和前馈神经网络一样,经过线性组合和偏移后,会加入非线性增强模型的拟合能力。</p>
<p>将卷积所得的Feature Map经过ReLU变换(elementwise)后所得到的output就如下图所展示。</p>
<p><img src="/images/image-20200824175441671.png" alt="image-20200824175441671"></p>
<h2 id="完全连接层"><a href="#完全连接层" class="headerlink" title="完全连接层"></a>完全连接层</h2><p>检测高级特征之后，网络最后的完全连接层就更是锦上添花了。简单地说，这一层处理输入内容（该输入可能是卷积层、ReLU 层或是池化层的输出）后会输出一个 N 维向量，N 是该程序必须选择的分类数量。例如，如果你想得到一个数字分类程序，如果有 10  个数字，N 就等于 10。这个 N 维向量中的每一数字都代表某一特定类别的概率。例如，如果某一数字分类程序的结果矢量是 [0 .1 .1 .75 0 0 0 0 0 .05]，则代表该图片有 10% 的概率是 1、10% 的概率是 2、75% 的概率是 3、还有 5% 的概率是 9（注：还有其他表现输出的方式，这里只展示了 softmax 的方法）。</p>
<p>完全连接层观察上一层的输出（其表示了更高级特征的激活映射）并确定这些特征与哪一分类最为吻合。例如，如果该程序预测某一图像的内容为狗，那么激活映射中的高数值便会代表一些爪子或四条腿之类的高级特征。同样地，如果程序测定某一图片的内容为鸟，激活映射中的高数值便会代表诸如翅膀或鸟喙之类的高级特征。大体上来说，完全连接层观察高级特征和哪一分类最为吻合和拥有怎样的特定权重，因此当计算出权重与先前层之间的点积后，你将得到不同分类的正确概率。</p>
<p><img src="/images/image-20200824170829653.png" alt="image-20200824170829653"></p>
<h2 id="步幅和填充"><a href="#步幅和填充" class="headerlink" title="步幅和填充"></a><strong>步幅和填充</strong></h2><p>选择了过滤器的尺寸以后，我们还需要选择步幅（stride）和填充（padding）。</p>
<h3 id="步长"><a href="#步长" class="headerlink" title="步长"></a>步长</h3><p>步幅控制着过滤器围绕输入内容进行卷积计算的方式。在第一部分我们举的例子中，过滤器通过每次移动一个单元的方式对输入内容进行卷积。过滤器移动的距离就是步幅。在那个例子中，步幅被默认设置为1。步幅的设置通常要确保输出内容是一个整数而非分数。让我们看一个例子。想象一个 7 x 7 的输入图像，一个 3 x 3 过滤器（简单起见不考虑第三个维度），步幅为 1。这是一种惯常的情况。</p>
<p><img src="/images/image-20200824171041218.png" alt="image-20200824171041218"></p>
<p><img src="/images/image-20200824171048563.png" alt="image-20200824171048563"></p>
<p>感受野移动了两个单元，输出内容同样也会减小。注意，如果试图把我们的步幅设置成 3，那我们就会难以调节间距并确保感受野与输入图像匹配。正常情况下，程序员如果想让接受域重叠得更少并且想要更小的空间维度（spatial dimensions）时，他们会增加步幅。</p>
<h3 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h3><p>现在让我们看一下填充（padding）。在此之前，想象一个场景：当你把 5 x 5 x 3 的过滤器用在 32 x 32 x 3 的输入上时，会发生什么？输出的大小会是 28 x 28 x 3。注意，这里空间维度减小了。如果我们继续用卷积层，尺寸减小的速度就会超过我们的期望。</p>
<p>在网络的早期层中，我们想要尽可能多地保留原始输入内容的信息，这样我们就能提取出那些低层的特征。比如说我们想要应用同样的卷积层，但又想让输出量维持为 32 x 32 x 3 。为做到这点，我们可以对这个层应用大小为 2 的零填充（zero padding）。零填充在输入内容的边界周围补充零。如果我们用两个零填充，就会得到一个 36 x 36 x 3 的输入卷。</p>
<p><img src="/images/image-20200824171233700.png" alt="image-20200824171233700"></p>
<h2 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h2><p>在几个 ReLU 层之后，程序员也许会选择用一个池化层（pooling layer）。它同时也被叫做下采样（downsampling）层。在这个类别中，也有几种可供选择的层，最受欢迎的就是最大池化（ max-pooling）。它基本上采用了一个过滤器（通常是 2x2 的）和一个同样长度的步幅。然后把它应用到输入内容上，输出过滤器卷积计算的每个子区域中的最大数字。</p>
<p><img src="/images/image-20200824171937608.png" alt="image-20200824171937608"></p>
<p>Max pooling的主要功能是downsampling,却不会损坏识别结果。这意味着卷积后的FeatureMap中有对于识别物体不必要的冗余信息。那么我们就反过来思考,这些”冗”信息是如何产生的。</p>
<p>直觉上,我们为了探测到某个特定形状的存在,用一个filer对整个图片进行逐步扫描。但只有出现了该特定形状的区域所卷积获得的输出才是真正有用的,用该filter卷积其他区域得出的数值就可能对该形状是否存在的判定影响较小。</p>
<p>比如下图中,我们还是考虑探测”横折”这个形状。卷积后得到3x3的Feature Map中,真正有用的就是数字为3的那个节点,其余数值对于这个任务而言都是无关的。所以用3x3的Max pooling后,并没有对“横折”的探测产生影响。试想在这里例子中如果不使用Max pooling,而让网络自己去学习。网络也会去学习与Max pooling近似效果的权重。因为是近似效果,增加了更多的parameters的代价,却还不如直接进行Max pooling</p>
<p><img src="/images/image-20200824181250361.png" alt="image-20200824181250361"></p>
<p>池化层还有其他选择，比如平均池化（average pooling）和 L2-norm 池化 。这一层背后的直观推理是：一旦我们知道了原始输入（这里会有一个高激活值）中一个特定的特征，它与其它特征的相对位置就比它的绝对位置更重要。可想而知，这一层大幅减小了输入卷的空间维度（长度和宽度改变了，但深度没变）。</p>
<p>这到达了两个主要目的。第一个是权重参数的数目减少到了75%，因此降低了计算成本。第二是它可以控制过拟合（overfitting）。这个术语是指一个模型与训练样本太过匹配了，以至于用于验证和检测组时无法产生出好的结果。出现过拟合的表现是一个模型在训练集能达到 100% 或 99% 的准确度，而在测试数据上却只有50%。</p>
<h2 id="数据增强技术"><a href="#数据增强技术" class="headerlink" title="数据增强技术"></a><strong>数据增强技术</strong></h2><p>如何利用一些简单的转换方法将你现有的数据集变得更大。正如我们之前所提及的，当计算机将图片当作输入时，它将用一个包含一列像素值的数组描述（这幅图）。若是图片左移一个像素。对你和我来说，这种变化是微不可察的。然而对计算机而已，这种变化非常显著：这幅图的类别和标签保持不变，数组却变化了。</p>
<p>这种改变训练数据的数组表征而保持标签不变的方法被称作数据增强技术。这是一种人工扩展数据集的方法。人们经常使用的增强方法包括灰度变化、水平翻转、垂直翻转、随机编组、色值跳变、翻译、旋转等其他多种方法。通过利用这些训练数据的转换方法，你将获得两倍甚至三倍于原数据的训练样本。</p>
<h1 id="FCN-全卷积网络-Fully-Convolutional-Network"><a href="#FCN-全卷积网络-Fully-Convolutional-Network" class="headerlink" title="FCN(全卷积网络)(Fully Convolutional Network)"></a>FCN(全卷积网络)(Fully Convolutional Network)</h1><h2 id="分割-语义，实例，全景分割"><a href="#分割-语义，实例，全景分割" class="headerlink" title="分割(语义，实例，全景分割)"></a>分割(语义，实例，全景分割)</h2><p>分割，顾名思义，就是把一个完整的东西按照某种方式或规则分成若干个部分。</p>
<p>那么什么是图像分割呢？简单来说，就是把图像中属于同一类别或同一个体的东西划分在一起，并将各个子部分区分开来。像下图这样：</p>
<p><img src="/images/image-20200825153649825.png" alt="image-20200825153649825"></p>
<p>为了训练神经网络，图片中这些像素点会按照某种规则被贴上一个“标签”，比如这个像素点是属于人、天空、草地还是树；更详细一点，可以再给它们第二个标签，声明它们是属于“哪一个人”或“哪一棵树”。</p>
<p>对于只有一个标签的（只区分类别）的任务，我们称之为<strong>“语义分割”（semantic segmentation）</strong>；</p>
<p>对于区分相同类别的不同个体的，则称之为<strong>实例分割（instance segmentation）</strong>。</p>
<p>由于实例分割往往只能分辨可数目标，因此，为了同时实现实例分割与不可数类别的语义分割，2018年Alexander Kirillov等人提出了<strong>全景分割（panoptic segmentation）</strong>的概念。</p>
<p>下图分别展示了（a）原始图像，（b）语义分割，（c）实例分割和（d）全景分割。</p>
<p><img src="/images/image-20200825153755444.png" alt="image-20200825153755444"></p>
<h2 id="语义分割"><a href="#语义分割" class="headerlink" title="语义分割"></a>语义分割</h2><p>图像语义分割(Semantic Segmentation)是图像处理和是机器视觉技术中关于图像理解的重要一环，也是 AI 领域中一个重要的分支。语义分割即是对图像中每一个像素点进行分类，确定每个点的类别（如属于背景、人或车等），从而进行区域划分。目前，语义分割已经被广泛应用于自动驾驶、无人机落点判定等场景中。</p>
<p><img src="/images/image-20200824181720616.png" alt="image-20200824181720616"></p>
<p>截止目前，CNN已经在图像分类分方面取得了巨大的成就，涌现出如VGG和Resnet等网络结构，并在ImageNet中取得了好成绩。CNN的强大之处在于它的多层结构能自动学习特征，并且可以学习到多个层次的特征：</p>
<p>这些抽象特征对物体的大小、位置和方向等敏感性更低，从而有助于分类性能的提高。这些抽象的特征对分类很有帮助，可以很好地判断出一幅图像中包含什么类别的物体。<strong>图像分类是图像级别的！</strong></p>
<p><img src="/images/image-20200824181810618.png" alt="image-20200824181810618"></p>
<p>与分类不同的是，语义分割需要判断图像每个像素点的类别，进行精确分割。<strong>图像语义分割是像素级别的！</strong>但是由于CNN在进行convolution和pooling过程中丢失了图像细节，即feature map size逐渐变小，所以不能很好地指出物体的具体轮廓、指出每个像素具体属于哪个物体，无法做到精确的分割。</p>
<p>针对这个问题，<a href="https://link.zhihu.com/?target=http%3A//people.eecs.berkeley.edu/~jonlong/" target="_blank" rel="noopener">Jonathan Long</a>等人提出了<strong>Fully Convolutional Networks（FCN）</strong>用于图像语义分割。自从提出后，FCN已经成为语义分割的基本框架，后续算法其实都是在这个框架中改进而来。</p>
<h2 id="FCN与CNN区别"><a href="#FCN与CNN区别" class="headerlink" title="FCN与CNN区别"></a>FCN与CNN区别</h2><p>对于一般的分类CNN网络，如VGG和Resnet，都会在网络的最后加入一些全连接层，经过softmax后就可以获得类别概率信息。但是这个概率信息是1维的，即只能标识整个图片的类别，不能标识每个像素点的类别，所以这种全连接方法不适用于图像分割。</p>
<p><img src="/images/image-20200824181946499.png" alt="image-20200824181946499"></p>
<p>而FCN提出可以把后面几个全连接都换成卷积，这样就可以获得一张2维的feature map，后接softmax获得每个像素点的分类信息，从而解决了分割问题，如图4。</p>
<p><img src="/images/image-20200824182012059.png" alt="image-20200824182012059"></p>
<p><img src="/images/image-20200824182045698.png" alt="image-20200824182045698"></p>
<h2 id="反卷积与上采样"><a href="#反卷积与上采样" class="headerlink" title="反卷积与上采样"></a>反卷积与上采样</h2><p><strong>上采样（upsampling）一般包括2种方式：</strong></p>
<ol>
<li>Resize，如双线性插值直接缩放，类似于图像缩放</li>
<li>Deconvolution，也叫Transposed Convolution</li>
</ol>
<p>对于一般卷积，输入蓝色4x4矩阵，卷积核大小3x3。当设置卷积参数pad=0，stride=1时，卷积输出绿色2x2矩阵，如图6。</p>
<p><img src="/images/image-20200824182236071.png" alt="image-20200824182236071"></p>
<p>而对于反卷积，相当于把普通卷积反过来，输入蓝色2x2矩阵（周围填0变成6x6），卷积核大小还是3x3。当设置反卷积参数pad=0，stride=1时输出绿色4x4矩阵，如图7，这相当于完全将图4倒过来</p>
<p><img src="/images/image-20200824182254014.png" alt="image-20200824182254014"></p>
<p>传统的网络是subsampling的，对应的输出尺寸会降低；<strong>upsampling的意义在于将小尺寸的高维度feature map恢复回去</strong>，以便做pixelwise prediction，获得每个点的分类信息。</p>
<p><img src="/images/image-20200824182310073.png" alt="image-20200824182310073"></p>
<p>上采样在FCN网络中的作用如图8，明显可以看到经过上采样后恢复了较大的pixelwise feature map，这其实相当于一个Encode-Decode的过程。 （编码和解码</p>
<h2 id="FCN的缺陷"><a href="#FCN的缺陷" class="headerlink" title="FCN的缺陷"></a>FCN的缺陷</h2><ul>
<li>无法解决实例分割问题</li>
<li>速度远不能达到实时</li>
<li>不能够应对诸如3D点云等不定型数据</li>
</ul>
<p><img src="/images/image-20200825154150329.png" alt="image-20200825154150329"></p>
<h1 id="U-Net"><a href="#U-Net" class="headerlink" title="U-Net"></a>U-Net</h1><p>U-Net是一种分割网络，能够适应很小的训练集（大约30张图）。</p>
<p><img src="/images/image-20200824182811504.png" alt="image-20200824182811504"></p>
<p>整个U-Net网络结构如图9，类似于一个大大的U字母：首先进行Conv+Pooling下采样；然后Deconv反卷积进行上采样，crop之前的低层feature map，进行融合；然后再次上采样。重复这个过程，直到获得输出388x388x2的feature map，最后经过softmax获得output segment map。总体来说与FCN思路非常类似。</p>
<p>Unet 网络结构是对称的，形似英文字母 U 所以被称为 Unet。整张图都是由蓝/白色框与各种颜色的箭头组成，其中，<strong>蓝/白色框表示 feature map；蓝色箭头表示 3x3 卷积，用于特征提取；灰色箭头表示 skip-connection，用于特征融合；红色箭头表示池化 pooling，用于降低维度；绿色箭头表示上采样 upsample，用于恢复维度；青色箭头表示 1x1 卷积，用于输出结果</strong>。</p>
<p><strong>U-Net采用了与FCN完全不同的特征融合方式：拼接！</strong></p>
<p><img src="/images/image-20200824182930397.png" alt="image-20200824182930397"></p>
<p>与FCN逐点相加不同，U-Net采用将特征在channel维度拼接在一起，形成更“厚”的特征。所以：</p>
<h2 id="两种特征融合方法"><a href="#两种特征融合方法" class="headerlink" title="两种特征融合方法"></a>两种特征融合方法</h2><p><strong>语义分割网络在特征融合时也有2种办法：</strong></p>
<ol>
<li>FCN式的逐点相加，</li>
<li>U-Net式的channel维度拼接融合</li>
</ol>
<p><img src="/images/image-20200824183103024.png" alt="image-20200824183103024"></p>
<p>运用CNN的分割问题上，主要分为以FCN为基础的结构，和以U-Net为基础的结构。前者的encoder-decoder是非对称的，后者的encoder-decoder是对称的；</p>
<h2 id="U-Net为何适用于医学图像"><a href="#U-Net为何适用于医学图像" class="headerlink" title="U-Net为何适用于医学图像"></a>U-Net为何适用于医学图像</h2><h2 id="医学图像特点"><a href="#医学图像特点" class="headerlink" title="医学图像特点"></a>医学图像特点</h2><ol>
<li>图像语义较为简单、结构较为固定。我们做脑的，就用脑CT和脑MRI，做胸片的只用胸片CT，做眼底的只用眼底OCT，都是一个固定的器官的成像。由于器官本身结构固定和语义信息没有特别丰富，所以高级语义信息和低级特征都显得很重要(UNet的skip connection和U型结构就派上了用场)。</li>
<li>数据量少。医学影像的数据获取相对难一些，很多比赛只提供不到100例数据。所以我们设计的模型不宜过大，如果参数过多，很容易导致过拟合。</li>
<li>多模态。相比自然影像，医疗影像比较有趣和不同的一点是，医疗影像是具有多种模态的。以ISLES脑梗竞赛为例，其官方提供了CBF,MTT,CBV,TMAX,CTP等多种模态的数据。这就需要我们更好的设计网络去提取不同模态的特征feature。。</li>
<li>可解释性重要。由于医疗影像最终是辅助医生的临床诊断，所以网络告诉医生一个3D的CT有没有病是远远不够的，医生还要进一步的想知道，病灶在哪一层，在哪一层的哪个位置，分割出来了吗，能求体积嘛？同时对于网络给出的分类和分割等结果，医生还想知道为什么，也就是说从医生角度出发，更希望知道医疗AI的可解释性如何<br>解释医学影像以Attention及CAM(class-activation-map)等可视化方法为主。</li>
</ol>
<p>因为医学图像边界模糊、梯度复杂，需要较多的高分辨率信息。高分辨率用于精准分割。</p>
<p>人体内部结构相对固定，分割目标在人体图像中的分布很具有规律，语义简单明确，低分辨率信息能够提供这一信息，用于目标物体的识别。<br>UNet结合了<strong>低分辨率信息</strong>（提供物体类别识别依据）和<strong>高分辨率信息</strong>（提供精准分割定位依据），完美适用于医学图像分割。</p>
<h1 id="Seg-Net"><a href="#Seg-Net" class="headerlink" title="Seg-Net"></a>Seg-Net</h1><h2 id="解码器"><a href="#解码器" class="headerlink" title="解码器"></a>解码器</h2><p>分割任务中的编码器encode与解码器decode就像是玩“你来比划我来猜”的双方：比划的人想把看到的东西用一种方式描述出来，猜的人根据比划的人提供的信息猜出答案。</p>
<p>其中，“比划的人”叫做<strong>编码器</strong>，“猜的人”就是<strong>解码器</strong>。</p>
<p>具体来说，编码器的任务是在给定输入图像后，通过神经网络学习得到输入图像的特征图谱；而解码器则在编码器提供特征图后，逐步实现每个像素的类别标注，也就是分割。</p>
<p>通常，分割任务中的编码器结构比较类似，大多来源于用于分类任务的网络结构，比如VGG。这样做有一个好处，就是可以借用在大数据库下训练得到的分类网络的权重参数，通过迁移学习实现更好的效果。因此，<strong>解码器的不同在很大程度上决定了一个基于编解码结构的分割网络的效果。</strong></p>
<p><img src="/images/image-20200825154816865.png" alt="image-20200825154816865"></p>
<p>SegNet的编码器结构与解码器结构是一一对应的，即一个decoder具有与其对应的encoder相同的空间尺寸和通道数。对于基础SegNet结构，二者各有13个卷积层，其中编码器的卷积层就对应了VGG16网络结构中的前13个卷积层。</p>
<p>下图是SegNet的网络结构，其中蓝色代表卷积+Batch Normalization+ReLU，绿色代表max-pooling，红色代表上采样，黄色是Softmax。</p>
<p><img src="/images/image-20200825154846862.png" alt="image-20200825154846862"></p>
<p>SegNet与FCN的对应结构相比，体量要小很多。这主要得益于SegNet中为了权衡计算量而采取的操作：用记录的池化过程的位置信息替代直接的反卷积操作。具体如下图所示。</p>
<h2 id="Seg-Net与FCN解码方式的不同"><a href="#Seg-Net与FCN解码方式的不同" class="headerlink" title="Seg-Net与FCN解码方式的不同"></a>Seg-Net与FCN解码方式的不同</h2><p><img src="/images/image-20200825154906316.png" alt="image-20200825154906316"></p>
<p>图中左侧是SegNet使用的解码方式，右侧是FCN对应的解码方式。可以看到，SegNet的做法是先根据位置信息生成稀疏的特征图，再利用后续的卷积计算恢复稠密特征图。而FCN则直接利用反卷积操作求得上采样后的特征图，再将其与编码器特征图相加。</p>
<h2 id="改变解码器的参数"><a href="#改变解码器的参数" class="headerlink" title="改变解码器的参数"></a>改变解码器的参数</h2><p>前文已经提到，编解码结构中，解码器的效果和复杂程度对于整个分割网络的影响是非常大的。这里我们就一起来看一下不同解码器结构和它们的效果。</p>
<p>SegNet中一共尝试了8种不同的解码结构，先上结果：</p>
<p><img src="/images/image-20200825155038967.png" alt="image-20200825155038967"></p>
<p>这些变体共用相同的编码器结构，只是在解码器结构上有所不同。比如，将解码器的结构单纯减少层数，改变解码器最后一层通道数，改变编解码器对应结构之间的连接方式（只连接池化信息、保留特征层内信息或全部保留），改变采样方式等。</p>
<p>除上面几种变体外，论文中还尝试了改变上采样方法，或取消池化和下采样过程，但是这些改变都没有带来更好的结果。</p>
<h2 id="解码器总结"><a href="#解码器总结" class="headerlink" title="解码器总结"></a>解码器总结</h2><ul>
<li>保留编码器所有特征图所实现的效果最好，在这一点上语义分割边缘轮廓描述度量（BF）体现最为明显。</li>
<li>当推理过程的内存受限时，可以使用编码器特征图的压缩形式（比如缩小维度、使用池化信息等），但需要搭配合适的解码器形式（比如SegNet类型的）来提升表现。</li>
<li>在给定编码器时，越大的解码器效果越好。</li>
</ul>
<p><img src="/images/image-20200825155141488.png" alt="image-20200825155141488"></p>
<h1 id="图像处理的非深度学习方法"><a href="#图像处理的非深度学习方法" class="headerlink" title="图像处理的非深度学习方法"></a>图像处理的非深度学习方法</h1><p>图像分割是什么？如果下学术定义，就是把图像分割成想要的语义上相同的若干子区域，看上面的自动驾驶的分割任务，路是路，车是车，树是树。</p>
<p>这些子区域，组成图像的完备子集，相互之间不重叠。图像分割可以被看作是一个逐像素的图像分类问题</p>
<p>没有深度学习的那些年，也发展出了非常多的图像分割技术。</p>
<h2 id="边缘与阈值法"><a href="#边缘与阈值法" class="headerlink" title="边缘与阈值法"></a>边缘与阈值法</h2><p>简单的边缘检测也曾被用于图像分割，但是因为要做复杂后处理以及后面和其他方法有重叠，这里就不再说了，而是从阈值法开始说。</p>
<p>阈值法的基本思想是基于图像的灰度特征来计算一个或多个灰度阈值，并将图像中每个像素的灰度值与阈值相比较。</p>
<p>其中，最广泛使用也最具有代表性质就是OTSU【1】方法，它是用于灰度图像分割的方法，核心思想就是使<strong>类间方差最大</strong>。</p>
<p>这样的方法，非常简单，要求被分割的物体颜色纹理比较紧凑，类内方差小，只适合一些文本图像的处理，比如车牌，比如指纹。</p>
<p><img src="/images/image-20200825160014067.png" alt="image-20200825160014067"></p>
<h2 id="区域增长，分裂"><a href="#区域增长，分裂" class="headerlink" title="区域增长，分裂"></a>区域增长，分裂</h2><p>阈值法的一个硬伤是太粗暴简单，哪怕是自适应的局部阈值法，一样难逃无法分割类内方差较大的目标的宿命。它完全没有利用好像素的空间信息，导致分割结果极其容易受噪声干扰，经常出现断裂的边缘，需要后处理。</p>
<p>所以，<strong>区域生长法出现了，它通过一些种子点，再加上相似性准则来不断扩充区域直到达到类别的边界</strong>，这时候分割结果是连续的了。</p>
<p>区域分裂则是反过程，不再详述。区域增长法的佼佼者，就是分水岭算法【2】。</p>
<p>分水岭算法是一种基于拓扑理论的数学形态学的分割方法，将图像中每一点像素的灰度值表示该点的海拔高度，每一个局部极小值称为集水盆，而集水盆的边界则是分水岭。分水岭算法有很多种实现算法，常用浸水模拟法。</p>
<p><strong>分水岭算法对于弱边缘有不错的响应</strong>，因此常被用于材料图像的分割，以及产生超像素用于提高其他方法的分割效率。咱在硕士期间也与师姐鼓捣过半导体材料的分割，还不错。</p>
<p><img src="/images/image-20200825160125758.png" alt="image-20200825160125758"></p>
<p>说到这里，超像素也是很重要的一种方法，某种程度上也能被归为图像分割的方法。SLIC，Meanshift等都是非常经典的方法，去文【3】中做更详细解读吧。</p>
<p><img src="/images/image-20200825160151786.png" alt="image-20200825160151786"></p>
<h2 id="图割"><a href="#图割" class="headerlink" title="图割"></a>图割</h2><p>以graphcut【4】为代表的图割方法，是传统图像分割里面鲁棒性最好的方法，它是一种概率无向图模型(Probabilistic undirected graphical model)，又被称Markov random field马尔可夫随机场。</p>
<p>Graphcut的基本思路，就是建立一张图，看下面这张图，其中以图像像素或者超像素作为图像顶点，然后优化的目标就是要找到一个切割，使得各个子图不相连从而实现分割，前提是移除边的和权重最小。</p>
<p>后来图割方法从MRF发展到CRF，也就是条件随机场。它通常包含两个优化目标，一个是区域的相似度，被称为区域能量项，即piecewise能量。一个是被切断边的相似度，被称为边缘能量项，即pairwise能量。它追求区域能量项的最大化以及边缘能量的最小化，也就是<strong>区域内部越相似越好，区域间相似度越低越好。</strong></p>
<p>图割方法很通用，对于纹理比较复杂的图像分割效果也不错。缺点是时间复杂度和空间复杂度较高，所以通常使用超像素进行加速计算，上面的分水岭算法就可以拿来用用。</p>
<p><img src="/images/image-20200825160228037.png" alt="image-20200825160228037"></p>
<p>graphcut的迭代版本，也就是grabcut【5】更好用，它的基本思路是；使用混合高斯<strong>模型(Gaussian Mixture Model，GMM)</strong>替代了graphcut基于灰度的模型，初始的混合高斯模型的构建，通过用户交互来指定，只需要指定确定性的背景像素区域即可，通常是画一个框。</p>
<p>多年以后再看下面这张图，效果依然是惊艳的，边缘很不错。不像上面的几个方法，图割方法仍然被广泛使用，deeplab系列的前几篇文章就用到了全连接的crf，它与mrf的区别可以参考这篇文章【Discriminative fields for modeling spatial dependencies in natural images】。</p>
<p><img src="/images/image-20200825160259976.png" alt="image-20200825160259976"></p>
<h2 id="轮廓模型"><a href="#轮廓模型" class="headerlink" title="轮廓模型"></a>轮廓模型</h2><p>轮廓模型大部分人可能不知道，它的<strong>基本思想是使用连续曲线来表达目标轮廓，并定义一个能量泛函，其自变量为曲线，将分割过程转变为求解能量泛函的最小值的过程。</strong>数值实现可通过求解函数对应的欧拉(Euler-Lagrange)方程来实现。包括以snake模型为代表的参数活动轮廓模型和以水平集方法为代表的几何活动轮廓模型。</p>
<p><strong>当能量达到最小时的，曲线位置就处于正确的目标轮廓。</strong></p>
<p>该类分割方法具有几个显著的特点：(1)由于能量泛函是在连续状态下实现，所以最终得到的图像轮廓可以达到较高的精度；(2)通过约束目标轮廓为光滑，同时融入其它关于目标形状的先验信息，算法可以具有较强的鲁棒性；(3)使用光滑的闭合曲线表示物体的轮廓，可获取完整的轮廓，从而避免传统图像分割方法中的预/后处理过程。</p>
<p>不过，缺点也很明显，比较敏感，容易陷入局部极值。</p>
<p>下面是我的硕士论文【6】中采用水平集方法分割出的肿瘤，就是白色那一块。这个方法的数学味有点浓，考虑到咱们是闲聊，就不摆公式了，毕竟后面还有很多事。</p>
<p><img src="/images/image-20200825160334846.png" alt="image-20200825160334846"></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.zhihu.com/question/52668301" target="_blank" rel="noopener">CNN（卷积神经网络）是什么？有何入门简介或文章吗？</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NDIyMjM1NA==&amp;mid=2649032348&amp;idx=1&amp;sn=80825e10fcfd502e2145ed9ce8e6b430&amp;chksm=8712b8e1b06531f7723c37851204ccea66b212b24cf36315a2859aec07dbe0938c9a6bfe59fb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【图像分割模型】编解码结构SegNet</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NDIyMjM1NA==&amp;mid=2649032209&amp;idx=2&amp;sn=ee63ef7fc1ac163cea8277b9a1dcaf84&amp;chksm=8712b86cb065317aa4a79c774614965318a95333952ef31d9b6aaddfae0666d714bc0026cb8f&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【图像分割模型】从FCN说起</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzA3NDIyMjM1NA==&amp;mid=2649029723&amp;idx=1&amp;sn=555a2d45fa210a1c5c5c703de54899a4&amp;chksm=87134226b064cb30f070ea5a2368f1c5bb6679d0f13e7e84b3f6374be33c549ce81a665d6e25&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">【技术综述】闲聊图像分割这件事儿</a></p>
<p><a href="https://zhuanlan.zhihu.com/c_151876233" target="_blank" rel="noopener">有三AI学院</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/72691417" target="_blank" rel="noopener">图像分割之UNet++ 论文笔记</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/43927696" target="_blank" rel="noopener">图像分割之U-Net</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/118540575" target="_blank" rel="noopener">U-Net+与FCN的区别+医学表现+网络详解+创新</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/159173338" target="_blank" rel="noopener">FCN、Unet、Unet++医学图像分割那点事儿</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/79204199" target="_blank" rel="noopener">语义分割网络 U-Net 详解</a></p>
]]></content>
      <categories>
        <category>神经网络</category>
      </categories>
      <tags>
        <tag>CNN</tag>
        <tag>前馈神经网络</tag>
        <tag>图像识别</tag>
      </tags>
  </entry>
  <entry>
    <title>共形几何第四节-不动点，庞加莱-霍普斯定理</title>
    <url>/2020/08/14/%E5%85%B1%E5%BD%A2%E5%87%A0%E4%BD%95%E7%AC%AC%E5%9B%9B%E8%8A%82-%E4%B8%8D%E5%8A%A8%E7%82%B9%EF%BC%8C%E5%BA%9E%E5%8A%A0%E8%8E%B1-%E9%9C%8D%E6%99%AE%E6%96%AF%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<h2 id="布劳威尔-Brouwer-不动点理论"><a href="#布劳威尔-Brouwer-不动点理论" class="headerlink" title="布劳威尔(Brouwer)不动点理论"></a>布劳威尔(Brouwer)不动点理论</h2><p><img src="/images/image-20200814210228342.png" alt="image-20200814210228342"></p>
<p><strong>对于一个拓扑空间中满足一定条件的连续函数f，存在一个点x0，使得f(x0) = x0。</strong></p>
<p>这个定理可以通过很实际的例子来理解。比如：取两张一样大小的白纸，在上面画好垂直的坐标系以及纵横的方格。将一张纸平铺在桌面，而另外一张随意揉成一个形状（但不能撕裂），放在第一张白纸之上，不超出第一张的边界。那么第二张纸上一定有一点正好就在第一张纸的对应点的正上方。一个更简单的说法是：将一张白纸平铺在桌面上，再将它揉成一团（不撕裂），放在原来白纸所在的地方，那么只要它不超出原来白纸平铺时的边界，那么白纸上一定有一点在水平方向上没有移动过。</p>
<p>这个断言的根据就是布劳威尔不动点定理在二维欧几里得空间（欧几里得平面）的情况，因为把纸揉皱是一个连续的变换过程。</p>
<p>另一个例子是大商场等地方可以看到的平面地图，上面标有“您在此处”的红点。如果标注足够精确，那么这个点就是把实际地形射到地图的连续函数的不动点。</p>
<p>地球绕着它的自转轴自转。自转轴在自转过程中是不变的，也就是自转运动的不动点</p>
<p>如果我们用一个密封的锅子煮水，那么总有一个水分子在煮开前的某一刻和煮开后的某一刻处于同样的位置。</p>
<a id="more"></a>
<p><a href="https://www.youtube.com/watch?v=tN5VHfu0Svg" target="_blank" rel="noopener">拓扑学，布劳威尔不动点定理得直观和直接的证明</a></p>
<h2 id="Lefschetz-莱夫谢茨不动点定理"><a href="#Lefschetz-莱夫谢茨不动点定理" class="headerlink" title="(Lefschetz)莱夫谢茨不动点定理"></a>(Lefschetz)莱夫谢茨不动点定理</h2><p>布劳威尔不动点定理是莱夫谢茨不动点定理的特例。</p>
<p>莱夫谢茨不动点定理是布劳威尔不动点定理的推广。</p>
<p><strong>设|K|为有限多面体，f:|K|→|K|为<a href="https://baike.baidu.com/item/连续映射/18916806" target="_blank" rel="noopener">连续映射</a>，若f的莱夫谢茨数L(f)≠0，则f有不动点。</strong></p>
<p><img src="/images/image-20200814212216708.png" alt="image-20200814212216708"></p>
<h2 id="孤立零点"><a href="#孤立零点" class="headerlink" title="孤立零点"></a>孤立零点</h2><p><img src="/images/image-20200814215147535.png" alt="image-20200814215147535"></p>
<h2 id="零点的指标"><a href="#零点的指标" class="headerlink" title="零点的指标"></a>零点的指标</h2><p><img src="/images/image-20200814215339484.png" alt="image-20200814215339484"></p>
<p><img src="/images/image-20200814215849072.png" alt="image-20200814215849072"></p>
<h2 id="庞加莱-霍普夫-Poincare-Hopf-定理"><a href="#庞加莱-霍普夫-Poincare-Hopf-定理" class="headerlink" title="庞加莱-霍普夫(Poincaré-Hopf)定理"></a><strong>庞加莱-霍普夫(Poincaré-Hopf)</strong>定理</h2><p><strong>庞加莱-霍普夫(Poincaré-Hopf)</strong>定理(也称为<strong>庞加莱-霍普夫指标定理</strong>，<strong>庞加莱-霍普夫指标公式</strong>，或<strong>霍普夫指标定理</strong>)是<a href="http://www.wanweibaike.com/wiki-微分拓扑" target="_blank" rel="noopener">微分拓扑</a>的重要定理。</p>
<p><img src="/images/image-20200817154608848.png" alt="image-20200817154608848"></p>
<p><img src="/images/image-20200817154717789.png" alt="image-20200817154717789"></p>
<p><img src="/images/image-20200817154728479.png" alt="image-20200817154728479"></p>
<p><img src="/images/image-20200817154838430.png" alt="image-20200817154838430"></p>
<p><img src="/images/image-20200817154846239.png" alt="image-20200817154846239"></p>
<p><img src="/images/image-20200817160912089.png" alt="image-20200817160912089"></p>
<h2 id="流形"><a href="#流形" class="headerlink" title="流形"></a>流形</h2><p><img src="/images/image-20200817161215934.png" alt="image-20200817161215934"></p>
<p><img src="/images/image-20200817165012506.png" alt="image-20200817165012506"></p>
<p><img src="/images/image-20200817165036534.png" alt="image-20200817165036534"></p>
<p><img src="/images/image-20200817165115345.png" alt="image-20200817165115345"></p>
<p><img src="/images/image-20200817165341939.png" alt="image-20200817165341939"></p>
<p><img src="/images/image-20200817170346054.png" alt="image-20200817170346054"></p>
]]></content>
      <categories>
        <category>共形几何</category>
      </categories>
      <tags>
        <tag>共形几何</tag>
        <tag>笔记</tag>
        <tag>微分流形</tag>
      </tags>
  </entry>
  <entry>
    <title>共形几何第三节-同调群和上同调群Homology and Cohomology</title>
    <url>/2020/07/24/%E5%85%B1%E5%BD%A2%E5%87%A0%E4%BD%95%E7%AC%AC%E4%B8%89%E8%8A%82-%E5%90%8C%E8%B0%83%E7%BE%A4%E5%92%8C%E4%B8%8A%E5%90%8C%E8%B0%83%E7%BE%A4/</url>
    <content><![CDATA[<h1 id="闭合曲面的拓扑"><a href="#闭合曲面的拓扑" class="headerlink" title="闭合曲面的拓扑"></a>闭合曲面的拓扑</h1><p><img src="/images/image-20200726113232194.png" alt="image-20200726113232194"></p>
<p>带有边界的曲面的拓扑</p>
<p><img src="/images/image-20200726113243216.png" alt="image-20200726113243216"></p>
<p>g为洞的数目，b为边界的数目</p>
<a id="more"></a>
<h1 id="连通和"><a href="#连通和" class="headerlink" title="连通和"></a>连通和</h1><p><img src="/images/image-20200726114406417.png" alt="image-20200726114406417"></p>
<p><img src="/images/image-20200726113912895.png" alt="image-20200726113912895"></p>
<p><img src="/images/image-20200726113928708.png" alt="image-20200726113928708"></p>
<p>射影平面</p>
<p><img src="/images/image-20200726114220282.png" alt="image-20200726114220282"></p>
<p><img src="/images/image-20200726114235740.png" alt="image-20200726114235740"></p>
<p><img src="/images/image-20200726122603769.png" alt="image-20200726122603769"></p>
<p>闭合曲面的连通和是可定向的曲面，而具有交叉的曲面的连通和是不可定向的</p>
<p><img src="/images/image-20200726212207039.png" alt="image-20200726212207039"></p>
<h2 id="一些基本连接面"><a href="#一些基本连接面" class="headerlink" title="一些基本连接面"></a>一些基本连接面</h2><p><img src="/images/image-20200726212717260.png" alt="image-20200726212717260"></p>
<h2 id="D-Disk圆盘-S-Sphere球体-T"><a href="#D-Disk圆盘-S-Sphere球体-T" class="headerlink" title="D Disk圆盘 S Sphere球体 T"></a>D Disk圆盘 S Sphere球体 T</h2><p>可定向曲面和不可定向曲面连接和的代数表述</p>
<p><img src="/images/image-20200726213324643.png" alt="image-20200726213324643"></p>
<p><img src="/images/image-20200726212852103.png" alt="image-20200726212852103"></p>
<p><img src="/images/image-20200726213108274.png" alt="image-20200726213108274"></p>
<p><img src="/images/image-20200726213152393.png" alt="image-20200726213152393"></p>
<p>具有三个不同基本结构曲面的连接</p>
<p><img src="/images/image-20200726213216805.png" alt="image-20200726213216805"></p>
<p><img src="/images/image-20200726212907797.png" alt="image-20200726212907797"></p>
<p><img src="/images/image-20200726213041304.png" alt="image-20200726213041304"></p>
<h2 id="球体-环面-S-L"><a href="#球体-环面-S-L" class="headerlink" title="球体+环面 S#L"></a>球体+环面 S#L</h2><p><img src="/images/image-20200726213855932.png" alt="image-20200726213855932"></p>
<p><img src="/images/image-20200726213948575.png" alt="image-20200726213948575"></p>
<p>其结果和环面同胚</p>
<p>实际上球体和任何曲面相连都是一样的</p>
<h2 id="一个假设-球体以外的任何曲面都可以由T-D，IRP三种曲面组合而成"><a href="#一个假设-球体以外的任何曲面都可以由T-D，IRP三种曲面组合而成" class="headerlink" title="一个假设:球体以外的任何曲面都可以由T,D，IRP三种曲面组合而成"></a>一个假设:球体以外的任何曲面都可以由T,D，IRP三种曲面组合而成</h2><p><img src="/images/image-20200726214147520.png" alt="image-20200726214147520"></p>
<p>圆环与莫比斯环 T\D # M\D</p>
<p><img src="/images/image-20200726214217713.png" alt="image-20200726214217713"></p>
<p><img src="/images/image-20200726214323947.png" alt="image-20200726214323947"></p>
<h2 id="圆环的变形"><a href="#圆环的变形" class="headerlink" title="圆环的变形"></a>圆环的变形</h2><p><img src="/images/image-20200726214347558.png" alt="image-20200726214347558"></p>
<p><img src="/images/image-20200726214400900.png" alt="image-20200726214400900"></p>
<p><img src="/images/image-20200726214412082.png" alt="image-20200726214412082"></p>
<p><img src="/images/image-20200726214452854.png" alt="image-20200726214452854"></p>
<h2 id="圆环-莫比乌斯带-T-M"><a href="#圆环-莫比乌斯带-T-M" class="headerlink" title="圆环+莫比乌斯带 T # M"></a>圆环+莫比乌斯带 T # M</h2><p><img src="/images/image-20200726214509388.png" alt="image-20200726214509388"></p>
<h2 id="圆环-圆盘-L-D-L-D"><a href="#圆环-圆盘-L-D-L-D" class="headerlink" title="圆环+圆盘 L#D = L\D"></a>圆环+圆盘 L#D = L\D</h2><p><img src="/images/image-20200726215141449.png" alt="image-20200726215141449"></p>
<p><img src="/images/image-20200726215227502.png" alt="image-20200726215227502"></p>
<p><img src="/images/image-20200726215244751.png" alt="image-20200726215244751"></p>
<p><img src="/images/image-20200726215258963.png" alt="image-20200726215258963"></p>
<p>结果相当于圆环减去一个圆盘  L+D=L-D</p>
<h1 id="Youtube一个讲解射影平面的视频"><a href="#Youtube一个讲解射影平面的视频" class="headerlink" title="Youtube一个讲解射影平面的视频"></a>Youtube一个讲解射影平面的视频</h1><iframe width="560" height="315" src="https://www.youtube.com/embed/dBH-Id8VC3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br><img src="/images/image-20200726155442814.png" alt="image-20200726155442814"><br><br><img src="/images/image-20200726155457405.png" alt="image-20200726155457405"><br><br><img src="/images/image-20200726155514917.png" alt="image-20200726155514917"><br><br><img src="/images/image-20200726155542389.png" alt="image-20200726155542389"><br><br><img src="/images/image-20200726155552526.png" alt="image-20200726155552526"><br><br><img src="/images/image-20200726155611749.png" alt="image-20200726155611749"><br><br>## <strong>投影平面=莫比乌斯环U圆盘Disk</strong><br><br><img src="/images/image-20200726155651316.png" alt="image-20200726155651316"><br><br><img src="/images/image-20200726155700375.png" alt="image-20200726155700375"><br><br><img src="/images/image-20200726155712610.png" alt="image-20200726155712610"><br><br><img src="/images/image-20200726155729988.png" alt="image-20200726155729988"><br><br><img src="/images/image-20200726155800533.png" alt="image-20200726155800533"><br><br><img src="/images/image-20200726155816170.png" alt="image-20200726155816170"><br><br><img src="/images/image-20200726155825266.png" alt="image-20200726155825266"><br><br># 单形与复形<br><br><img src="/images/image-20200726160557373.png" alt="image-20200726160557373"><br><br><a href="https://zhuanlan.zhihu.com/p/137677583" target="_blank" rel="noopener">单纯同调群</a><br><br><img src="/images/image-20200726160718926.png" alt="image-20200726160718926"><br><br><img src="/images/image-20200726160727215.png" alt="image-20200726160727215"><br><br><img src="/images/image-20200726160748741.png" alt="image-20200726160748741"><br><br><img src="/images/image-20200726160834501.png" alt="image-20200726160834501"><br><br>左侧是复形，右侧并非复形，<br><br># 链空间<br><br><img src="/images/image-20200726160946059.png" alt="image-20200726160946059"><br><br># 边界算子<br><br><img src="/images/image-20200726161117794.png" alt="image-20200726161117794"><br><br>边界算子就像是分解 降维<br><br><img src="/images/image-20200727142140492.png" alt="image-20200727142140492"><br><br>一个边界算子计算的例子<br><br><img src="/images/image-20200727142155781.png" alt="image-20200727142155781"><br><br><img src="/images/image-20200727142854652.png" alt="image-20200727142854652"><br><br><img src="/images/image-20200727143111768.png" alt="image-20200727143111768"><br><br>Z 表示圈，B表示边界<br><br><img src="/images/image-20200727143302446.png" alt="image-20200727143302446"><br><br><img src="/images/image-20200727143448145.png" alt="image-20200727143448145"><br><br><img src="/images/image-20200727150954102.png" alt="image-20200727150954102"><br><br>B为<strong>实心图形</strong>的边界<br><br>C为链<br><br><img src="/images/image-20200727151039273.png" alt="image-20200727151039273"><br><br># 闭链<br><br><img src="/images/image-20200726161400361.png" alt="image-20200726161400361"><br><br># 恰当链，边缘链<br><br><img src="/images/image-20200726161527416.png" alt="image-20200726161527416"><br><br>右侧为闭链，但不是恰当链<br><br># 边的边为空<br><br><img src="/images/image-20200726161659174.png" alt="image-20200726161659174"><br><br># 同调群<br><br><img src="/images/image-20200726162007885.png" alt="image-20200726162007885"><br><br><img src="/images/image-20200726162015676.png" alt="image-20200726162015676"><br><br><img src="/images/image-20200727134955577.png" alt="image-20200727134955577"><br><br><img src="/images/image-20200727135241758.png" alt="image-20200727135241758"><br><br><strong>其拓扑空间的三角剖分可以有多个</strong><br><br>## 定向的单形<br><br><img src="/images/image-20200727135831770.png" alt="image-20200727135831770"><br><br>p链等于定向单形的和<br><br><img src="/images/image-20200727140152495.png" alt="image-20200727140152495"><br><br>C1(K)代表单纯复形的一链<br><br>K代表单纯复形<br><br><img src="/images/image-20200727151327730.png" alt="image-20200727151327730"><br><br>一阶同调群为 一阶圈群/一阶边界群<br><br>##  H(K) = Z/B<br><br><br><br><img src="/images/image-20200727151833509.png" alt="image-20200727151833509"><br><br><img src="/images/image-20200727151848877.png" alt="image-20200727151848877"><br><br><img src="/images/image-20200727151855670.png" alt="image-20200727151855670"><br><br>## 环面同调群的计算过程<br><br><img src="/images/image-20200727154132115.png" alt="image-20200727154132115"><br><br><img src="/images/image-20200727154556463.png" alt="image-20200727154556463"><br><br><img src="/images/image-20200727154930164.png" alt="image-20200727154930164"><br><br><img src="/images/image-20200727155229585.png" alt="image-20200727155229585"><br><br><img src="/images/image-20200727155359806.png" alt="image-20200727155359806"><br><br><img src="/images/image-20200727175203674.png" alt="image-20200727175203674"><br><br><img src="/images/image-20200727175351134.png" alt="image-20200727175351134"><br><br><img src="/images/image-20200727175457087.png" alt="image-20200727175457087"><br><br>## 结论:对于一般的拓扑空间，一阶同调群同构与其基本群的abel化<br><br><img src="/images/image-20200727175626648.png" alt="image-20200727175626648"><br><br><iframe src="//player.bilibili.com/player.html?aid=92141490&bvid=BV1P7411N7fW&cid=213222342&page=54" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p><a href="https://zhuanlan.zhihu.com/p/137677583" target="_blank" rel="noopener">单纯同调群</a></p>
<p><img src="/images/image-20200726162602425.png" alt="image-20200726162602425"></p>
<h1 id="上同调群与上链空间"><a href="#上同调群与上链空间" class="headerlink" title="上同调群与上链空间"></a>上同调群与上链空间</h1><p><img src="/images/image-20200726163557458.png" alt="image-20200726163557458"></p>
<p><img src="/images/image-20200726163650680.png" alt="image-20200726163650680"></p>
<h1 id="单纯映射"><a href="#单纯映射" class="headerlink" title="单纯映射"></a>单纯映射</h1><p><img src="/images/image-20200726165536675.png" alt="image-20200726165536675"></p>
<h1 id="映射度"><a href="#映射度" class="headerlink" title="映射度"></a>映射度</h1><p><img src="/images/image-20200726170212704.png" alt="image-20200726170212704"></p>
<p><img src="/images/image-20200726171323106.png" alt="image-20200726171323106"></p>
<p>高斯映射</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/AmgkSdhK4K8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zh.wikipedia.org/wiki/%E5%90%8C%E8%B0%83" target="_blank" rel="noopener">同调维基百科</a></p>
<p><a href="https://en.wikipedia.org/wiki/Simplicial_homology" target="_blank" rel="noopener">Simplicial homology Wiki</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/137677583" target="_blank" rel="noopener">单纯同调群 zhihu</a></p>
<p><a href="https://bkso.baidu.com/item/%E5%8D%95%E7%BA%AF%E5%90%8C%E8%B0%83%E7%BE%A4" target="_blank" rel="noopener">单纯同调群 baike</a></p>
<p><a href="http://blog.sciencenet.cn/blog-2472277-1173812.html" target="_blank" rel="noopener">计算共形几何讲义 （4）单纯同调</a></p>
<p><a href="https://www.bilibili.com/video/BV1ws411q7rw/?spm_id_from=333.788.videocard.6" target="_blank" rel="noopener">[轻松愉快] 拓扑学 Topology &amp; Geometry by Dr Tadashi Tokieda</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%B0%84%E5%BD%B1%E5%B9%B3%E9%9D%A2" target="_blank" rel="noopener">射影平面 维基百科</a>  <a href="https://baike.baidu.com/item/%E5%B0%84%E5%BD%B1%E5%B9%B3%E9%9D%A2/4559683?fr=aladdin#reference-[2]-1751996-wrap" target="_blank" rel="noopener">射影平面 百度百科</a>  <a href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E5%B0%84%E5%BD%B1%E5%B9%B3%E9%9D%A2" target="_blank" rel="noopener">real projective plane 实射影平面 wiki</a></p>
<p><a href="https://www.cnblogs.com/XiongRuiMath/p/10241912.html" target="_blank" rel="noopener">映射的度</a></p>
<p><a href="http://pi.math.cornell.edu/~mec/Winter2009/Victor/part3.htm" target="_blank" rel="noopener">Orientable and Nonorientable Surfaces</a></p>
<p><a href="https://www.math3ma.com/blog/the-fundamental-group-of-the-real-projective-plane" target="_blank" rel="noopener">The Fundamental Group of the Real Projective Plane</a></p>
<p><a href="https://www.youtube.com/watch?v=u0VkikpElMo&amp;feature=emb_rel_pause" target="_blank" rel="noopener">Real projective plane and Moebius strip</a></p>
<p><a href="https://www.youtube.com/user/numberphile/search?query=Topology" target="_blank" rel="noopener">Numberphile youtube</a></p>
<p><a href="https://www.youtube.com/watch?v=H8qwqGjOlSE" target="_blank" rel="noopener">Topology Riddles | Infinite Series</a></p>
<p><a href="https://www.youtube.com/watch?v=i0KfrQ3dg9k" target="_blank" rel="noopener">Real Projective Plane-Connected sum</a></p>
<p><a href="https://www.youtube.com/watch?v=yaeyNjUPVqs" target="_blank" rel="noopener">The Klein bottle</a></p>
<p><a href="http://www.map.mpim-bonn.mpg.de/Projective_plane:_a_history" target="_blank" rel="noopener">Projective plane: a history</a></p>
<p><a href="https://www.youtube.com/watch?v=lDqmaPEjJpk" target="_blank" rel="noopener">The Real Projective Plane youtube anime</a></p>
<p><a href="https://www.youtube.com/watch?v=x2SZSfYYSc8" target="_blank" rel="noopener">The Möbius band and the projective plane youtube anime</a></p>
]]></content>
      <categories>
        <category>共形几何</category>
      </categories>
      <tags>
        <tag>共形几何</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算共形几何2-基础群和覆盖空间</title>
    <url>/2020/07/14/%E8%AE%A1%E7%AE%97%E5%85%B1%E5%BD%A2%E5%87%A0%E4%BD%952-%E5%9F%BA%E7%A1%80%E7%BE%A4%E5%92%8C%E8%A6%86%E7%9B%96%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h2 id="如何定义一个曲面"><a href="#如何定义一个曲面" class="headerlink" title="如何定义一个曲面"></a>如何定义一个曲面</h2><p><img src="/images/image-20200714210523323.png" alt="image-20200714210523323"></p>
<p><img src="/images/image-20200714210938379.png" alt="image-20200714210938379"></p>
<p><img src="/images/image-20200714211405075.png" alt="image-20200714211405075"></p>
<p>Handle loops 在外部缩成一个点，t unnel在内部缩成一个点。</p>
<a id="more"></a>
<h2 id="环柄在医学上的应用"><a href="#环柄在医学上的应用" class="headerlink" title="环柄在医学上的应用"></a>环柄在医学上的应用</h2><p><img src="/images/image-20200714211504183.png" alt="image-20200714211504183"></p>
<p>拓扑去噪，用环柄找出大肠微小的环柄，一些医疗设备，西门子会使用这些技术。</p>
<h2 id="代数拓扑与群"><a href="#代数拓扑与群" class="headerlink" title="代数拓扑与群"></a>代数拓扑与群</h2><p><img src="/images/image-20200714212222933.png" alt="image-20200714212222933"></p>
<h3 id="1-基本群的定义"><a href="#1-基本群的定义" class="headerlink" title="1.基本群的定义"></a>1.基本群的定义</h3><p><img src="/images/image-20200714212249910.png" alt="image-20200714212249910"></p>
<p><img src="/images/image-20200714212315299.png" alt="image-20200714212315299"></p>
<p>所有过基点的环路集合</p>
<p><img src="/images/image-20200718194326144.png" alt="image-20200718194326144"></p>
<p>这样？环路的同伦类好像还是在这个集合里？</p>
<h3 id="2-何为同伦"><a href="#2-何为同伦" class="headerlink" title="2.何为同伦"></a>2.何为同伦</h3><p><img src="/images/image-20200714212414979.png" alt="image-20200714212414979"></p>
<p><img src="/images/image-20200714213359524.png" alt="image-20200714213359524"></p>
<p>同伦是一种等价关系</p>
<p><img src="/images/image-20200714213535320.png" alt="image-20200714213535320"></p>
<h3 id="3-乘积和逆"><a href="#3-乘积和逆" class="headerlink" title="3.乘积和逆"></a>3.乘积和逆</h3><p>环路的乘积</p>
<p><img src="/images/image-20200718193420922.png" alt="image-20200718193420922"></p>
<p><img src="/images/image-20200718193557384.png" alt="image-20200718193557384"></p>
<p>环路的逆</p>
<p><img src="/images/image-20200718193246350.png" alt="image-20200718193246350"></p>
<h2 id="基本群的表示"><a href="#基本群的表示" class="headerlink" title="基本群的表示"></a>基本群的表示</h2><p><img src="/images/image-20200718194829237.png" alt="image-20200718194829237"></p>
<p>使用字母来表示环路</p>
<p>词群的插入和删除操作</p>
<p><img src="/images/image-20200718194833977.png" alt="image-20200718194833977"></p>
<p><img src="/images/image-20200718194846669.png" alt="image-20200718194846669"></p>
<p>曲面交叉索引的值，交点曲线切向量叉积和法线同个方向值为1，垂直值为0，相反为-1，这样为每个焦点定义了一个指标。</p>
<p><img src="/images/image-20200718195229858.png" alt="image-20200718195229858"></p>
<p>代数相交数</p>
<p><img src="/images/image-20200718195445085.png" alt="image-20200718195445085"></p>
<p><img src="/images/image-20200718195518586.png" alt="image-20200718195518586"></p>
<p>代数相交数在同伦变换下不变</p>
<h3 id="基本群的典范表示"><a href="#基本群的典范表示" class="headerlink" title="基本群的典范表示"></a>基本群的典范表示</h3><p><img src="/images/image-20200718200815406.png" alt="image-20200718200815406"></p>
<p><img src="/images/image-20200718200857467.png" alt="image-20200718200857467"></p>
<p>a1,b2,a2,b2 叫做曲面基本群的典范基底。</p>
<h2 id="拓扑同胚和基本群-Homeomorphism"><a href="#拓扑同胚和基本群-Homeomorphism" class="headerlink" title="拓扑同胚和基本群(Homeomorphism)"></a>拓扑同胚和基本群(Homeomorphism)</h2><p><img src="/images/image-20200718201425645.png" alt="image-20200718201425645"></p>
<p>两个曲面的基本群同构，则其拓扑等价，即拓扑同胚。</p>
<p><img src="/images/image-20200726172230602.png" alt="image-20200726172230602"></p>
<p><img src="/images/image-20200726172350878.png" alt="image-20200726172350878"></p>
<p><strong>莫比乌斯环是不可定向的曲面</strong></p>
<p><img src="/images/image-20200726174221347.png" alt="image-20200726174221347"></p>
<p><strong>球和圆环是可定向的曲面</strong></p>
<p><img src="/images/image-20200726174421903.png" alt="image-20200726174421903"></p>
<p><strong>曲面不可定向则包含莫比乌斯环，包含莫比乌斯环的曲面必然不可定向</strong></p>
<p><img src="/images/image-20200726175027394.png" alt="image-20200726175027394"></p>
<p>没有边界并且不可定向的曲面</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/e8lVhJjiwk0" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<p><a href="https://baike.baidu.com/item/%E5%9F%BA%E6%9C%AC%E7%BE%A4/4587933?fr=aladdin" target="_blank" rel="noopener">百科 基本群</a></p>
<p>基本群的概念和正交基之类的相同(应该)，即使用最少的元素表示一个空间或者曲面。</p>
<p><img src="/images/46988976e9e705a5fd4875086254aa5f_r.jpg" alt="img"></p>
<p><img src="/images/image-20200720193931191.png" alt="image-20200720193931191"></p>
<p><img src="/images/image-20200720193911278.png" alt="image-20200720193911278"></p>
<p><img src="/images/image-20200720193231451.png" alt="image-20200720193231451"></p>
<h3 id="拓扑空间分解"><a href="#拓扑空间分解" class="headerlink" title="拓扑空间分解"></a>拓扑空间分解</h3><p><img src="/images/image-20200718202002876.png" alt="image-20200718202002876"></p>
<h3 id="曲面的连通和"><a href="#曲面的连通和" class="headerlink" title="曲面的连通和"></a>曲面的连通和</h3><p><img src="/images/image-20200718202132192.png" alt="image-20200718202132192"></p>
<h3 id="表面拓扑分类"><a href="#表面拓扑分类" class="headerlink" title="表面拓扑分类"></a>表面拓扑分类</h3><p><img src="/images/image-20200718202328467.png" alt="image-20200718202328467"></p>
<p><img src="/images/image-20200718202305292.png" alt="image-20200718202305292"></p>
<iframe width="560" height="560" src="https://www.youtube.com/embed/0XebqXmWM0A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<h3 id="环面的基本群"><a href="#环面的基本群" class="headerlink" title="环面的基本群"></a>环面的基本群</h3><p><img src="/images/image-20200718202535408.png" alt="image-20200718202535408"></p>
<h3 id="刺破环面基本群的表示-亏格为2的曲面的基本群表示"><a href="#刺破环面基本群的表示-亏格为2的曲面的基本群表示" class="headerlink" title="刺破环面基本群的表示(亏格为2的曲面的基本群表示)"></a>刺破环面基本群的表示(亏格为2的曲面的基本群表示)</h3><p><img src="/images/image-20200719223916410.png" alt="image-20200719223916410"></p>
<p>其证明</p>
<p><img src="/images/image-20200719224247221.png" alt="image-20200719224247221"></p>
<p><img src="/images/image-20200719224501664.png" alt="image-20200719224501664"></p>
<h2 id="切图-Cut-Graph"><a href="#切图-Cut-Graph" class="headerlink" title="切图(Cut Graph)"></a>切图(Cut Graph)</h2><p><img src="/images/image-20200719224547657.png" alt="image-20200719224547657"></p>
<h3 id="计算切图的算法"><a href="#计算切图的算法" class="headerlink" title="计算切图的算法"></a>计算切图的算法</h3><p><img src="/images/image-20200719225058276.png" alt="image-20200719225058276"></p>
<h3 id="亏格为3的切图"><a href="#亏格为3的切图" class="headerlink" title="亏格为3的切图"></a>亏格为3的切图</h3><p><img src="/images/image-20200719225214579.png" alt="image-20200719225214579"></p>
<p><img src="/images/image-20200719225358435.png" alt="image-20200719225358435"></p>
<h3 id="基本群的关系算法"><a href="#基本群的关系算法" class="headerlink" title="基本群的关系算法"></a>基本群的关系算法</h3><h2 id="万有覆盖空间"><a href="#万有覆盖空间" class="headerlink" title="万有覆盖空间(?)"></a>万有覆盖空间(?)</h2><p><img src="/images/image-20200719225413914.png" alt="image-20200719225413914"></p>
<p><img src="/images/image-20200719225727530.png" alt="image-20200719225727530"></p>
<p><img src="/images/image-20200719225910465.png" alt="image-20200719225910465"></p>
<h3 id="覆盖群的结构"><a href="#覆盖群的结构" class="headerlink" title="覆盖群的结构"></a>覆盖群的结构</h3><p><img src="/images/image-20200719230118222.png" alt="image-20200719230118222"></p>
<h3 id="亏格为2的曲面的万有覆盖空间"><a href="#亏格为2的曲面的万有覆盖空间" class="headerlink" title="亏格为2的曲面的万有覆盖空间"></a>亏格为2的曲面的万有覆盖空间</h3><p><img src="/images/image-20200719230400428.png" alt="image-20200719230400428"></p>
<p><img src="/images/image-20200719230819194.png" alt="image-20200719230819194"></p>
<h3 id="万有覆盖空间的算法表示"><a href="#万有覆盖空间的算法表示" class="headerlink" title="万有覆盖空间的算法表示"></a>万有覆盖空间的算法表示</h3><p><img src="/images/image-20200719230915657.png" alt="image-20200719230915657"></p>
<h1 id="基本拓扑学笔记"><a href="#基本拓扑学笔记" class="headerlink" title="基本拓扑学笔记"></a>基本拓扑学笔记</h1><p><a href="https://www.bilibili.com/video/BV1P7411N7fW?p=1" target="_blank" rel="noopener">基础拓扑学</a></p>
<h2 id="第一节-欧拉定理"><a href="#第一节-欧拉定理" class="headerlink" title="第一节:欧拉定理"></a>第一节:欧拉定理</h2><h3 id="1-欧拉定理"><a href="#1-欧拉定理" class="headerlink" title="1.欧拉定理"></a>1.欧拉定理</h3><p><img src="/images/image-20200720114046331.png" alt="image-20200720114046331"></p>
<p>凸多面体的任何截面都是凸多边形，与凹多面体相反。</p>
<p>把凸多面体的任何一个面伸展成平面，它的所有其他各面都在这个平面的同侧。</p>
<p><img src="/images/image-20200720113919180.png" alt="image-20200720113919180"></p>
<p><img src="/images/image-20200720114333012.png" alt="image-20200720114333012"></p>
<p>最后一个计算没有意义因为顶面的形状不算是多边形。</p>
<h4 id="v-e-f-0的例子"><a href="#v-e-f-0的例子" class="headerlink" title="v-e+f=0的例子"></a>v-e+f=0的例子</h4><p><img src="/images/image-20200720114553753.png" alt="image-20200720114553753"></p>
<h4 id="几个多面体其本质的不同"><a href="#几个多面体其本质的不同" class="headerlink" title="几个多面体其本质的不同"></a>几个多面体其本质的不同</h4><p><img src="/images/image-20200720114903381.png" alt="image-20200720114903381"></p>
<p><img src="/images/image-20200720115259324.png" alt="image-20200720115259324"></p>
<p>具体的几何形状无关，而更深层的几何结构有关</p>
<h2 id="第二节-拓扑引论"><a href="#第二节-拓扑引论" class="headerlink" title="第二节:拓扑引论"></a>第二节:拓扑引论</h2><h3 id="同胚"><a href="#同胚" class="headerlink" title="同胚"></a>同胚</h3><p>双射</p>
<p><img src="/images/image-20200720120129552.png" alt="image-20200720120129552"></p>
<p><img src="/images/image-20200720115810758.png" alt="image-20200720115810758"></p>
<p><img src="/images/image-20200720115843213.png" alt="image-20200720115843213"></p>
<h3 id="不同胚的例子"><a href="#不同胚的例子" class="headerlink" title="不同胚的例子"></a>不同胚的例子</h3><p><img src="/images/image-20200720120233345.png" alt="image-20200720120233345"></p>
<h3 id="拓扑不变量"><a href="#拓扑不变量" class="headerlink" title="拓扑不变量"></a>拓扑不变量</h3><p><img src="/images/image-20200720120512184.png" alt="image-20200720120512184"></p>
<h3 id="什么是连续"><a href="#什么是连续" class="headerlink" title="什么是连续"></a>什么是连续</h3><p>微积分中的连续定义</p>
<p><img src="/images/image-20200720120746045.png" alt="image-20200720120746045"></p>
<h3 id="开集与逆"><a href="#开集与逆" class="headerlink" title="开集与逆"></a><a href="https://baike.baidu.com/item/%E5%BC%80%E9%9B%86/10505701?fr=aladdin#3" target="_blank" rel="noopener">开集与逆</a></h3><p><img src="/images/image-20200720121038667.png" alt="image-20200720121038667"></p>
<p><img src="/images/image-20200720121240817.png" alt="image-20200720121240817"></p>
<p><img src="/images/image-20200720121730101.png" alt="image-20200720121730101"></p>
<p><img src="/images/image-20200720121839706.png" alt="image-20200720121839706"></p>
<h2 id="第三节-拓扑空间"><a href="#第三节-拓扑空间" class="headerlink" title="第三节:拓扑空间"></a>第三节:拓扑空间</h2><p><img src="/images/image-20200720121532927.png" alt="image-20200720121532927"></p>
<p>有限个开集的交为开集</p>
<p><img src="/images/image-20200720164224525.png" alt="image-20200720164224525"></p>
<p>这样？</p>
<h3 id="平凡拓扑-只有空集和全集"><a href="#平凡拓扑-只有空集和全集" class="headerlink" title="平凡拓扑 只有空集和全集"></a>平凡拓扑 只有空集和全集</h3><h3 id="离散拓扑"><a href="#离散拓扑" class="headerlink" title="离散拓扑"></a>离散拓扑</h3><p><img src="/images/image-20200720164405109.png" alt="image-20200720164405109"></p>
<h3 id="度量空间"><a href="#度量空间" class="headerlink" title="度量空间"></a><a href="https://zhuanlan.zhihu.com/p/54041981" target="_blank" rel="noopener">度量空间</a></h3><p><img src="/images/image-20200720171150699.png" alt="image-20200720171150699"></p>
<p><strong>度量空间（metric space）是一种具有度量函数（metric function）或者叫做距离函数（distance function）的集合，此函数定义集合内所有元素间的距离，被称为集合上的metric。</strong></p>
<p><strong>度量空间中最符合直观理解的是三维欧氏空间，事实上，metric的概念是欧氏距离性质的推广。</strong></p>
<p>度量空间是1906年Maurice Fréchet在其著作中引入的，但是名字来自于Felix Hausdorff。</p>
<p>度量空间在分析学中有重要应用。</p>
<h4 id="实数序列的极限与metric-function"><a href="#实数序列的极限与metric-function" class="headerlink" title="实数序列的极限与metric function"></a><strong>实数序列的极限与metric function</strong></h4><p><img src="/images/image-20200720170944837.png" alt="image-20200720170944837"></p>
<p><img src="/images/image-20200720171012957.png" alt="image-20200720171012957"></p>
<p><img src="/images/image-20200720171039452.png" alt="image-20200720171039452"></p>
<p>除了极限的概念，通过度量空间还可以定义连续、一致连续、Lipschitz连续、一致收敛等性质，度量空间本身还可以具有很多性质，如完备性、紧致性、连通性、分离性等。此外度量空间还能导出开集与闭集等拓扑性质，<strong>这导致了对再度抽象的拓扑空间的研究。</strong></p>
<p><strong>数学是一个不断抽象的过程，度量空间以及更加抽象的拓扑空间的引入，并不是为了抽象而抽象，而是为了研究的方便，使概念准确和简洁。</strong></p>
<h3 id="度量空间诱导的拓扑"><a href="#度量空间诱导的拓扑" class="headerlink" title="度量空间诱导的拓扑"></a>度量空间诱导的拓扑</h3><p><img src="/images/image-20200720164800688.png" alt="image-20200720164800688"></p>
<h3 id="子空间拓扑"><a href="#子空间拓扑" class="headerlink" title="子空间拓扑"></a>子空间拓扑</h3><p><img src="/images/image-20200720191124569.png" alt="image-20200720191124569"></p>
<p><img src="/images/image-20200720191202821.png" alt="image-20200720191202821"></p>
]]></content>
      <categories>
        <category>共形几何</category>
      </categories>
      <tags>
        <tag>共形几何</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>计算共形几何笔记-1</title>
    <url>/2020/07/10/%E8%AE%A1%E7%AE%97%E5%85%B1%E5%BD%A2%E5%87%A0%E4%BD%95%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<h2 id="如何制作一张地图？"><a href="#如何制作一张地图？" class="headerlink" title="如何制作一张地图？"></a>如何制作一张地图？</h2><p><img src="/images/image-20200712210233986.png" alt="image-20200712210233986"></p>
<p>怎么样做一个地球的平面图？很难，就像把橘子皮摊平一样，如果没有扭曲和切割几乎不可能。</p>
<p><img src="/images/image-20200712211535319.png" alt="image-20200712211535319"></p>
<p>既然不能尺寸和角度不能都保留，那么共形几何选择在绘制地图的时候保持角度，在航海地图的时候很有用。</p>
<p><img src="/images/image-20200712211437488.png" alt="image-20200712211437488"></p>
<p>保留角度会使得地图上一些区域的面积严重扭曲，例如在地图上看，格陵兰岛面积比澳大利亚大，但是实际上澳大利亚面积768万平方千米，是世界上最小的大陆；格陵兰岛面积216万平方千米，是世界上最大的岛屿。澳大利亚的实际面积相当于格陵兰岛的三倍多。</p>
<p>经过将球体地图投影到平面上，角度得到了保留，但是局部的尺寸和比例发生了严重的变化。</p>
<p><img src="/images/image-20200712212559590.png" alt="image-20200712212559590"></p>
<p>一般来讲，共型几何研究的是<strong>保持角度</strong>。</p>
<p><img src="/images/image-20200712212804648.png" alt="image-20200712212804648"></p>
<p><img src="/images/image-20200712213036382.png" alt="image-20200712213036382"></p>
<h2 id="为何保持角度？"><a href="#为何保持角度？" class="headerlink" title="为何保持角度？"></a>为何保持角度？</h2><p>那为什么要保持角度不变，即共形？</p>
<p><img src="/images/image-20200712213324338.png" alt="image-20200712213324338"></p>
<p>计算效率和几何处理效率更高。</p>
<p><img src="/images/image-20200712213440834.png" alt="image-20200712213440834"></p>
<p><strong>尺寸变化非常平滑。</strong></p>
<p><img src="/images/image-20200712213631266.png" alt="image-20200712213631266"></p>
<p>假设在地球上旅行，可以不用思考角度问题，而只考虑尺寸，这样简化了问题。</p>
<p><img src="/images/image-20200712214517442.png" alt="image-20200712214517442"></p>
<p>那为什么不保留面积？保留面积产生的图形极为复杂难懂，也不平滑。</p>
<p><img src="/images/image-20200712214830145.png" alt="image-20200712214830145"></p>
<p>共形几何可以解决很多问题。</p>
<p><img src="/images/image-20200712215050784.png" alt="image-20200712215050784"></p>
<p><img src="/images/image-20200712215408556.png" alt="image-20200712215408556"></p>
<p><img src="/images/image-20200712215853886.png" alt="image-20200712215853886"></p>
<p>一旦把第一个三角形保留了角度，其他的都不能变了。结果已经固定，这时候需要一些别的思考方式。</p>
<p><img src="/images/image-20200712215948948.png" alt="image-20200712215948948"></p>
<p><img src="/images/image-20200712220048484.png" alt="image-20200712220048484"></p>
<p><img src="/images/image-20200712220200126.png" alt="image-20200712220200126"></p>
<p><img src="/images/image-20200712220431816.png" alt="image-20200712220431816"></p>
<h2 id="曲面的保角映射"><a href="#曲面的保角映射" class="headerlink" title="曲面的保角映射"></a>曲面的保角映射</h2><p><img src="/images/image-20200712220613894.png" alt="image-20200712220613894"></p>
<p><img src="/images/image-20200713145958920.png" alt="image-20200713145958920"></p>
<p>把雕像展为2维平面和制作一幅地图的过程是一样的。</p>
<p><img src="/images/image-20200713150457565.png" alt="image-20200713150457565"></p>
<p><img src="/images/image-20200713151959839.png" alt="image-20200713151959839"></p>
<p>如果在平面上绘制小圆，则经过变换之后的3维空间中的圆形则会保持角度，但大小会发生扭曲，变成椭圆。</p>
<h3 id="共形映射补充-2020-11-8"><a href="#共形映射补充-2020-11-8" class="headerlink" title="共形映射补充(2020-11-8)"></a>共形映射补充(2020-11-8)</h3><p>来源:<a href="https://www.youtube.com/watch?v=WXtuoV9yON8&amp;ab_channel=%E4%B8%AD%E5%9B%BD%E5%A4%A7%E5%AD%A6MOOC-%E6%85%95%E8%AF%BE" target="_blank" rel="noopener">复变函数与积分变换</a> 华中科技大学 MOOC 尹慧 第六章共形映射</p>
<p><img src="/images/gongxing/image-20201108093131990.png" alt="image-20201108093131990"></p>
<h3 id="伸缩率的概念"><a href="#伸缩率的概念" class="headerlink" title="伸缩率的概念"></a>伸缩率的概念</h3><p><img src="/images/gongxing/image-20201108093449089.png" alt="image-20201108093449089"></p>
<h3 id="旋转角的概念"><a href="#旋转角的概念" class="headerlink" title="旋转角的概念"></a>旋转角的概念</h3><p><img src="/images/image-20201108093600305.png" alt="image-20201108093600305"></p>
<h3 id="导数的几何意义"><a href="#导数的几何意义" class="headerlink" title="导数的几何意义"></a>导数的几何意义</h3><p><img src="/images/gongxing/image-20201108101157545.png" alt="image-20201108101157545"></p>
<p>我TM直接爆炸草？</p>
<h2 id="单值化定理"><a href="#单值化定理" class="headerlink" title="单值化定理"></a>单值化定理</h2><p><strong>所有带度量的封闭曲面都可以共形映射到三种标准空间中的一种，球面，欧式平面或者双曲球面。</strong></p>
<p><img src="/images/image-20200713152246136.png" alt="image-20200713152246136"></p>
<p><img src="/images/image-20200713152813767.png" alt="image-20200713152813767"></p>
<p>0亏格的封闭曲面保角变换到球面上。</p>
<p><img src="/images/image-20200713153052228.png" alt="image-20200713153052228"></p>
<p>亏格为一的曲面映射到欧式平面上。</p>
<p><img src="/images/image-20200713153139750.png" alt="image-20200713153139750"></p>
<p>亏格为2的曲面覆盖整个双曲曲面。</p>
<p><img src="/images/image-20200713153409827.png" alt="image-20200713153409827"></p>
<p>带有边界的曲面。</p>
<p><img src="/images/image-20200713154138607.png" alt="image-20200713154138607"></p>
<h3 id="1-调和映射（适用于亏格为0的曲面"><a href="#1-调和映射（适用于亏格为0的曲面" class="headerlink" title="1.调和映射（适用于亏格为0的曲面"></a>1.调和映射（适用于亏格为0的曲面</h3><p><img src="/images/image-20200713154226992.png" alt="image-20200713154226992"></p>
<h3 id="2-全纯微分（适用于亏格为1的曲面"><a href="#2-全纯微分（适用于亏格为1的曲面" class="headerlink" title="2.全纯微分（适用于亏格为1的曲面"></a>2.全纯微分（适用于亏格为1的曲面</h3><p><img src="/images/image-20200713154351569.png" alt="image-20200713154351569"></p>
<p>找到散度和梯度为0的像静电场形式的，其映射具有唯一性。</p>
<h3 id="3-Ricci-流（适用于高亏格曲面）"><a href="#3-Ricci-流（适用于高亏格曲面）" class="headerlink" title="3.Ricci 流（适用于高亏格曲面）"></a>3.Ricci 流（适用于高亏格曲面）</h3><p><img src="/images/image-20200713154600878.png" alt="image-20200713154600878"></p>
<h2 id="表面纹理映射参数化"><a href="#表面纹理映射参数化" class="headerlink" title="表面纹理映射参数化"></a>表面纹理映射参数化</h2><p><img src="/images/image-20200713154816139.png" alt="image-20200713154816139"></p>
<p>传统纹理工艺浪费大量的内存</p>
<p><img src="/images/image-20200713154926621.png" alt="image-20200713154926621"></p>
<p><img src="/images/image-20200713154957758.png" alt="image-20200713154957758"></p>
<p>法向映射</p>
<p><img src="/images/image-20200713155034422.png" alt="image-20200713155034422"></p>
<p>保持角度和保持面积的到不同的映射</p>
<p><img src="/images/image-20200713155051332.png" alt="image-20200713155051332"></p>
<h2 id="几何图像"><a href="#几何图像" class="headerlink" title="几何图像"></a>几何图像</h2><p>使用2维图像保存3维模型数据。</p>
<p><img src="/images/image-20200713155305899.png" alt="image-20200713155305899"></p>
<p><img src="/images/image-20200713155316499.png" alt="image-20200713155316499"></p>
<p><img src="/images/image-20200713155325662.png" alt="image-20200713155325662"></p>
<h2 id="如何处理大量的三维数据"><a href="#如何处理大量的三维数据" class="headerlink" title="如何处理大量的三维数据"></a>如何处理大量的三维数据</h2><p>使用三维技术，人们可以非常容易地得到三维的数据结构。</p>
<p>例如使用结构光的方法进行扫描，扫描速度非常快，解析度也高。</p>
<p><img src="/images/image-20200713145121704.png" alt="image-20200713145121704"></p>
<p>动态的表情变化每一帧有差不多50万个采样点。这样可以得到非常迅速的、大规模的三维数据的采集。</p>
<p><img src="/images/image-20200713145230676.png" alt="image-20200713145230676"></p>
<p><img src="/images/image-20200712201526208.png" alt="image-20200712201526208"></p>
<p><img src="/images/image-20200712201601680.png" alt="image-20200712201601680"></p>
<p><img src="/images/image-20200712201616702.png" alt="image-20200712201616702"></p>
<p>我们瞬间可以得到大量的三维数据，但是如何来处理这些非常难以处理的三维的数据？</p>
<p>平直空间的问题可以使用线性代数，而对于曲面的话无能为力，因此必须要引入现代的<strong>微分几何和共形几何</strong>。</p>
<p><img src="/images/image-20200712221448627.png" alt="image-20200712221448627"></p>
<p>角度不变，尺寸发生改变。</p>
<h1 id="共形几何应用"><a href="#共形几何应用" class="headerlink" title="共形几何应用"></a>共形几何应用</h1><h2 id="人脸曲面配准"><a href="#人脸曲面配准" class="headerlink" title="人脸曲面配准"></a>人脸曲面配准</h2><p>给定两张三维人脸，如何在他们之间，建立比较好的一一映射？我们的方法就是把三维人脸，用黎曼映照，映到二维的圆盘上。这样通过降维攻击，就把这三维问题变成了二维问题。二维问题，会简化非常多。</p>
<p><img src="/images/image-20200712221552677.png" alt="image-20200712221552677"></p>
<p>把这个男孩的这张脸映到女孩这张脸。第一步，用一些机器学习的方法，找到人脸上的特征点，比如眼角、鼻窝还有鼻尖，然后使特征点对齐。第二步，使得整个的畸变达到最小。使畸变最小这个映射，被称为<strong>泰希米勒映射</strong>。（?</p>
<p><img src="/images/image-20200712221734728.png" alt="image-20200712221734728"></p>
<p>畸变由什么决定呢？是由<strong>两族Foliation（叶状结构）</strong>决定，调和叶状结构决定。（<strong>？</strong></p>
<p>为什么要得到非常精细的映射呢？主要是<strong>为了做精准医疗。</strong>欧美的白人他们祖先生活在寒带，所以他的基因中缺乏抵御紫外线的功能。所以对于白人来讲，非常容易得皮肤癌，也就是所谓的黑色素瘤。黑色素瘤非常小，肉眼几乎不可见，低于毫米。如果用人工去筛查这个黑色素瘤就会非常痛苦。我们就发明这种方法，同一个人每隔一年扫描一次，然后精细地筛查在皮肤上逐点比较看哪一点皮肤发生突变。这样可以非常自动地找到这个黑色素瘤。所以计算机视觉在医学上也有很深的应用。</p>
<h3 id="三维映射"><a href="#三维映射" class="headerlink" title="三维映射"></a>三维映射</h3><p><img src="/images/image-20200713155607729.png" alt="image-20200713155607729"></p>
<h2 id="动画与电影"><a href="#动画与电影" class="headerlink" title="动画与电影"></a>动画与电影</h2><h3 id="动作捕捉和表情捕捉"><a href="#动作捕捉和表情捕捉" class="headerlink" title="动作捕捉和表情捕捉"></a>动作捕捉和表情捕捉</h3><p>动漫领域，这些方法也有很好的应用。在动漫电影中，动作捕捉和表情捕捉是非常关键的技术。比如武打片的动作捕捉，就是要得到各个关节的信息。但是动作捕捉非常容易，因为人的关节只有几十个，表情捕捉却非常难，表情的自由度有无穷多个。所以现在整个动漫产业，最困难的就是<strong>表情捕捉</strong>。那么怎么进行表情捕捉呢？</p>
<p>把动态的三维人脸，通过<strong>黎曼映照</strong>映到二维的圆盘上，然后用刚才的方法可以建立帧与帧之间的一一映射。</p>
<p><img src="/images/image-20200712224413061.png" alt="image-20200712224413061"></p>
<p><code>哦。也就是说在工程上这些数据的数据量压缩到最小同时保留了角度信息，可以还原。</code></p>
<p><img src="/images/image-20200713155748624.png" alt="image-20200713155748624"></p>
<h3 id="表情移植到卡通人物上"><a href="#表情移植到卡通人物上" class="headerlink" title="表情移植到卡通人物上"></a>表情移植到卡通人物上</h3><p>把一张蓝色的四边形网格贴到第一张脸上，依随这个人脸的变化而变化。这个蓝色网格上每一个点会得到三维空间中的一条轨迹，这个轨迹就代表了这个表情的信息。我们可以把这表情信息拿出来，去移植到其他的卡通人物身上。</p>
<p><img src="/images/image-20200712224823740.png" alt="image-20200712224823740"></p>
<h3 id="虚拟演员"><a href="#虚拟演员" class="headerlink" title="虚拟演员"></a>虚拟演员</h3><p>把三维的人脸表情拿下来，然后进行表情捕捉。建立一个<strong>虚拟演员</strong>。</p>
<p><img src="/images/image-20200712224920050.png" alt="image-20200712224920050"></p>
<p>现在明星拍摄非常非常昂贵。那么我们是不是可以把他的所有的表情以三维的方式记录下来，然后导演来决定，到哪一个情节、哪一个台词，用什么表情，从数据库中给它取出来。如果这样，我们不需要这个演员真正来出演，只需要得到他的数字版权就可以。</p>
<p>在这边找了一个演员，把他的一些标准表情给数字化，然后做了下面一个非常小的一个电影片段。这边的整个场景是假的，是用Maya（三维动画）做的。人也是假的，表情也是假的。所以我们相信虚拟演员这个技术，未来可以在VR、AR中很大地普及。</p>
<p><img src="/images/image-20200712225014760.png" alt="image-20200712225014760"></p>
<h2 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h2><p>在VR,AR中，<strong>数据压缩</strong>是一个非常关键的问题。比如我们为了表达一张老人的脸，饱经沧桑、满布皱纹，需要大量的几何信息。如果要通过无线网络来传递这个信息，或者是本身硬件性能比较差，渲染速度就非常慢。如何来压缩这个复杂的几何信息是一个非常关键的问题。我们把一个老人头映到平面的圆盘，然后再控制每个区域在平面上的大小。比如说它曲率比较高的地方，皱纹比较高的地方，让它在平面的区域变得比较大。</p>
<p><img src="/images/image-20200712225134880.png" alt="image-20200712225134880"></p>
<p>比如这幅图，我们在平面上采样，采样之后在平面上重新进行三角剖分得到这个简化的模型。这边如果我们只用2000个这个采样点，得到的是左侧这张人脸。如果用4000的话得到右侧这张人脸。所以增加采样率，可以使得图像几何的特征越来越细腻。这样就可以求得一个渲染的质量和这个所谓的空间的存储一个很好的一个平衡。这是在VR、AR中几何压缩的一个应用。</p>
<p><img src="/images/image-20200712225249285.png" alt="image-20200712225249285"></p>
<h2 id="医学图像领域"><a href="#医学图像领域" class="headerlink" title="医学图像领域"></a>医学图像领域</h2><h3 id="脑图"><a href="#脑图" class="headerlink" title="脑图"></a>脑图</h3><p>在医学图像领域，共形几何用得也非常广泛，比如说<strong>共形脑图</strong>。人的大脑，形状非常地复杂，有很多沟回，这些沟回，随着岁月的增长是会发生变化的。比较两个大脑本身来讲非常困难。通过刚才大一统定理，我们知道存在一个共形变换。把大脑映到单位球面上，并且这个映射，基本是唯一的。得到这个映射之后，我们为大脑的每一点，确定唯一的经纬坐标。这样可以在大脑上精确地定位，进行比较。</p>
<p><img src="/images/image-20200712225331229.png" alt="image-20200712225331229"></p>
<h3 id="老年痴呆"><a href="#老年痴呆" class="headerlink" title="老年痴呆"></a>老年痴呆</h3><p><strong>老年痴呆症</strong>是一个非常普遍的一个疾病。人的大脑根据功能有很多种分区。比如最中间的这个山谷，是胚胎期最先形成的一个皱褶，人的感情，基本存在这个皱褶两边。</p>
<p><img src="/images/image-20200712225437118.png" alt="image-20200712225437118"></p>
<p>下图中，不同颜色代表不同的功能区域。有的区域主管语言，有的区域主管着运动，有的区域主管感情，有的区域主管推理。老年痴呆，是对应的某些功能区域会发生萎缩。</p>
<p><img src="/images/image-20200712225454397.png" alt="image-20200712225454397"></p>
<p>如果我们通过共形脑图，来进行精确的比较，发现老人的语言中枢开始萎缩，可以让他学一门新的外语，这样就可以延缓他老年痴呆症状。如果他的感情中枢开始萎缩，让他多参加社交，如果他的运动中枢开始萎缩，让他去跳广场舞，这样可以加强对这个区域刺激。</p>
<h3 id="癌症检测与虚拟肠镜"><a href="#癌症检测与虚拟肠镜" class="headerlink" title="癌症检测与虚拟肠镜"></a>癌症检测与虚拟肠镜</h3><p>​    在医学图像中的，另外的应用，是关于<strong>癌症检测</strong>。直肠癌，是男子的第四号杀手，普通男子过了中年之后，肠子里面会长出一些息肉。如果息肉的位置长得不对，经常地摩擦溃疡，摩擦溃疡之后复合，复合之后又反复摩擦溃疡，它的DNA复制次数就会非常多，这样就非常容易出错，出错之后就会形成癌变。</p>
<p>​    从一个息肉变到癌变，一般需要5到8年，如果在这期间，进行了肠镜检查，就可以非常有效地预防和防止。但是传统的肠镜检查非常痛苦，病人需要全身被麻醉，同时肠镜检查的方式具有非常强的侵犯性。并且老年人的肠壁肌肉非常薄弱，很容易产生非常强烈的并发症。</p>
<p>​    还有一个很大的问题，直肠有很多皱褶，如果我们的息肉长在皱褶里面的话，传统的光学方法是看不到的，所以用传统的检测方式来进行检查会有大概30%的漏检率。</p>
<p><img src="/images/image-20200712225639796.png" alt="image-20200712225639796"></p>
<p>于是我们就发明了<strong>虚拟肠镜</strong>的方法，核心的想法就是–把肠子的皱褶打开摊平到整个平面上。如果以传统方式来检查，在活人身上是不可能实现的，但是用数字模型可以做到这一点。虚拟肠镜可以把所有肠壁的皱褶给摊开，把所有的息肉暴露出来，然后我们用CT来扫描人的直肠得到数字模型。于是，医生就可以戴上VR眼镜，来观察肠道的内壁。</p>
<p><img src="/images/image-20200712225719260.png" alt="image-20200712225719260"></p>
<p>用伪彩色表达肠道内壁，那核心的话我们是要寻找一些肿瘤，或者一些比较大的息肉，那么在这个肠道中探索这个和真实的光学肠镜这个体验是非常相近的。通过这种方法我们就能看到一些比较可疑的息肉。</p>
<p><img src="/images/image-20200712225742163.png" alt="image-20200712225742163"></p>
<p>虚拟肠镜有非常多好处。第一，病人不需要全身麻醉。第二，医生和病人没有肢体接触，第三，我们能暴露所有潜在的息肉，提高诊断的准确率。</p>
<p>这个技术现在北美和日本用得非常普遍，在中国大陆，所有的医院几乎都有这套算法但是很可惜没有被真正用起来。那么它后边基于的是什么？非常艰深的几何用于医疗挽救了非常多的生命。</p>
<h2 id="物联网路由器"><a href="#物联网路由器" class="headerlink" title="物联网路由器"></a>物联网路由器</h2><p><img src="/images/image-20200713160515566.png" alt="image-20200713160515566"></p>
<p>交付保证贪婪路由，</p>
<p><img src="/images/image-20200713160608677.png" alt="image-20200713160608677"></p>
<p>给传感器分配虚拟坐标</p>
<h2 id="整形图像分析"><a href="#整形图像分析" class="headerlink" title="整形图像分析"></a>整形图像分析</h2><p><img src="/images/image-20200713160952980.png" alt="image-20200713160952980"></p>
<p>比较微整容前后的差异</p>
<h2 id="工业界"><a href="#工业界" class="headerlink" title="工业界"></a>工业界</h2><p>样条曲面要求2阶可导</p>
<p><img src="/images/image-20200713161407284.png" alt="image-20200713161407284"></p>
<h2 id="四边形网格曲面"><a href="#四边形网格曲面" class="headerlink" title="四边形网格曲面"></a>四边形网格曲面</h2><p><img src="/images/image-20200713161504438.png" alt="image-20200713161504438"></p>
<p>模拟仿真需要计算高质量的四边形网格，如何生成高质量的网格。</p>
<p><img src="/images/image-20200713161638872.png" alt="image-20200713161638872"></p>
<p><img src="/images/image-20200713161709664.png" alt="image-20200713161709664"></p>
<p><img src="/images/image-20200713161724001.png" alt="image-20200713161724001"></p>
<p><img src="/images/image-20200713161838369.png" alt="image-20200713161838369"></p>
<p><img src="/images/image-20200713161904184.png" alt="image-20200713161904184"></p>
<p><img src="/images/image-20200713161926475.png" alt="image-20200713161926475"></p>
<p><img src="/images/image-20200713161942032.png" alt="image-20200713161942032"></p>
<p><img src="/images/image-20200713162004040.png" alt="image-20200713162004040"></p>
<h2 id="雕塑与力学结构"><a href="#雕塑与力学结构" class="headerlink" title="雕塑与力学结构"></a>雕塑与力学结构</h2><p><img src="/images/image-20200713162156799.png" alt="image-20200713162156799"></p>
<p><img src="/images/image-20200713162209896.png" alt="image-20200713162209896"></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference:"></a>Reference:</h1><p><a href="https://mp.weixin.qq.com/s?__biz=MzA5MzgwNzM4OQ==&amp;mid=2651900461&amp;idx=1&amp;sn=355073afdd1b4e164ccd810c4be2238a&amp;chksm=8bbc5c5fbccbd549fc9ed5fc3d99fec5c4016429ffc89154b1408c10bbe0bc1cdc9ce55ac308&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">几何为万物赋能——建筑、医疗、动漫、游戏…… | 凤凰卫视世纪大讲堂</a></p>
<p><a href="https://www.youtube.com/watch?v=g0nY5VM1PSU" target="_blank" rel="noopener">Conformal Geometry Processing</a></p>
<p><a href="https://en.wikipedia.org/wiki/Conformal_geometry" target="_blank" rel="noopener">Conformal geometry wiki</a> </p>
<p><a href="https://www.bilibili.com/video/BV1nT4y1E74A" target="_blank" rel="noopener">Lecture 0 - Introduction to Computational Conformal Geometry</a></p>
]]></content>
      <categories>
        <category>共形几何</category>
      </categories>
      <tags>
        <tag>共形几何</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>三维重建学习-1</title>
    <url>/2020/07/04/%E4%B8%89%E7%BB%B4%E9%87%8D%E5%BB%BA%E5%AD%A6%E4%B9%A0-1/</url>
    <content><![CDATA[<p>想养成个习惯，学什么东西，比如深度学习什么的类别，在知乎上搜搜有没有前人的学习路线，在google,baidu上搜索看有没有书，在Youtube上搜搜有没有教程和介绍，在Coursera和Mooc，bilibili上看看有没有相关的课，youtube用英文搜索，在github上看看有没有相关开源框架，在淘宝上搜搜有没有相关的课程和书之类的，大致就是这几个方面。</p>
<h1 id="1-图像处理基础概论"><a href="#1-图像处理基础概论" class="headerlink" title="1.图像处理基础概论"></a>1.图像处理基础概论</h1><p><img src="/images/image-20200705204141625.png" alt="image-20200705204141625"></p>
<p>计算机的图像识别能力比人眼范围多</p>
<p>人眼的识别能力受主观限制，但是人眼对图像的理解能力很强</p>
<p><img src="/images/image-20200705204507215.png" alt="image-20200705204507215"></p>
<h2 id="1-1图像处理的目的"><a href="#1-1图像处理的目的" class="headerlink" title="1.1图像处理的目的"></a>1.1图像处理的目的</h2><p><img src="/images/image-20200705204555327.png" alt="image-20200705204555327"></p>
<p><img src="/images/image-20200705204651436.png" alt="image-20200705204651436"></p>
<h2 id="1-2-图像处理简史"><a href="#1-2-图像处理简史" class="headerlink" title="1.2 图像处理简史"></a>1.2 图像处理简史</h2><p><img src="/images/image-20200705204924732.png" alt="image-20200705204924732"></p>
<p><img src="/images/image-20200705205036043.png" alt="image-20200705205036043"></p>
<h2 id="1-3-图像处理应用"><a href="#1-3-图像处理应用" class="headerlink" title="1.3 图像处理应用"></a>1.3 图像处理应用</h2><p><img src="/images/image-20200705205208297.png" alt="image-20200705205208297"></p>
<h2 id="1-4-图像处理内容"><a href="#1-4-图像处理内容" class="headerlink" title="1.4 图像处理内容"></a>1.4 图像处理内容</h2><p><img src="/images/image-20200705205447511.png" alt="image-20200705205447511"></p>
<p>图像增强：直观理解应该是马赛克模糊和美颜什么的</p>
<h2 id="1-5-图像处理构成"><a href="#1-5-图像处理构成" class="headerlink" title="1.5 图像处理构成"></a>1.5 图像处理构成</h2><p><img src="/images/image-20200705205835929.png" alt="image-20200705205835929"></p>
<h1 id="2-图像处理概念"><a href="#2-图像处理概念" class="headerlink" title="2.图像处理概念"></a>2.图像处理概念</h1><p>坐标和幅值，图像的概念</p>
<p><img src="/images/image-20200705205927169.png" alt="image-20200705205927169"></p>
<h2 id="数字图像"><a href="#数字图像" class="headerlink" title="数字图像"></a>数字图像</h2><p><img src="/images/image-20200705210158208.png" alt="image-20200705205959426"></p>
<h2 id="灰度图像，彩色图像，二值图像"><a href="#灰度图像，彩色图像，二值图像" class="headerlink" title="灰度图像，彩色图像，二值图像"></a>灰度图像，彩色图像，二值图像</h2><p><img src="/images/image-20200705210342616.png" alt="image-20200705210342616"></p>
<p>。。。这也太。不行学过画画想笑。。</p>
<h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><p><img src="/images/image-20200705210534413.png" alt="image-20200705210534413"></p>
<p>采样有点像绘画里的最小笔触。。</p>
<h2 id="采样对图像的影响"><a href="#采样对图像的影响" class="headerlink" title="采样对图像的影响"></a>采样对图像的影响</h2><p><img src="/images/image-20200705210633781.png" alt="image-20200705210633781"></p>
<p><img src="/images/image-20200705210912698.png" alt="image-20200705210912698"></p>
<p>缩小的时候要取的像素颜色值，近邻的颜色值</p>
<h2 id="量化对图像的影响，灰度的级别"><a href="#量化对图像的影响，灰度的级别" class="headerlink" title="量化对图像的影响，灰度的级别"></a>量化对图像的影响，灰度的级别</h2><p><img src="/images/image-20200705211037649.png" alt="image-20200705211037649"></p>
<p>细节量</p>
<h2 id="影响图像质量的因素"><a href="#影响图像质量的因素" class="headerlink" title="影响图像质量的因素"></a>影响图像质量的因素</h2><h3 id="层次（灰度？"><a href="#层次（灰度？" class="headerlink" title="层次（灰度？"></a>层次（灰度？</h3><p><img src="/images/image-20200705211210183.png" alt="image-20200705211210183"></p>
<h3 id="对比度"><a href="#对比度" class="headerlink" title="对比度"></a>对比度</h3><p><img src="/images/image-20200705211228655.png" alt="image-20200705211228655"></p>
<h3 id="亮度-明度"><a href="#亮度-明度" class="headerlink" title="亮度(明度)"></a>亮度(明度)</h3><p><img src="/images/image-20200705211256646.png" alt="image-20200705211256646"></p>
<h3 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h3><p><img src="/images/image-20200705211424148.png" alt="image-20200705211424148"></p>
<h3 id="细节-像素大小"><a href="#细节-像素大小" class="headerlink" title="细节(像素大小)"></a>细节(像素大小)</h3><p><img src="/images/image-20200705211518629.png" alt="image-20200705211518629"></p>
<h3 id="饱和度"><a href="#饱和度" class="headerlink" title="饱和度"></a>饱和度</h3><p><img src="/images/image-20200705211541549.png" alt="image-20200705211541549"></p>
<h2 id="像素之间的关系"><a href="#像素之间的关系" class="headerlink" title="像素之间的关系"></a>像素之间的关系</h2><h3 id="4近邻"><a href="#4近邻" class="headerlink" title="4近邻"></a>4近邻</h3><p><img src="/images/image-20200705211624822.png" alt="image-20200705211624822"></p>
<h3 id="8近邻"><a href="#8近邻" class="headerlink" title="8近邻"></a>8近邻</h3><p><img src="/images/image-20200705211755641.png" alt="image-20200705211755641"></p>
<h3 id="连通"><a href="#连通" class="headerlink" title="连通"></a>连通</h3><p><img src="/images/image-20200705211828649.png" alt="image-20200705211828649"></p>
<p>灰度值相等或者差值在某个范围内</p>
<p><img src="/images/image-20200705211927016.png" alt="image-20200705211927016"></p>
<p><img src="/images/image-20200705211959672.png" alt="image-20200705211959672"></p>
<p><img src="/images/image-20200705212102159.png" alt="image-20200705212102159"></p>
<h3 id="通路"><a href="#通路" class="headerlink" title="通路"></a>通路</h3><p><img src="/images/image-20200706191409359.png" alt="image-20200706191409359"></p>
<h3 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h3><p><img src="/images/image-20200706191601356.png" alt="image-20200706191601356"></p>
<p><img src="/images/image-20200706191746275.png" alt="image-20200706191746275"></p>
]]></content>
      <categories>
        <category>图像处理</category>
      </categories>
      <tags>
        <tag>图像处理</tag>
      </tags>
  </entry>
  <entry>
    <title>图形学科研之路-1.开篇.Interactive computer graphics</title>
    <url>/2020/06/29/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E7%A7%91%E7%A0%94%E4%B9%8B%E8%B7%AF-1-%E5%BC%80%E7%AF%87-Interactive-computer-graphics/</url>
    <content><![CDATA[<p>知乎的书单，开始读了。<a href="https://zhuanlan.zhihu.com/p/27158983" target="_blank" rel="noopener">【书单】图形学科研之路（持续更新）</a></p>
<p><a href="http://gen.lib.rus.ec/" target="_blank" rel="noopener">genlib</a>找的第一本书 Interactive computer graphics : a top-down approach with shader-based OpenGL / Edward Angel et </p>
<p>OpenGl这东西也用一些，网上很多教程也烂大街了，但是说实话到最后都没看下去，都是停在前面那点知识，这本书中一句话让我对API消解了纠结，确实学API的同时也了解了底层的算法实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A graphics class teaches far more than the use ofa particular API, but a good API makes it easier to teach key graphics topics, including three-dimensional graphics, lighting and shading, client–server graphics, modeling, and implementation algorithms. We believe that OpenGL’s extensive capabilities and well-defined architecture lead to a stronger foundation for teaching both theoretical and practical aspects of the field and for teaching advanced concepts, including texture mapping, compositing, and programmable shaders.</span><br><span class="line">图形学所教授的远远不止是使用一个特定的API，但是一个好的API可以使它更容易地教授关键的图形主题，包括三维图形、光照和阴影、客户机-服务器图形、建模和实现算法。OpenGL广泛的能力和定义良好的架构为该领域的理论和实践方面的教学以及高级概念(包括纹理映射、合成和可编程着色器)的教学奠定了更坚实的基础。</span><br></pre></td></tr></table></figure>
<p>关于这本书的作者，看来看去我算是明白了，做图形学的就那么几批人。</p>
<p><a href="https://www.cs.unm.edu/~angel/" target="_blank" rel="noopener">Edward Angel</a> 主页上没什么可看的，我简称这人叫爱吉，有用的信息就是他研究的领域volume visualization, virtual reality, and masssively parallel computing.，体积视觉化，虚拟现实，大规模并行计算。</p>
<p>He has taught over 100 professional short courses including a MOOC with Coursera and at both SIGGRAPH and SIGGRAPH Asia.</p>
<p>这人貌似还在慕课MOOC，Coursera上有开课的，之后去看看，SIGGRAPH SIGGRAPH Asia.也有他的课。</p>
<h1 id="1-一些概念"><a href="#1-一些概念" class="headerlink" title="1.一些概念"></a>1.一些概念</h1><h2 id="光栅，帧缓冲，分辨率"><a href="#光栅，帧缓冲，分辨率" class="headerlink" title="光栅，帧缓冲，分辨率"></a>光栅，帧缓冲，分辨率</h2><p>之前一直不知道光栅是什么意思，光栅化是个啥，看了看发现大概理解为像素的数组就行了，像素数组的名字是帧缓冲，写出来相当于FrameBuffer[Pixels]，帧缓冲中像素的数目叫分辨率，这不就是数组的大小吗。。。帧缓冲深度就是像素比特数，决定能用多少个颜色 ，1bit只有黑白两个颜色，8bits有256个颜色，HDR分配的比特位更多，传统帧缓冲用整数，现在有了浮点格式来存储颜色值。</p>
<p>在非常简单的系统中,帧缓存只存储屏幕上显示的像素的颜色值。在大多数系统中,帧缓存存储的信息要多得多,比如为了从三维数据生成图像需要使用<strong>深度信息</strong>。在这样的系统中,<strong>帧缓存包括许多缓存</strong>,其中有一个或多个用于存储要显示的像素颜色,称为<strong>颜色缓存</strong>(colorbuffer)。狭义来说可以把帧缓存和颜色缓存当做同义词使用。</p>
<p>从几何实体到帧缓存中像素的颜色和位置的转换称为<strong>光栅化( rasterization)</strong>或者<strong>扫描转换(scan conversion)</strong></p>
<p><img src="/images/image-20200701202701994.png" alt="image-20200701202701994"></p>
<h2 id="第一章一些课后问题与答案"><a href="#第一章一些课后问题与答案" class="headerlink" title="第一章一些课后问题与答案"></a>第一章一些课后问题与答案</h2><p>1.8 为了以足够高的速度刷新显示器来避免闪烁,帧缓存的速度必须足够快。一个典型的工作站显示器的分辨率可以是1280 x 1024,如果每秒钟刷新72次,那么帧缓存的速度必须有多快?这指的是从帧缓存中读取一个像素可以用多长时间。如果刷新频率为60 Hz,分辨率为480 x640的隔行扫描显示器呢?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">视帧缓存的深度而定,以帧缓存为深度为1为例,速度为,1024*1280*1*72b=11.25MB/s,即读取一个像素用时倒数分之1每秒。隔行扫描, 72变30.</span><br></pre></td></tr></table></figure>
<p>1.9 制作电影的胶片所具有的分辨率大约是2000 x3000这样的分辨率对于制作与电影画质相当的电视动画意味着什么?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">每帧480*640像素的视频显示仅含有300K像素(普屏动画),而2000*3000像素的电影帧有6M像素,约多了18倍的显示时间,因此需要18倍的时间渲染</span><br></pre></td></tr></table></figure>
<h1 id="2-编程"><a href="#2-编程" class="headerlink" title="2.编程"></a>2.编程</h1><p>不是从三角形开始好评(不是XD)</p>
<h2 id="2-1-Sierpinski-镂垫（感觉是茶杯垫一样的东西"><a href="#2-1-Sierpinski-镂垫（感觉是茶杯垫一样的东西" class="headerlink" title="2.1 Sierpinski 镂垫（感觉是茶杯垫一样的东西"></a>2.1 Sierpinski 镂垫（感觉是茶杯垫一样的东西</h2><p><img src="/images/image-20200701212252813.png" alt="image-20200701212252813"></p>
<p>Sierpinski镂垫在分形几何领域中是重要的研究对象，可按递归和随机的方式来定义Sierpinski镂垫,当迭代的次数趋于无限时,其性质完全确定,并不随机,镂垫的三维版本与二维版本几乎相同。</p>
<p>从空间中的三个点开始，只要这些点不是共线的,就定义了一个三角形也定义了一个平面。假定这个平面z=0,并且这些点在某个坐标系下的坐标是(x1,y1,0),(x2, y2, 0)和(x3, y3, 0).</p>
<p>构造过程如下:</p>
<p>1,在三角形内随机选择一个初始点p(x, y, 0)。</p>
<p>2,随机选择3个顶点之一。</p>
<p>3,找出p和随机选择的这个顶点之间的中点q。</p>
<p>4,在显示器上把这个中点q所对应的位置用某种标记(比如小圆圈)显示出来。</p>
<p>5·用这个中点q替换p</p>
<p>6.转步骤2</p>
<p>每当计算出一个新的点,就把它显示在输出设备上。这个过程如图所示,其中po是初始点,p,和p2是该算法首先生成的两个点。</p>
<p><img src="/images/image-20200701212715251.png" alt="image-20200701212715251"></p>
<h2 id="2-2-具体编程有两种办法-立即绘制模式和延迟绘制模式"><a href="#2-2-具体编程有两种办法-立即绘制模式和延迟绘制模式" class="headerlink" title="2.2 具体编程有两种办法 立即绘制模式和延迟绘制模式"></a>2.2 具体编程有两种办法 立即绘制模式和延迟绘制模式</h2><p><img src="/images/image-20200702122849249.png" alt="image-20200702122849249"></p>
<p>立即模式就是边算边显示，再显示的话就要重新计算。</p>
<p><img src="/images/image-20200702123110074.png" alt="image-20200702123110074"></p>
<p>延迟绘制模式是把所有的点计算出来，用空间换时间，把数据存储起来，不用重新计算，如果点的颜色发生变化，就可以重新发送而不需要重新计算。</p>
<h2 id="2-3-两种模式的缺点"><a href="#2-3-两种模式的缺点" class="headerlink" title="2.3 两种模式的缺点"></a>2.3 两种模式的缺点</h2><p>假定要制作一个动画,希望反复显示同一个对象,对象的几何外观不变,但是对象的位置可能要移动。每当对象在一个新的位置上显示,就需要把所有需要显示的点从CPU发送到GPU中。如果数据量非常大,那么从CPU到GPU的数据传输会成为显示处理的一个瓶颈。</p>
<p><img src="/images/image-20200702202550176.png" alt="image-20200702202550176"></p>
<p><strong>解决方案</strong>:把顶点存储在GPU中，直接修改GPU中的数据。</p>
<p><img src="/images/image-20200702202959125.png" alt="image-20200702202959125"></p>
<p>如果以动画的形式显示这些数据,由于这些数据已经存储在GPU中,所以重新显示这些数据不需要额外的数据传输开销,而只需要调用一个简单的函数就可以修改对象移动后的空间位置数据。</p>
<p><strong>问题的核心：生成点和显示点</strong></p>
<h2 id="2-4-图形API函数的分类"><a href="#2-4-图形API函数的分类" class="headerlink" title="2.4 图形API函数的分类"></a>2.4 图形API函数的分类</h2><p>1·图元函数2,属性函数3·观察函数4,变换函数5·输入函数 6·控制函数 7,查询函数</p>
<p>这7个任务是不管体系结构，不管API都要实现的共性功能。</p>
<h3 id="1-图元函数"><a href="#1-图元函数" class="headerlink" title="1.图元函数"></a>1.图元函数</h3><p>点，线，像素，文本，曲线，面啥的基本图形</p>
<p><code>OpenGL只直接支持非常有限的图元集,如点、线段和三角形,应用程序可以使用OpenGL支持的图元通过逼近的方式来支持其他图元。对于许多OpenCL不支持的重要对象,例如规则的多面体、二次曲线、Bezier曲线和Bezier曲面,可以使用相关的库来支持。可以通过可编程着色器来高效地支持这些扩展的图元集。</code></p>
<h3 id="2-属性函数"><a href="#2-属性函数" class="headerlink" title="2.属性函数"></a>2.属性函数</h3><p>线的颜色，文本的字体等</p>
<h3 id="3-观察函数-——涉及到裁剪和摄像机"><a href="#3-观察函数-——涉及到裁剪和摄像机" class="headerlink" title="3.观察函数 ——涉及到裁剪和摄像机"></a>3.观察函数 ——涉及到裁剪和摄像机</h3><h3 id="4-变换函数——平移，缩放"><a href="#4-变换函数——平移，缩放" class="headerlink" title="4.变换函数——平移，缩放"></a>4.变换函数——平移，缩放</h3><h3 id="5-输入——键盘鼠标"><a href="#5-输入——键盘鼠标" class="headerlink" title="5.输入——键盘鼠标"></a>5.输入——键盘鼠标</h3><h3 id="6-控制——多处理器多窗口"><a href="#6-控制——多处理器多窗口" class="headerlink" title="6.控制——多处理器多窗口"></a>6.控制——多处理器多窗口</h3><h3 id="7-查询——查点显示器支持的颜色数，显示器尺寸等，API会提供这些函数"><a href="#7-查询——查点显示器支持的颜色数，显示器尺寸等，API会提供这些函数" class="headerlink" title="7.查询——查点显示器支持的颜色数，显示器尺寸等，API会提供这些函数"></a>7.查询——查点显示器支持的颜色数，显示器尺寸等，API会提供这些函数</h3>]]></content>
      <tags>
        <tag>图形学</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title>构成课作业存档</title>
    <url>/2020/04/29/%E6%9E%84%E6%88%90%E8%AF%BE%E4%BD%9C%E4%B8%9A%E5%AD%98%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="第一堂-飞行道具"><a href="#第一堂-飞行道具" class="headerlink" title="第一堂:飞行道具"></a>第一堂:飞行道具</h1>]]></content>
      <categories>
        <category>构成课</category>
      </categories>
      <tags>
        <tag>Krenz</tag>
        <tag>DLC</tag>
        <tag>构成课</tag>
        <tag>基础作业</tag>
      </tags>
  </entry>
  <entry>
    <title>绘画过程与思考-厨房的过程记录</title>
    <url>/2020/04/22/%E7%BB%98%E7%94%BB%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%80%9D%E8%80%83-%E5%8E%A8%E6%88%BF%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="四叶妹妹厨房"><a href="#四叶妹妹厨房" class="headerlink" title="四叶妹妹厨房"></a>四叶妹妹厨房</h2><p><img src="/images/TouShi/siyemeimei/siyemeimei.png" alt=""></p>
<p>这线条我画的好认真啊…</p>
<a id="more"></a>
<p><img src="/images/TouShi/siyemeimei/siyemeimei2.png" alt=""></p>
<p>抱枕和纸片确定人物的占位和比例</p>
<p><img src="/images/TouShi/siyemeimei/siyemeimei3.png" alt=""></p>
<p>3D软件来确定地面然后升起来用色块确定物件的比例</p>
]]></content>
      <categories>
        <category>绘画过程</category>
      </categories>
      <tags>
        <tag>透视课</tag>
        <tag>思考</tag>
        <tag>过程</tag>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Krenz透视课知识点截图汇总</title>
    <url>/2020/04/22/Krenz%E9%80%8F%E8%A7%86%E8%AF%BE%E7%9F%A5%E8%AF%86%E7%82%B9%E6%88%AA%E5%9B%BE%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="大透视"><a href="#大透视" class="headerlink" title="大透视"></a>大透视</h1><h2 id="K大谈大透视创作"><a href="#K大谈大透视创作" class="headerlink" title="K大谈大透视创作"></a>K大谈大透视创作</h2><p><img src="/images/TouShi/KnowLedge/200222 K大答疑：大透视创作.jpg" alt=""></p>
<h1 id="摄影机与角度控制"><a href="#摄影机与角度控制" class="headerlink" title="摄影机与角度控制"></a>摄影机与角度控制</h1><h2 id="透视第一堂"><a href="#透视第一堂" class="headerlink" title="透视第一堂"></a>透视第一堂</h2><p><img src="/images/TouShi/KnowLedge/150704透视第一堂.jpg" alt=""></p>
<h2 id="角度控制和摄影机-refs"><a href="#角度控制和摄影机-refs" class="headerlink" title="角度控制和摄影机_refs"></a>角度控制和摄影机_refs</h2><p><img src="/images/TouShi/KnowLedge/2.角度控制和摄影机_refs.jpg" alt=""></p>
<h2 id="角度控制和摄影机"><a href="#角度控制和摄影机" class="headerlink" title="角度控制和摄影机"></a>角度控制和摄影机</h2><p><img src="/images/TouShi/KnowLedge/2.角度控制和摄影机.jpg" alt=""></p>
<h1 id="安全距离与取景框"><a href="#安全距离与取景框" class="headerlink" title="安全距离与取景框"></a>安全距离与取景框</h1><h2 id="K大说安全的透视距离"><a href="#K大说安全的透视距离" class="headerlink" title="K大说安全的透视距离"></a>K大说安全的透视距离</h2><p><img src="/images/TouShi/KnowLedge/K大说安全的透视距离.png" alt=""></p>
<h2 id="画方块时消失点抓多远的安全参考范围"><a href="#画方块时消失点抓多远的安全参考范围" class="headerlink" title="画方块时消失点抓多远的安全参考范围"></a>画方块时消失点抓多远的安全参考范围</h2><p><img src="/images/TouShi/KnowLedge/画方块时消失点抓多远的安全参考范围.jpg" alt=""></p>
<h2 id="K大说取景框"><a href="#K大说取景框" class="headerlink" title="K大说取景框"></a>K大说取景框</h2><p><img src="/images/TouShi/KnowLedge/K大说取景框-1.jpg" alt=""></p>
<h1 id="分法"><a href="#分法" class="headerlink" title="分法"></a>分法</h1><h2 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h2><p><img src="/images/TouShi/KnowLedge/三分法 boss助教.PNG" alt=""></p>
<h2 id="五分之一分段画法"><a href="#五分之一分段画法" class="headerlink" title="五分之一分段画法"></a>五分之一分段画法</h2><p><img src="/images/TouShi/KnowLedge/五分之一分段画法.jpg.png" alt=""></p>
<h2 id="七分之一分段画法"><a href="#七分之一分段画法" class="headerlink" title="七分之一分段画法"></a>七分之一分段画法</h2><p><img src="/images/TouShi/KnowLedge/七分之一分段画法.jpg" alt=""></p>
<h1 id="16个方块"><a href="#16个方块" class="headerlink" title="16个方块"></a>16个方块</h1><p><img src="/images/TouShi/KnowLedge/方块1.png" alt=""></p>
<p><img src="/images/TouShi/KnowLedge/方块2.png" alt=""></p>
]]></content>
      <categories>
        <category>透视课</category>
      </categories>
      <tags>
        <tag>透视课</tag>
        <tag>Krenz</tag>
        <tag>知识点</tag>
        <tag>截图</tag>
        <tag>大透视</tag>
        <tag>取景框</tag>
        <tag>安全距离</tag>
        <tag>摄像机</tag>
        <tag>角度控制</tag>
        <tag>分段</tag>
      </tags>
  </entry>
  <entry>
    <title>色彩课心智图-文字总结</title>
    <url>/2020/04/21/%E8%89%B2%E5%BD%A9%E8%AF%BE%E5%BF%83%E6%99%BA%E5%9B%BE-%E6%96%87%E5%AD%97%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="L1知识点"><a href="#L1知识点" class="headerlink" title="L1知识点"></a>L1知识点</h2><h3 id="1-焦点"><a href="#1-焦点" class="headerlink" title="1.焦点"></a>1.焦点</h3><p>一張作品中想表現的重點區域，我們在構圖/配色/打光所做的各種安排多是為了突顯焦點</p>
<p>突顯焦點的方法：①灰純對比     ②冷暖(色相)對比    ③邊緣虚實對比    </p>
<p>​                            ④明度对比      ⑤疏密對比              ⑥視覺導引</p>
<h3 id="2-权利游戏-权重"><a href="#2-权利游戏-权重" class="headerlink" title="2.权利游戏(权重)"></a>2.权利游戏(权重)</h3><p>就像三國志的勢力圖,我們每下一筆色彩/光影/形狀,都會造成圖面上的勢力波動，要保持焦點擁有較好/較稀缺的資源(較顯眼)</p>
<h3 id="3-固有色配色"><a href="#3-固有色配色" class="headerlink" title="3.固有色配色"></a>3.固有色配色</h3><h4 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想:"></a>核心思想:</h4><p>高富帥主角-確認焦點處的重要地位，給予高純度/特殊色相/高明度差等等強烈對比，人物畫來說,通常是瞳孔/髮飾/首飾等等區域，高純度/冷暖明顯的這個色彩又常被說是提神色</p>
]]></content>
      <categories>
        <category>色彩课</category>
      </categories>
      <tags>
        <tag>Krenz</tag>
        <tag>知识点</tag>
        <tag>色彩</tag>
        <tag>色彩课</tag>
      </tags>
  </entry>
  <entry>
    <title>色彩知识点-藏色</title>
    <url>/2020/04/21/%E8%89%B2%E5%BD%A9%E7%9F%A5%E8%AF%86%E7%82%B9-%E8%97%8F%E8%89%B2/</url>
    <content><![CDATA[<h2 id="1-藏色的逻辑"><a href="#1-藏色的逻辑" class="headerlink" title="1.藏色的逻辑"></a>1.藏色的逻辑</h2><p><img src="/images/cangse/L4_LogicOfCangSe-Krenz.jpg" alt="藏色的逻辑"></p>
]]></content>
      <categories>
        <category>色彩课</category>
      </categories>
      <tags>
        <tag>Krenz</tag>
        <tag>DLC</tag>
        <tag>知识点</tag>
        <tag>色彩</tag>
        <tag>色彩课</tag>
        <tag>油画</tag>
        <tag>藏色</tag>
        <tag>小结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Shader学习笔记-1-一个最简单的顶点/片元着色器</title>
    <url>/2020/02/05/Unity-Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E9%A1%B6%E7%82%B9-%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8/</url>
    <content><![CDATA[<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Shader <span class="string">"Custom/Chapter5-SimpleShader"</span> &#123;</span><br><span class="line"></span><br><span class="line">    SubShader &#123;</span><br><span class="line">        Pass&#123;</span><br><span class="line">            CGPROGRAM</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 两条非常重要的编译指令</span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> vertex vert <span class="comment">// 定点着色器</span></span></span><br><span class="line">            <span class="meta">#<span class="meta-keyword">pragma</span> fragment frag <span class="comment">// 片元着色器</span></span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 这一步是把顶点坐标从模型空间转换到裁剪空间</span></span><br><span class="line">            float4 vert(float4 v : POSITION) : SV_POSITION &#123;</span><br><span class="line">                <span class="keyword">return</span> mul(UNITY_MATRIX_MVP, v);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag() : SV_Target&#123;</span><br><span class="line">                <span class="keyword">return</span> fixed4(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>vert , 顶点着色器代码, 逐顶点执行, 函数的输入 v 包含了这个顶点的位置, 返回值是该顶点在模型空间中的位置, POSITION : 把模型的顶点坐标填充到输入参数中, SV_POSITION : 顶点着色器的输出是裁剪空间中的顶点坐标</li>
<li>frag , SV_Target : 把用户的输出颜色存储到一个渲染目标中, 这里将输出到默认的帧缓存中, 片元着色器输出的颜色的每个分量范围是[0,1].</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>学习笔记</tag>
        <tag>Shader</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity学习笔记- -脚本的开发学习</title>
    <url>/2020/02/05/unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E8%84%9A%E6%9C%AC%E7%9A%84%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/02/05/QVcsmbGEn8UjKdY.png" alt="image.png"></p>
]]></content>
  </entry>
  <entry>
    <title>unity学习笔记-3-SkyBox天空盒的学习</title>
    <url>/2020/02/05/unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-SkyBox%E5%A4%A9%E7%A9%BA%E7%9B%92%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="2D图片-gt-SkyBox"><a href="#2D图片-gt-SkyBox" class="headerlink" title="2D图片-&gt;SkyBox"></a>2D图片-&gt;SkyBox</h2><p><img src="https://i.loli.net/2020/02/05/KrjtCvahF5XdUkn.png" alt="image.png"></p>
<p>Texture Shape-&gt;从2D转为Cube 就变为可以用的天空盒了</p>
<p><img src="https://i.loli.net/2020/02/05/uBVJZXNW7ysGq1v.png" alt="image.png"></p>
<p>2017之前可以直接拖动</p>
<p>2017之后的版本要新建一个Material Shader-&gt;SkyBox-&gt;Cubemap在CubeMap里拖动上面做好的SkyBox</p>
<p><img src="https://i.loli.net/2020/02/05/iQzCqR6hXjnNoHe.png" alt="image.png"></p>
<h2 id="CubeMap"><a href="#CubeMap" class="headerlink" title="CubeMap"></a>CubeMap</h2><p><img src="https://i.loli.net/2020/02/05/BCLe8HqN16aUPmi.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Tint Color 基础颜色</span><br><span class="line">-Exposure 曝光程度</span><br><span class="line">-Rotation 旋转</span><br></pre></td></tr></table></figure>
<h2 id="HDRI"><a href="#HDRI" class="headerlink" title="HDRI"></a>HDRI</h2><p><img src="https://i.loli.net/2020/02/05/oj1g9Xy5hiBnCrv.png" alt="image.png"></p>
<p>1.转为Cube可以作为SkyBox</p>
<p>2.新建Material Shader-&gt;Skybox-&gt;Panoramic</p>
<p><img src="https://i.loli.net/2020/02/05/FYgXDlbqduHQmrV.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/02/05/ZCkGi8meLJD16UQ.png" alt="image.png"></p>
<iframe src="//player.bilibili.com/player.html?aid=57479723&cid=100349191&page=8" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>



<h2 id="Lighting-Setting"><a href="#Lighting-Setting" class="headerlink" title="Lighting Setting"></a>Lighting Setting</h2><h2 id="Environment环境"><a href="#Environment环境" class="headerlink" title="Environment环境"></a>Environment环境</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Sun Source 最亮的灯作为太阳 默认为Direction Light</span><br></pre></td></tr></table></figure>
<h2 id="Environment-Lighting"><a href="#Environment-Lighting" class="headerlink" title="Environment Lighting"></a>Environment Lighting</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-Source [Color][SkyBox][]</span><br><span class="line"></span><br><span class="line">-SKy Color 天空</span><br><span class="line">-Equator Color 赤道</span><br><span class="line">-Ground Color地面</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/05/9x5zcBZbFmktNAa.png" alt="image.png"></p>
<p>方块基本色是白色的，但是因为环境光的影响变为了粉色，环境光的颜色是场景里最暗的不可能有比之还暗的颜色</p>
<p><img src="https://i.loli.net/2020/02/05/v8EkQqxspFXaSVc.png" alt="image.png"></p>
<p>注意这是球体反射的环境，-SKy Color 天空-Equator Color 赤道-Ground Color地面的设置</p>
<h2 id="Environment-Reflections环境反射"><a href="#Environment-Reflections环境反射" class="headerlink" title="Environment Reflections环境反射"></a>Environment Reflections环境反射</h2><p>环境反射：Environment Reflections</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-source  预设使用Skybox反射</span><br><span class="line">-Resolution 分辨率</span><br><span class="line">-Compression 压缩  集成显卡不压缩 好的显卡选择Compression</span><br><span class="line">-Intensity Multiplier 权重</span><br><span class="line">-Bounces 反射次数</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/05/cIu5Ct2AGKiBl47.png" alt="image.png"></p>
<p>但是这里反射是假的反射，在旁白新建一个物体的话，其不会反射出来</p>
<p><img src="https://i.loli.net/2020/02/05/V8OdklMDUFbaR2Z.png" alt="image.png"></p>
<p>更改SkyBox的话其反射也会不符合环境</p>
<h3 id="Reflection-Probe"><a href="#Reflection-Probe" class="headerlink" title="Reflection Probe"></a>Reflection Probe</h3><p>如果要把旁边的正方体反射出来需要使用Reflection Probe</p>
<p><img src="https://i.loli.net/2020/02/05/vmVzD7dUFRlG2HE.png" alt="image.png"></p>
<h2 id="Material的金属与环境光的作用"><a href="#Material的金属与环境光的作用" class="headerlink" title="Material的金属与环境光的作用"></a>Material的金属与环境光的作用</h2><p><img src="https://i.loli.net/2020/02/05/UE6DrX3BWcLv9nO.png" alt="image.png">0的话偏向环境光，1 的话偏向环境反射</p>
<p><img src="https://i.loli.net/2020/02/05/4wQs3L9WqiYaG7j.png" alt="image.png"></p>
<h2 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频"></a>参考视频</h2><iframe src="//player.bilibili.com/player.html?aid=57479723&cid=100349324&page=9" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Unity</tag>
        <tag>SkyBox</tag>
      </tags>
  </entry>
  <entry>
    <title>unity学习笔记-2-Material的学习</title>
    <url>/2020/02/05/unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-Material%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="材质球的基本属性"><a href="#材质球的基本属性" class="headerlink" title="材质球的基本属性"></a>材质球的基本属性</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Main Maps</span><br><span class="line">	-1.Albedo:Texture 贴图 漫反射 基础色</span><br><span class="line">	</span><br><span class="line">	-2.Tiling 重复次数</span><br><span class="line">	-3.offset 偏移</span><br><span class="line">	</span><br><span class="line">	-4.Smothness 光滑度 0 橡皮树木 1玻璃</span><br><span class="line">	-5 Metalic 金属度 铁 有科学的数值 查表</span><br><span class="line">	</span><br><span class="line">	-6 Normal 法线贴图 节约资源</span><br></pre></td></tr></table></figure>
<h2 id="视觉的欺骗-Normal-法线贴图"><a href="#视觉的欺骗-Normal-法线贴图" class="headerlink" title="视觉的欺骗:Normal 法线贴图"></a>视觉的欺骗:Normal 法线贴图</h2><p><img src="https://i.loli.net/2020/02/05/T7zfuhdJXVnsUZl.png" alt="image.png"></p>
<p>可以在网上搜索Pbr Material </p>
<p>低模可以通过法线贴图显得很逼真和漂亮，手机游戏避免资源的消耗使用法线贴图</p>
<p>高模转低模过程中生成法线贴图使用</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>学习笔记</tag>
        <tag>Unity</tag>
        <tag>Material</tag>
        <tag>材质</tag>
      </tags>
  </entry>
  <entry>
    <title>unity学习笔记-0-安装Unity配置编辑器与界面中文语言包安装</title>
    <url>/2020/02/05/unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-0-%E5%AE%89%E8%A3%85Unity%E9%85%8D%E7%BD%AE%E7%BC%96%E8%BE%91%E5%99%A8%E4%B8%8E%E7%95%8C%E9%9D%A2%E4%B8%AD%E6%96%87%E8%AF%AD%E8%A8%80%E5%8C%85%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="配置编辑器"><a href="#配置编辑器" class="headerlink" title="配置编辑器"></a>配置编辑器</h2><p>edit-&gt;preference-&gt;external Tools 编辑器选择VS或者MONO</p>
<h2 id="界面汉语"><a href="#界面汉语" class="headerlink" title="界面汉语"></a>界面汉语</h2><p><img src="https://i.loli.net/2020/02/05/AhrysQda7ZN42cI.png" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\Program Files\Unity\Editor\Data\Localization</span><br></pre></td></tr></table></figure>
<p>没有localization就新建一个，将zh-cn.po文件扔进去</p>
<h2 id="Unity视窗"><a href="#Unity视窗" class="headerlink" title="Unity视窗"></a>Unity视窗</h2><p><img src="https://i.loli.net/2020/02/05/VpgUYToDxQfLitA.png" alt="image.png"></p>
<p>game视窗可以拖拽进行改变</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">toolBar 工作列</span><br><span class="line"></span><br><span class="line">hierarchy 树状图</span><br><span class="line"></span><br><span class="line">Scene View 3D编辑器</span><br><span class="line"></span><br><span class="line">Inspector 参数栏</span><br><span class="line"></span><br><span class="line">Project 资源管理器</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/02/05/fTzs7EoRMFYur8O.png" alt="image.png"></p>
<p>文件夹和管理器的同步</p>
<p><img src="https://i.loli.net/2020/02/05/M7UvjDkOXChyYpr.png" alt="image.png"></p>
<h2 id="复制物件Ctrl-d"><a href="#复制物件Ctrl-d" class="headerlink" title="复制物件Ctrl+d"></a>复制物件Ctrl+d</h2><iframe src="//player.bilibili.com/player.html?aid=57479723&cid=100348215&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>学习笔记</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>unity学习笔记-1-点击按钮Button生成Cube</title>
    <url>/2020/02/05/unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AEButton%E7%94%9F%E6%88%90Cube/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>学习笔记</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>VisualStudio学习笔记-VisualZStudio编译器及其版本的问题</title>
    <url>/2020/02/04/VisualStudio%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-VisualZStudio%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%8A%E5%85%B6%E7%89%88%E6%9C%AC%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>一些编译器版本的_MSC_VER值</p>
<h2 id="VC-编译器的版本号"><a href="#VC-编译器的版本号" class="headerlink" title="VC++编译器的版本号"></a>VC++编译器的版本号</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MS VC++ <span class="number">15.0</span> _MSC_VER = <span class="number">1910</span> (Visual Studio <span class="number">2017</span>)</span><br><span class="line">MS VC++ <span class="number">14.0</span> _MSC_VER = <span class="number">1900</span> (Visual Studio <span class="number">2015</span>)</span><br><span class="line">MSVC++ <span class="number">12.0</span> _MSC_VER == <span class="number">1800</span> (Visual Studio <span class="number">2013</span>)</span><br><span class="line">MSVC++ <span class="number">11.0</span> _MSC_VER == <span class="number">1700</span> (Visual Studio <span class="number">2012</span>)</span><br><span class="line">MSVC++ <span class="number">10.0</span> _MSC_VER == <span class="number">1600</span> (Visual Studio <span class="number">2010</span>)</span><br><span class="line">MSVC++ <span class="number">9.0</span>  _MSC_VER == <span class="number">1500</span> (Visual Studio <span class="number">2008</span>)</span><br><span class="line">MSVC++ <span class="number">8.0</span>  _MSC_VER == <span class="number">1400</span> (Visual Studio <span class="number">2005</span>)</span><br><span class="line">MSVC++ <span class="number">7.1</span>  _MSC_VER == <span class="number">1310</span> (Visual Studio <span class="number">2003</span>)</span><br><span class="line">MSVC++ <span class="number">7.0</span>  _MSC_VER == <span class="number">1300</span> (VisualStudio .NET)</span><br><span class="line">MSVC++ <span class="number">6.0</span>  _MSC_VER == <span class="number">1200</span> (VisualStudio  <span class="number">98</span>)</span><br><span class="line">MSVC++ <span class="number">5.0</span>  _MSC_VER == <span class="number">1100</span> (VisualStudio  <span class="number">97</span>)</span><br></pre></td></tr></table></figure>
<p>关于编译器版本号的查看，需要说名的是：这里的版本号并不是指在“Microsoft Visual Studio——Help——About”里的“Version”的值，这个版本号是指Visual Studio的版本号，而不是VC++编译器的版本号，VC++编译器在Visual Studio里面是指“<a href="https://baike.baidu.com/item/cl.exe/9443290" target="_blank" rel="noopener">cl.exe</a>”程序，该程序才是编译C++代码的真正编译器，如查看“cl.exe”的版本号，以在WIndows 7查看VC 2005的“cl.exe”的版本号为例，“开始——所有程序——Microsoft Visual Studio 2005——Visual Studio Tools——Visual Studio 2005 Command Prompt”进入<a href="https://baike.baidu.com/item/VC%2B%2B/2668342" target="_blank" rel="noopener">VC++</a> 2005命令行，运行“<strong>cl /?</strong>”，将会看到如下的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Microsoft (R) 32-bit C/C++ Optimizing Compiler Version 14.00.50727.762 for 80x86</span><br><span class="line">Copyright (C) Microsoft Corporation. All rights reserved.</span><br></pre></td></tr></table></figure>
<p><a href="https://en.wikipedia.org/wiki/Microsoft_Visual_C%2B%2B#Internal_version_numbering" target="_blank" rel="noopener">Microsoft Visual C++</a>可查看全部的版本号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MSC    <span class="number">2.0</span>   _MSC_VER == <span class="number">200</span></span><br><span class="line">MSC    <span class="number">3.0</span>   _MSC_VER == <span class="number">300</span></span><br><span class="line">MSC    <span class="number">4.0</span>   _MSC_VER == <span class="number">400</span></span><br><span class="line">MSC    <span class="number">5.0</span>   _MSC_VER == <span class="number">500</span></span><br><span class="line">MSC    <span class="number">6.0</span>   _MSC_VER == <span class="number">600</span></span><br><span class="line">MSC    <span class="number">7.0</span>   _MSC_VER == <span class="number">700</span></span><br><span class="line">MSVC++ <span class="number">1.0</span>   _MSC_VER == <span class="number">800</span></span><br><span class="line">MSVC++ <span class="number">2.0</span>   _MSC_VER == <span class="number">900</span></span><br><span class="line">MSVC++ <span class="number">4.0</span>   _MSC_VER == <span class="number">1000</span> (Developer Studio <span class="number">4.0</span>)</span><br><span class="line">MSVC++ <span class="number">4.2</span>   _MSC_VER == <span class="number">1020</span> (Developer Studio <span class="number">4.2</span>)</span><br><span class="line">MSVC++ <span class="number">5.0</span>   _MSC_VER == <span class="number">1100</span> (Visual Studio <span class="number">97</span> version <span class="number">5.0</span>)</span><br><span class="line">MSVC++ <span class="number">6.0</span>   _MSC_VER == <span class="number">1200</span> (Visual Studio <span class="number">6.0</span> version <span class="number">6.0</span>)</span><br><span class="line">MSVC++ <span class="number">7.0</span>   _MSC_VER == <span class="number">1300</span> (Visual Studio .NET <span class="number">2002</span> version <span class="number">7.0</span>)</span><br><span class="line">MSVC++ <span class="number">7.1</span>   _MSC_VER == <span class="number">1310</span> (Visual Studio .NET <span class="number">2003</span> version <span class="number">7.1</span>)</span><br><span class="line">MSVC++ <span class="number">8.0</span>   _MSC_VER == <span class="number">1400</span> (Visual Studio <span class="number">2005</span> version <span class="number">8.0</span>)</span><br><span class="line">MSVC++ <span class="number">9.0</span>   _MSC_VER == <span class="number">1500</span> (Visual Studio <span class="number">2008</span> version <span class="number">9.0</span>)</span><br><span class="line">MSVC++ <span class="number">10.0</span>  _MSC_VER == <span class="number">1600</span> (Visual Studio <span class="number">2010</span> version <span class="number">10.0</span>)</span><br><span class="line">MSVC++ <span class="number">11.0</span>  _MSC_VER == <span class="number">1700</span> (Visual Studio <span class="number">2012</span> version <span class="number">11.0</span>)</span><br><span class="line">MSVC++ <span class="number">12.0</span>  _MSC_VER == <span class="number">1800</span> (Visual Studio <span class="number">2013</span> version <span class="number">12.0</span>)</span><br><span class="line">MSVC++ <span class="number">14.0</span>  _MSC_VER == <span class="number">1900</span> (Visual Studio <span class="number">2015</span> version <span class="number">14.0</span>)</span><br><span class="line">MSVC++ <span class="number">14.1</span>  _MSC_VER == <span class="number">1910</span> (Visual Studio <span class="number">2017</span> version <span class="number">15.0</span>)</span><br><span class="line">MSVC++ <span class="number">14.11</span> _MSC_VER == <span class="number">1911</span> (Visual Studio <span class="number">2017</span> version <span class="number">15.3</span>)</span><br><span class="line">MSVC++ <span class="number">14.12</span> _MSC_VER == <span class="number">1912</span> (Visual Studio <span class="number">2017</span> version <span class="number">15.5</span>)</span><br><span class="line">MSVC++ <span class="number">14.13</span> _MSC_VER == <span class="number">1913</span> (Visual Studio <span class="number">2017</span> version <span class="number">15.6</span>)</span><br><span class="line">MSVC++ <span class="number">14.14</span> _MSC_VER == <span class="number">1914</span> (Visual Studio <span class="number">2017</span> version <span class="number">15.7</span>)</span><br><span class="line">MSVC++ <span class="number">14.15</span> _MSC_VER == <span class="number">1915</span> (Visual Studio <span class="number">2017</span> version <span class="number">15.8</span>)</span><br><span class="line">MSVC++ <span class="number">14.16</span> _MSC_VER == <span class="number">1916</span> (Visual Studio <span class="number">2017</span> version <span class="number">15.9</span>)</span><br><span class="line">MSVC++ <span class="number">14.2</span>  _MSC_VER == <span class="number">1920</span> (Visual Studio <span class="number">2019</span> Version <span class="number">16.0</span>)</span><br><span class="line">MSVC++ <span class="number">14.21</span> _MSC_VER == <span class="number">1921</span> (Visual Studio <span class="number">2019</span> Version <span class="number">16.1</span>)</span><br><span class="line">MSVC++ <span class="number">14.22</span> _MSC_VER == <span class="number">1922</span> (Visual Studio <span class="number">2019</span> Version <span class="number">16.2</span>)</span><br><span class="line">MSVC++ <span class="number">14.23</span> _MSC_VER == <span class="number">1923</span> (Visual Studio <span class="number">2019</span> Version <span class="number">16.3</span>)</span><br><span class="line">MSVC++ <span class="number">14.24</span> _MSC_VER == <span class="number">1924</span> (Visual Studio <span class="number">2019</span> Version <span class="number">16.4</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>VisualStudio</category>
      </categories>
      <tags>
        <tag>VisualStudio</tag>
      </tags>
  </entry>
  <entry>
    <title>杂-虚拟机的配置和使用</title>
    <url>/2020/02/04/%E6%9D%82-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E9%85%8D%E7%BD%AE%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>最近终于在安装开发环境的途中崩溃了，也用上了虚拟机，啊<del>~</del><del>~</del><del>~</del>~ ~~~~(风扇)</p>
<p>每次构建一个东西啊<del>~ ~</del>  ~~~         ~~</p>
<p>~~   都会报错啊~~  ~   ~~~ </p>
<p>用了虚拟机<del>~     啊    ~</del>   一个顶俩啊 <del>~</del>   草  这就是传说中的windows-vmware虚拟机-windows结构套娃？</p>
<p>还好 只装个Codeblock和wxWidgets开发环境的话应该还可以</p>
]]></content>
      <categories>
        <category>杂</category>
      </categories>
      <tags>
        <tag>VMWare</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt学习笔记-1-QtCreator和QtDesigner的安装与配置</title>
    <url>/2020/02/03/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-QtCreator%E5%92%8CQtDesigner%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>VisualStudio学习笔记-报错-#include stdio.h的报错安全问题</title>
    <url>/2020/02/03/VisualStudio%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8A%A5%E9%94%99-include-stdio-h%E7%9A%84%E6%8A%A5%E9%94%99%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>由于高版本的visual studio默认不让使用scanf等函数，认为这些函数不够安全，而其相对应的代替函数为scanf_s等。如果在visual studio中使用scanf等那些visual studio认为不安全的函数，就会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;scanf&apos;: This function or variable may be unsafe. Consider using scanf_s instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. See online help for details.</span><br></pre></td></tr></table></figure>
<p>以下几种方法可以解决该问题：</p>
<p>1.在文件开头添加 #define _CRT_SECURE_NO_WARNINGS</p>
<p>例如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//添加到头行,添加到stdio.h等头文件后还是会出警告的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%255s"</span>,str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Hello World!\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.在 项目-&gt;属性-&gt;C/C++-&gt;预处理器-&gt;预处理器定义中添加_CRT_SECURE_NO_WARNINGS</p>
<p><img src="https://i.loli.net/2020/02/03/jA5Dc8NHRmSyntQ.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/02/03/djZsWhQHSpPoEAF.png" alt="image.png"></p>
]]></content>
      <categories>
        <category>VisualStudio</category>
      </categories>
      <tags>
        <tag>VisualStudio</tag>
      </tags>
  </entry>
  <entry>
    <title>WxWidgets学习笔记-Tips-Makefile理念学习</title>
    <url>/2020/02/03/WxWidgets%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Tips-Makefile%E7%90%86%E5%BF%B5%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>第一次从零开始开发一个东西，使用到了WxWidgets</p>
<p><img src="https://i.loli.net/2020/02/03/alQyo6WK5Z1YNtd.png" alt="image.png"></p>
<p>其目录就像这样…根本不知道下那个和其区别是什么，是编译器的区别吗？</p>
]]></content>
      <categories>
        <category>WxWidgets图形化界面学习</category>
      </categories>
      <tags>
        <tag>图形界面</tag>
        <tag>WxWidgets</tag>
        <tag>GUI</tag>
        <tag>C++</tag>
        <tag>MakeFile</tag>
      </tags>
  </entry>
  <entry>
    <title>WxWidgets学习笔记-1.1-环境搭建Codeblocks-WxWidgets</title>
    <url>/2020/02/03/WxWidgets%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BACodeblocks-WxWidgets/</url>
    <content><![CDATA[<h2 id="方法1-自己编译"><a href="#方法1-自己编译" class="headerlink" title="方法1:自己编译"></a>方法1:自己编译</h2><p><img src="https://i.loli.net/2020/02/03/wTn5JElicHfN8yV.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/02/03/ANKWxL7H53pR9SG.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/02/03/uklxfGRBAdjH846.png" alt="image.png"></p>
<p><img src="/images/986259-20160830144920371-1144319313.png" alt="img"></p>
<p><img src="https://i.loli.net/2020/02/03/liTDBtmNkyeP2bC.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/02/03/LqU3OhF4CVBtSwu.png" alt="image.png"></p>
<p>记得用管理员打开CMD或者PowerShell</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mingw32-make -f makefile.gcc clean</span><br><span class="line">mingw32-make -f makefile.gcc MONOLITHIC=<span class="number">0</span> SHARED=<span class="number">1</span> UNICODE=<span class="number">1</span> BUILD=release</span><br><span class="line">mingw32-make -f makefile.gcc MONOLITHIC=<span class="number">0</span> SHARED=<span class="number">1</span> UNICODE=<span class="number">1</span> BUILD=debug</span><br></pre></td></tr></table></figure>
<p>SHARED控制wxWidgets是构建DLL（SHARED=1）还是静态库（SHARED=0）。上面构建DLL，是因为动态库较小   且加载比较快。</p>
<p>  MONOLITHIC控制是构建一个单一的库（MONOLITHIC=1）还是多个组件库（MONOLITHIC=0）。</p>
<p>  UNICODE控制wxWidgets以及你的程序是否使用支持Unicode的宽字符串。</p>
<p>  *关于参数的详细解释可以参照<a href="http://blog.csdn[.NET](http://lib.csdn.net/base/dotnet)/longzuyuan/article/details/22382131中写的，在此不再赘余。" target="_blank" rel="noopener">http://blog.csdn[.NET](http://lib.csdn.net/base/dotnet)/longzuyuan/article/details/22382131中写的，在此不再赘余。</a></p>
<p><img src="https://i.loli.net/2020/02/03/KjdXfs2qPYnL65c.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/02/03/fC15pjQadwSiYEe.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2020/02/03/fkYvsnabXVMWLP3.png" alt="image.png"></p>
<h2 id="codeblocks全局环境配置"><a href="#codeblocks全局环境配置" class="headerlink" title="codeblocks全局环境配置"></a>codeblocks全局环境配置</h2><p> 1、打开codeblocks，点击菜单栏的settings-&gt;Global variables…出现下图：</p>
<p><img src="https://i.loli.net/2020/02/04/DI57Ta2UmbHL6Be.png" alt="image.png"></p>
<h3 id="坑"><a href="#坑" class="headerlink" title="坑"></a>坑</h3><p>坑1：每个不同版本的wxWidgets都需要指定的WinGW版本才可以编译，如wxWidgets 3.1.0需要TDM-GCC 4.9 and 5.1版才可以编译，wxWidgets 3.0.2需要TDM-GCC 4.7 and 4.8 才可以编译，一开始没注意到这个问题，用了CodeBlocks中自带的4.9.1去编译wxWidgets 3.0.2，结果自然是中途出错，被坑死了。</p>
<h3 id="参考视频"><a href="#参考视频" class="headerlink" title="参考视频:"></a>参考视频:</h3><iframe width="560" height="315" src="https://www.youtube.com/embed/FgAaiBg4wEE" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<iframe width="560" height="315" src="https://www.youtube.com/embed/PlOhu1KkTZw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<h2 id="方法2-下载"><a href="#方法2-下载" class="headerlink" title="方法2:下载"></a>方法2:下载</h2><h3 id="1-查看gcc和g-的版本"><a href="#1-查看gcc和g-的版本" class="headerlink" title="1.查看gcc和g++的版本"></a>1.查看gcc和g++的版本</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc -v</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">g++ -v</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc version 5.1.0 (tdm-1)</span><br></pre></td></tr></table></figure>
<p>直接找到Gcc相同的版本，这里是<a href="https://github.com/wxWidgets/wxWidgets/releases/tag/v3.0.4" target="_blank" rel="noopener">3.0.4</a></p>
<p><img src="https://i.loli.net/2020/02/04/Zjr29nvHPItWGYS.png" alt="image.png"></p>
<p>下载下来解压</p>
<p><img src="https://i.loli.net/2020/02/04/Ux5zsL9vtOkKMjb.png" alt="image.png"></p>
<p>相当于构建完了</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接:"></a>参考链接:</h2><p><a href="https://jingyan.baidu.com/article/eae0782742ba9d1fec54853f.html" target="_blank" rel="noopener">windowns下查看CodeBlocks中MinGW的gcc版本信息</a></p>
]]></content>
      <categories>
        <category>WxWidgets图形化界面学习</category>
      </categories>
      <tags>
        <tag>图形界面</tag>
        <tag>WxWidgets</tag>
        <tag>GUI</tag>
        <tag>C++</tag>
        <tag>Codeblocks</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo双线部署与双SSH设置</title>
    <url>/2020/01/31/Hexo%E5%8F%8C%E7%BA%BF%E9%83%A8%E7%BD%B2%E4%B8%8E%E5%8F%8CSSH%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="1-SSH配置"><a href="#1-SSH配置" class="headerlink" title="1.SSH配置"></a>1.SSH配置</h2><p>Hexo博客要同时在github和coding上发布，两端同时需要提交代码，这个时候就需要电脑配置多个ssh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">进入~/.ssh目录</span><br><span class="line"></span><br><span class="line">ssh-keygen -t rsa -C &quot;你的邮箱&quot; </span><br><span class="line"></span><br><span class="line">SSH命名为Coding 按回车</span><br><span class="line"></span><br><span class="line">生成ssh成功，会生成coding和Coding.pub文件</span><br><span class="line"></span><br><span class="line">同样的操作，再创建Github ssh</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/01/31/wE8H9QyiRZzLSAf.png" alt="92SZ_NP3XFQGJG4_5BXP5MH.png"></p>
<p><img src="https://i.loli.net/2020/01/31/Sr8wWBPVNIMqU54.png" alt="H~4FLTAPS_8_@A_2PS_WFG3.png"></p>
<p><img src="https://i.loli.net/2020/01/31/upcFLNHEPMqf75W.png" alt="2B_5Z_BO12L`YFF1_UB~__1.png"></p>
<h2 id="2-添加和编辑配置文件config"><a href="#2-添加和编辑配置文件config" class="headerlink" title="2.添加和编辑配置文件config"></a>2.添加和编辑配置文件config</h2><p>在 ~/.ssh 目录下新建一个config文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch ~/.ssh/config</span><br></pre></td></tr></table></figure>
<p>添加如下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># github 个人的GitHub公钥</span><br><span class="line">Host Github</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/Github  # 指定特定的ssh私钥文件</span><br><span class="line">User git</span><br><span class="line"></span><br><span class="line"># Coding 个人的Coding公钥</span><br><span class="line">Host Coding</span><br><span class="line">HostName git.coding.net</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/Coding  # 指定特定的ssh私钥文件</span><br><span class="line">User git</span><br></pre></td></tr></table></figure>
<h2 id="3-绑定github和coding的ssh"><a href="#3-绑定github和coding的ssh" class="headerlink" title="3.绑定github和coding的ssh"></a>3.绑定github和coding的ssh</h2><p><img src="https://i.loli.net/2020/01/31/PL4h13yFRjEGzAc.png" alt="LJV5`2OC4BO4_~_2R@LXXWO.png"></p>
<p><img src="https://i.loli.net/2020/01/31/S83piQJfCOlRtes.png" alt="KA__X~H9S38VCXDWZU2_G0L.png"></p>
<h2 id="4-ssh-add"><a href="#4-ssh-add" class="headerlink" title="4.ssh-add"></a>4.ssh-add</h2><p>手动开启ssh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eval `ssh-agent -s`</span><br></pre></td></tr></table></figure>
<p>执行ssh-add </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add Coding</span><br><span class="line">ssh-add Github</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&apos;ssh-add -K 私钥&apos; 这个命令可以永久生效.</span><br></pre></td></tr></table></figure>
<p>ssh-add -l查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-add -l</span><br><span class="line">2048 SHA256:**********************（一长串) Coding (RSA)</span><br><span class="line">2048 SHA256:******************(一长串) Github (RSA)</span><br></pre></td></tr></table></figure>
<h3 id="关于windows下ssh-add失败的解决办法"><a href="#关于windows下ssh-add失败的解决办法" class="headerlink" title="关于windows下ssh-add失败的解决办法"></a>关于windows下ssh-add失败的解决办法</h3><p>打开git Bash命令行,依次执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec ssh-agent bash</span><br><span class="line">eval ssh-agent -s</span><br><span class="line">ssh-add &quot;XXX\.ssh\id_rsa&quot;</span><br></pre></td></tr></table></figure>
<p>**引号中的路径就是你私钥文件的路径</p>
<h2 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Hi ! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure>
<p>成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T  git@git.coding.net</span><br></pre></td></tr></table></figure>
<p>出现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Coding 提示: Hello *****, You&apos;ve connected to Coding.net via SSH. This is a personal key.</span><br><span class="line">*****，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个个人公钥</span><br></pre></td></tr></table></figure>
<p>成功</p>
<h2 id="hexo下的设置"><a href="#hexo下的设置" class="headerlink" title="hexo下的设置"></a>hexo下的设置</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: </span><br><span class="line">     github: git@github.com:Molers/Molers.github.io.git,master</span><br><span class="line">     coding: git@git.dev.tencent.com:molers233/molers233.git,master</span><br></pre></td></tr></table></figure>
<h2 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h2><p>貌似每一次开启都需要ssh-add</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-add Coding Github</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>博客</tag>
        <tag>部署</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>WxWidgets学习笔记-3-多线程编程</title>
    <url>/2020/01/29/WxWidgets%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>​    大多数时候,事件驱动的GUI程序可以给你造成一个很好的假象:多个任务在同时的运行这是因为,重绘窗口通常只占用很少的时间,用户输入也被很快的进行了处理.然后,有时候,有些任务很难将其分割成足够小的让人难以察觉的小块来运行,这时候就要使用多线程编程了，本章我们来介绍一下在wxWidgets中怎样实现多线程编程在本章的最后,我们将介绍一下多线程编程的一些替代解决方案..</p>
<p>## </p>
<h2 id="1-使用wxThread"><a href="#1-使用wxThread" class="headerlink" title="1.使用wxThread"></a>1.使用wxThread</h2><p>如果你要在你的代码中使用线程,首先要实现一个wxThread的派生类,并且至少要重载其虚函数Entry,这个函数包含了线程要做的主要的事情举例来说,比如我们要用一个单独的线程来计算图片中颜色的数目,下面是我们的派生类的声明:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> :</span> <span class="keyword">public</span> wxThread </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MyThread(wxImage∗ image, <span class="keyword">int</span>∗ count): </span><br><span class="line">	m image(image), m count(count) &#123;&#125;</span><br><span class="line">	<span class="keyword">virtual</span> <span class="keyword">void</span> ∗Entry(); 、</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line">	wxImage∗ m image; </span><br><span class="line">	<span class="keyword">int</span>∗ m count;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//一个标识符用来在线程工作完成的时候通知应用程序</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ID_COUNTED_COLORS_100</span></span><br></pre></td></tr></table></figure>
<p>Entry函数用来进行计算工作并且返回一个返回值(对于联合线程(即将介绍),Wait函数将返回这个值),下面是我们的Entry函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void ∗MyThread::Entry() &#123;</span><br><span class="line">(∗ m count) = m image−&gt;CountColours(); </span><br><span class="line">// . wxCommandEvent event(wxEVT COMMAND MENU SELECTED, ID COUNTED COLORS);</span><br><span class="line">wxGetApp().AddPendingEvent(event); return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WxWidgets图形化界面学习</category>
      </categories>
      <tags>
        <tag>图形界面</tag>
        <tag>WxWidgets</tag>
        <tag>GUI</tag>
        <tag>C++</tag>
        <tag>VisualStudio</tag>
      </tags>
  </entry>
  <entry>
    <title>东馆艺术课-色彩-1-开场</title>
    <url>/2020/01/29/%E4%B8%9C%E9%A6%86%E8%89%BA%E6%9C%AF%E8%AF%BE-%E8%89%B2%E5%BD%A9-1-%E5%BC%80%E5%9C%BA/</url>
    <content><![CDATA[<p><img src="/images/image-20200129145223137.png" alt="image-20200129145223137"></p>
<p>学院派和CG插画实际上并不一样，设计色彩有问题，去练习写生的话什么也解决不了，其目标完全不一样</p>
<a id="more"></a>
<h2 id="序幕-上"><a href="#序幕-上" class="headerlink" title="序幕(上)"></a>序幕(上)</h2><h3 id="色彩构成-过于抽象"><a href="#色彩构成-过于抽象" class="headerlink" title="色彩构成(过于抽象)"></a>色彩构成(过于抽象)</h3><p><img src="/images/image-20200129213648369.png" alt="image-20200129213648369"></p>
<h3 id="黑白"><a href="#黑白" class="headerlink" title="黑白"></a>黑白</h3><p><img src="/images/image-20200129213657806.png" alt="image-20200129213657806"></p>
<h3 id="加起来"><a href="#加起来" class="headerlink" title="加起来"></a>加起来</h3><p><img src="/images/image-20200129213722060.png" alt="image-20200129213722060"></p>
<p>色彩在创作领域地位比较靠后边，从观者角度比较靠前</p>
]]></content>
      <categories>
        <category>色彩</category>
      </categories>
      <tags>
        <tag>绘画</tag>
        <tag>色彩</tag>
        <tag>东馆艺术课</tag>
      </tags>
  </entry>
  <entry>
    <title>东馆方案学习笔记-2-素描-1几何-意义与调子</title>
    <url>/2020/01/29/%E4%B8%9C%E9%A6%86%E6%96%B9%E6%A1%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E7%B4%A0%E6%8F%8F-1%E5%87%A0%E4%BD%95-%E6%84%8F%E4%B9%89%E4%B8%8E%E8%B0%83%E5%AD%90/</url>
    <content><![CDATA[<h2 id="1-几何形体的意义"><a href="#1-几何形体的意义" class="headerlink" title="1.几何形体的意义"></a>1.几何形体的意义</h2><p>几何形体其实是一种思维方式，思考能力，有这种意识其实几何并不一定要练习</p>
<p><img src="/images/image-20200129144527247.png" alt="image-20200129144527247"></p>
<p>真正要思考的是如何<strong>把物体归纳为几何形体的能力</strong>，这才是练习几何形体的意义所在，其练习意义并不在于正方形和长方形的本身</p>
<a id="more"></a>
<p><img src="../images/image-20200131174918517.png" alt="image-20200131174918517"></p>
<p><img src="../images/image-20200131175314559.png" alt="image-20200131175314559"></p>
<h3 id="2-灰面"><a href="#2-灰面" class="headerlink" title="2.灰面"></a>2.灰面</h3><p>很厉害的画师会注重做灰面，真正处理好灰面才能最出效果</p>
<h3 id="3-五大调子"><a href="#3-五大调子" class="headerlink" title="3.五大调子"></a>3.五大调子</h3><p>(高光)，亮面，灰面，交界线，反光，阴影</p>
<p><img src="../images/image-20200131175552567.png" alt="image-20200131175552567"></p>
<h3 id="4-反光"><a href="#4-反光" class="headerlink" title="4.反光"></a>4.反光</h3><p>新手不建议去画反光，反光对于新手来说难以控制，而且对于画面来讲会跳出来</p>
<p><img src="../images/image-20200131175644157.png" alt="image-20200131175644157"><img src="../images/image-20200131175658892.png" alt="image-20200131175658892"></p>
<h2 id="2-光源"><a href="#2-光源" class="headerlink" title="2.光源"></a>2.光源</h2><p>科班教育一般不会提起光源，除非出现比较大的差错才会提起光源，因为一般来讲科班直接丢一张图临摹</p>
<p>但是凭空设计要有依据，这个依据就是光源</p>
<p><strong>如何贯彻光源是一个比较难的问题</strong></p>
<p>一个光源+一个正方体其面好画，一个光源+一万个正方体复合怎么画？</p>
<h3 id="光源的分类"><a href="#光源的分类" class="headerlink" title="光源的分类"></a>光源的分类</h3><p>(背)逆光:用来强调轮廓，侧光，顶光</p>
<p><strong>背光与勾轮廓</strong></p>
<p><img src="https://i.loli.net/2020/02/01/8nDQxbC2sIhE7yA.png" alt="image.png"></p>
<p>侧光-室内和人为光</p>
<p><img src="https://i.loli.net/2020/02/01/cVnsom7gC5Firxl.png" alt="image.png"></p>
<p>纯测光一般出现在室内的窗户 烛光</p>
<p>顶光:正顶光，侧顶光  45度之上的光，45度以下为正面光，会照到人脸</p>
<p><img src="https://i.loli.net/2020/02/01/iDSKt86MPgeZRsX.png" alt="AGA5`DL_J_FV`_NH7P70OUE.png"></p>
<p><img src="https://i.loli.net/2020/02/01/PxYeXIEkfaHRchA.png" alt="`@710CD27@_5OXP@_F7LLTU.png"></p>
<p>顶光-神秘感，庄严，一般不用</p>
<p>正顶光:详细表现一个角色，一般立绘用这种光，只画投影，韩系，说明性光源</p>
<p>顶光</p>
<p><img src="https://i.loli.net/2020/02/01/HFTYB1su6VUCNQx.png" alt="8VXFOJ_G_@_WWLGYA_5_E_D.png"></p>
<p>正顶光是绘画中一直使用的主光源，基础光源Basic Light</p>
<p><img src="https://i.loli.net/2020/02/01/rvKQbDzImCZk93N.png" alt="YIJSW7WE840JPZTH15WGI1I.png"></p>
<h2 id="3-人体"><a href="#3-人体" class="headerlink" title="3.人体"></a>3.人体</h2><p>几何+光源 合并除了圆柱体</p>
<p>人体上的所有东西基本都是用圆柱体合成的</p>
]]></content>
      <categories>
        <category>东馆方案</category>
      </categories>
      <tags>
        <tag>绘画</tag>
        <tag>素描</tag>
        <tag>几何</tag>
        <tag>光源</tag>
      </tags>
  </entry>
  <entry>
    <title>东馆方案学习笔记-1-春节训练任务-目录讲解</title>
    <url>/2020/01/29/%E4%B8%9C%E9%A6%86%E6%96%B9%E6%A1%88%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E6%98%A5%E8%8A%82%E8%AE%AD%E7%BB%83%E4%BB%BB%E5%8A%A1-%E7%9B%AE%E5%BD%95%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<p>白嫖的东西.目的是快速训练</p>
<h2 id="1-角色"><a href="#1-角色" class="headerlink" title="1.角色"></a>1.角色</h2><h3 id="1-1设计速写"><a href="#1-1设计速写" class="headerlink" title="1.1设计速写"></a>1.1设计速写</h3><p>在一个底模上照照片快速的画，先画个体型然后打上经纬线</p>
<p><img src="/images/image-20200129134234475.png" alt="image-20200129134234475"></p>
<p>跟着左边的角色快速的画出设计的大块，再画一点点细节</p>
<a id="more"></a>
<p><img src="/images/image-20200129134327277.png" alt="image-20200129134327277"><img src="/images/image-20200129134419300.png" alt="image-20200129134419300"></p>
<p><img src="/images/image-20200129134433772.png" alt="image-20200129134433772"><img src="/images/image-20200129134537492.png" alt="image-20200129134537492"></p>
<p>目的是为了之后画的角色积累感觉，画的时候不会那么受限</p>
<h3 id="1-2-设计色彩"><a href="#1-2-设计色彩" class="headerlink" title="1.2 设计色彩"></a>1.2 设计色彩</h3><p>第一步设计速写得到的线稿就可以拿来用练习了，只不过多了基本的投影</p>
<p><img src="/images/image-20200129134709459.png" alt="image-20200129134709459"></p>
<p>根据左边的参考快速调色</p>
<p><img src="/images/image-20200129134959544.png" alt="image-20200129134959544"></p>
<h3 id="1-3-临摹"><a href="#1-3-临摹" class="headerlink" title="1.3 临摹"></a>1.3 临摹</h3><h4 id="a-临完成度高的-带塑造"><a href="#a-临完成度高的-带塑造" class="headerlink" title="a.临完成度高的(带塑造)"></a>a.临完成度高的(带塑造)</h4><p>高清画面的局部</p>
<p><img src="/images/image-20200129135115882.png" alt="image-20200129135115882"></p>
<p>高强度的塑造可以不需要做整张的而只做局部的临摹</p>
<h4 id="b方案-非塑造出来的完成度"><a href="#b方案-非塑造出来的完成度" class="headerlink" title="b方案:非塑造出来的完成度"></a>b方案:非塑造出来的完成度</h4><p>例如剑与远征的插图</p>
<p><img src="/images/image-20200129135343170.png" alt="image-20200129135343170"></p>
<p><img src="/images/image-20200129135400242.png" alt="image-20200129135400242"></p>
<p>美术风格所流行的画风可能会带动一系列的游戏风格，美国卡通</p>
<h2 id="2-素描"><a href="#2-素描" class="headerlink" title="2.素描"></a>2.素描</h2><p><img src="/images/image-20200129135759936.png" alt="image-20200129135759936"></p>
<p>素描如何应用</p>
<h2 id="3-插画"><a href="#3-插画" class="headerlink" title="3.插画"></a>3.插画</h2><h3 id="1-气氛草图"><a href="#1-气氛草图" class="headerlink" title="1.气氛草图"></a>1.气氛草图</h3><p><img src="/images/image-20200129135839864.png" alt="image-20200129135839864"></p>
<p>黑白配色，透视，比例，构图方案</p>
<p><img src="/images/image-20200129135908847.png" alt="image-20200129135908847"></p>
<h3 id="2-角色穿装"><a href="#2-角色穿装" class="headerlink" title="2.角色穿装"></a>2.角色穿装</h3><p><img src="/images/image-20200129140107625.png" alt="image-20200129140107625"></p>
<h3 id="3-临摹"><a href="#3-临摹" class="headerlink" title="3.临摹"></a>3.临摹</h3><p>见插画局部临摹</p>
<h2 id="4-场景"><a href="#4-场景" class="headerlink" title="4.场景"></a>4.场景</h2><h3 id="1-黑白速涂"><a href="#1-黑白速涂" class="headerlink" title="1.黑白速涂"></a>1.黑白速涂</h3><p><img src="/images/image-20200129140432309.png" alt="image-20200129140432309"></p>
<p><img src="/images/image-20200129140445060.png" alt="image-20200129140445060"></p>
<p><img src="/images/image-20200129140459613.png" alt="image-20200129140459613"></p>
<p><img src="/images/image-20200129140514044.png" alt="image-20200129140514044"></p>
<p><img src="/images/image-20200129140527131.png" alt="image-20200129140527131"></p>
<p><img src="/images/image-20200129140540043.png" alt="image-20200129140540043"></p>
<p><img src="/images/image-20200129140554622.png" alt="image-20200129140554622"></p>
<h3 id="2-线稿训练"><a href="#2-线稿训练" class="headerlink" title="2.线稿训练"></a>2.线稿训练</h3><p>追求手感，训练组织画面的能力</p>
<p><img src="/images/image-20200129140948563.png" alt="image-20200129140948563"></p>
<p><img src="/images/image-20200129140958469.png" alt="image-20200129140958469"></p>
<p><img src="/images/image-20200129141009370.png" alt="image-20200129141009370"></p>
<p><img src="/images/image-20200129141018270.png" alt="image-20200129141018270"></p>
<p><img src="/images/image-20200129141028051.png" alt="image-20200129141028051"></p>
<p><img src="/images/image-20200129141058170.png" alt="image-20200129141058170"></p>
<p><img src="/images/image-20200129141129858.png" alt="image-20200129141129858"></p>
<p><img src="/images/image-20200129141141090.png" alt="image-20200129141141090"></p>
<p><img src="/images/image-20200129141149834.png" alt="image-20200129141149834"></p>
<p><img src="/images/image-20200129141159408.png" alt="image-20200129141159408"></p>
<p><img src="/images/image-20200129141211210.png" alt="image-20200129141211210"></p>
<p><img src="/images/image-20200129141236633.png" alt="image-20200129141236633"></p>
<p><img src="/images/image-20200129141307504.png" alt="image-20200129141307504"></p>
<p><img src="/images/image-20200129141321562.png" alt="image-20200129141321562"></p>
<p><img src="/images/image-20200129141331081.png" alt="image-20200129141331081"></p>
<p><img src="/images/image-20200129141436034.png" alt="image-20200129141436034"></p>
<p>传统绘画并没有用训练透视的，临摹的准透视的问题基本解决</p>
<p><img src="/images/image-20200129141511905.png" alt="image-20200129141511905"></p>
<p><img src="/images/image-20200129141531367.png" alt="image-20200129141531367"></p>
<h3 id="3-黑白单体速途"><a href="#3-黑白单体速途" class="headerlink" title="3.黑白单体速途"></a>3.黑白单体速途</h3><p><img src="/images/image-20200129141609089.png" alt="image-20200129141609089"></p>
<p><img src="/images/image-20200129141621329.png" alt="image-20200129141621329"></p>
<p><img src="/images/image-20200129141643032.png" alt="image-20200129141643032"></p>
<p><img src="/images/image-20200129141652049.png" alt="image-20200129141652049"></p>
<p><img src="/images/image-20200129141701296.png" alt="image-20200129141701296"></p>
<p><img src="/images/image-20200129141709176.png" alt="image-20200129141709176"></p>
<p><img src="/images/image-20200129141718345.png" alt="image-20200129141718345"></p>
<p><img src="/images/image-20200129141735336.png" alt="image-20200129141735336"></p>
<p>载具建议可以喵</p>
<p><img src="/images/image-20200129141755560.png" alt="image-20200129141755560"></p>
<p><img src="/images/image-20200129141804239.png" alt="image-20200129141804239"></p>
<p><img src="/images/image-20200129141814328.png" alt="image-20200129141814328"></p>
<p><img src="/images/image-20200129141831593.png" alt="image-20200129141831593"></p>
<p><img src="/images/image-20200129141841543.png" alt="image-20200129141841543"></p>
<p><img src="/images/image-20200129141912264.png" alt="image-20200129141912264"></p>
<p><img src="/images/image-20200129141930928.png" alt="image-20200129141930928"></p>
<p><img src="/images/image-20200129141958014.png" alt="image-20200129141958014"></p>
<p><img src="/images/image-20200129142011031.png" alt="image-20200129142011031"></p>
<h4 id="载具步骤"><a href="#载具步骤" class="headerlink" title="载具步骤"></a>载具步骤</h4><h5 id="1-线稿"><a href="#1-线稿" class="headerlink" title="1.线稿"></a>1.线稿</h5><p><img src="/images/image-20200129142058547.png" alt="image-20200129142058547"></p>
<h5 id="2-闭塞"><a href="#2-闭塞" class="headerlink" title="2.闭塞"></a>2.闭塞</h5><p><img src="/images/image-20200129142130453.png" alt="image-20200129142130453"></p>
<h5 id="3-基本素面灰面"><a href="#3-基本素面灰面" class="headerlink" title="3.基本素面灰面"></a>3.基本素面灰面</h5><p><img src="/images/image-20200129142204574.png" alt="image-20200129142204574"></p>
<h5 id="4-细节"><a href="#4-细节" class="headerlink" title="4.细节"></a>4.细节</h5><p><img src="/images/image-20200129142243047.png" alt="image-20200129142243047"></p>
<h5 id="5-注意图层的拜访顺序"><a href="#5-注意图层的拜访顺序" class="headerlink" title="5.注意图层的拜访顺序"></a>5.注意图层的拜访顺序</h5><p><img src="/images/image-20200129142307621.png" alt="image-20200129142307621"></p>
<h4 id="建筑步骤"><a href="#建筑步骤" class="headerlink" title="建筑步骤"></a>建筑步骤</h4><h5 id="1-草稿"><a href="#1-草稿" class="headerlink" title="1.草稿"></a>1.草稿</h5><p><img src="/images/image-20200129142417751.png" alt="image-20200129142417751"></p>
<h5 id="2-闭塞-1"><a href="#2-闭塞-1" class="headerlink" title="2.闭塞"></a>2.闭塞</h5><p><img src="/images/image-20200129142453116.png" alt="image-20200129142453116"></p>
<h5 id="3-体积灰面"><a href="#3-体积灰面" class="headerlink" title="3.体积灰面"></a>3.体积灰面</h5><p><img src="/images/image-20200129142516814.png" alt="image-20200129142516814"></p>
<h3 id="4-色彩速途-我感觉最有意思的"><a href="#4-色彩速途-我感觉最有意思的" class="headerlink" title="4.色彩速途(我感觉最有意思的)"></a>4.色彩速途(我感觉最有意思的)</h3><p><img src="/images/image-20200129142634854.png" alt="image-20200129142634854"></p>
<p>TipS:两个面去表现物体，保持边缘，里边选取笔刷细节随便，思考空间</p>
<p><img src="/images/image-20200129142754333.png" alt="image-20200129142754333"></p>
<p>速度类的训练，画幅小一点，控制边缘</p>
<h3 id="5-临摹"><a href="#5-临摹" class="headerlink" title="5.临摹"></a>5.临摹</h3><p>1.</p>
<p><img src="/images/image-20200129143104258.png" alt="image-20200129143104258"></p>
<p>思考光源的渐变，这一块属于光源的反光或者哪里</p>
<p><img src="/images/image-20200129143305461.png" alt="image-20200129143305461"></p>
<p>一块一块的清</p>
<p><img src="/images/image-20200129143352298.png" alt="image-20200129143352298"></p>
<p>画幅只摆到这里</p>
<p><img src="/images/image-20200129143416271.png" alt="image-20200129143416271"></p>
<p>1/10的画 1幅画画10次</p>
<p>固有色按面积选</p>
]]></content>
      <categories>
        <category>东馆方案</category>
      </categories>
      <tags>
        <tag>绘画</tag>
      </tags>
  </entry>
  <entry>
    <title>Krenz透视课作业汇总</title>
    <url>/2020/01/28/Krenz%E9%80%8F%E8%A7%86%E8%AF%BE%E7%AC%94%E8%AE%B0-1/</url>
    <content><![CDATA[<p>​    之前就喜欢胡思乱写一些东西，记笔记也是常态，从大四开始因为要准备考研就没有摸过画板了，之后放假半年再摸起画笔找状态说实话也费了不少时间，而且在K大那里学的东西基本忘的差不多了，又看到家里的旧电脑上残留有之前上透视课的画作业，还有聊天记录和一些自己无聊的时候思考的笔记，想了想就整理在这里，再抄一下K大微博发的课堂笔记和同学的心得再过一遍，也算是重新学习了一遍。</p>
<h2 id="第一堂-房子临摹-透视比例与结构-perspective-proportion-and-structure"><a href="#第一堂-房子临摹-透视比例与结构-perspective-proportion-and-structure" class="headerlink" title="第一堂:房子临摹(透视比例与结构) perspective, proportion and structure"></a>第一堂:房子临摹(透视比例与结构) perspective, proportion and structure</h2><h3 id="作业1-临摹"><a href="#作业1-临摹" class="headerlink" title="作业1:临摹"></a>作业1:临摹</h3><p><img src="/images/image-20200128223330037.png" alt="image-20200128223330037"></p>
<a id="more"></a>
<h3 id="作业2-转角度"><a href="#作业2-转角度" class="headerlink" title="作业2:转角度"></a>作业2:转角度</h3><p><img src="/images/image-20200128223344971.png" alt="image-20200128223344971"></p>
<h3 id="作业提示"><a href="#作业提示" class="headerlink" title="作业提示"></a>作业提示</h3><p><img src="/images/image-20200128223438447.png" alt="image-20200128223438447"></p>
<p>有句话叫做什么来着，眼高手低，不做这作业还以为自己很厉害，等到自己画的时候那个苦头吃的真心难受。</p>
<p>实际执行起来才深刻理解什么叫做真正的眼高手低，不过认识到也是后话了，当时啊，是第一次接触绘画，纯小白，非常</p>
<p>纯那种，作业留完大部分时间倒不是在画作业，而是摸索软件…后来有了意识就能分辨小白和有经验的人就是看线条，当</p>
<p>时也没啥注意事项之类的</p>
<p><img src="/images/image-20200128223916982.png" alt="image-20200128223916982"></p>
<p><img src="/images/image-20200128223929540.png" alt="image-20200128223929540"></p>
<p><img src="/images/image-20200128223949965.png" alt="image-20200128223949965"></p>
<p><img src="/images/image-20200128224005785.png" alt="image-20200128224005785"></p>
<h3 id="合格作业模范"><a href="#合格作业模范" class="headerlink" title="合格作业模范:"></a>合格作业模范:</h3><p><img src="/images/image-20200128224031926.png" alt="image-20200128224031926"></p>
<p>图片来自K大透视课的L1基础作业汇总说明，</p>
<h2 id="第二堂-简单室内场景-大熊与哆啦A梦"><a href="#第二堂-简单室内场景-大熊与哆啦A梦" class="headerlink" title="第二堂:简单室内场景 -大熊与哆啦A梦"></a>第二堂:简单室内场景 -大熊与哆啦A梦</h2><p><img src="/images/TouShi/HomeWork/Krenz-透视L2基础作业汇总说明.jpg" alt=""></p>
<h2 id="第三堂-简单室外场景与椅子-四叶妹妹"><a href="#第三堂-简单室外场景与椅子-四叶妹妹" class="headerlink" title="第三堂:简单室外场景与椅子-四叶妹妹"></a>第三堂:简单室外场景与椅子-四叶妹妹</h2><p> <img src="/images/TouShi/HomeWork/Krenz-透视L3基础作业汇总说明.jpg" alt=""></p>
<h2 id="第四堂-城镇场景"><a href="#第四堂-城镇场景" class="headerlink" title="第四堂:城镇场景"></a>第四堂:城镇场景</h2><p><img src="/images/TouShi/HomeWork/Krenz-透视L4基础作业汇总说明.jpg" alt=""></p>
<h2 id="第五堂-鞋子-学生鞋（各个角度与变形"><a href="#第五堂-鞋子-学生鞋（各个角度与变形" class="headerlink" title="第五堂:鞋子-学生鞋（各个角度与变形"></a>第五堂:鞋子-学生鞋（各个角度与变形</h2><p><img src="/images/TouShi/HomeWork/Krenz-透视L5基础作业汇总说明.jpg" alt=""></p>
<h2 id="第六堂-Q版人物-林克（各个角度"><a href="#第六堂-Q版人物-林克（各个角度" class="headerlink" title="第六堂:Q版人物-林克（各个角度"></a>第六堂:Q版人物-林克（各个角度</h2><p><img src="/images/TouShi/HomeWork/Krenz-透视L6基础作业汇总说明.jpg" alt=""></p>
<h2 id="第七堂-16格（用正方体画各种简单物体的各个角度"><a href="#第七堂-16格（用正方体画各种简单物体的各个角度" class="headerlink" title="第七堂:16格（用正方体画各种简单物体的各个角度"></a>第七堂:16格（用正方体画各种简单物体的各个角度</h2><p><img src="/images/TouShi/HomeWork/Krenz-透视L7基础作业汇总说明.jpg" alt=""></p>
<h2 id="第八堂-带景人物"><a href="#第八堂-带景人物" class="headerlink" title="第八堂:带景人物"></a>第八堂:带景人物</h2><p><img src="/images/TouShi/HomeWork/Krenz-透视L8基础作业汇总说明.jpg" alt=""></p>
<h2 id="DLC作业"><a href="#DLC作业" class="headerlink" title="DLC作业"></a>DLC作业</h2><h3 id="1-钢弹车"><a href="#1-钢弹车" class="headerlink" title="1.钢弹车"></a>1.钢弹车</h3><p><img src="/images/TouShi/DLC/钢弹车.jpg" alt=""></p>
]]></content>
      <categories>
        <category>透视课</category>
      </categories>
      <tags>
        <tag>透视课</tag>
        <tag>Krenz</tag>
        <tag>DLC</tag>
        <tag>homework</tag>
      </tags>
  </entry>
  <entry>
    <title>读书札记-1-言语</title>
    <url>/2020/01/28/%E8%AF%BB%E4%B9%A6%E6%9C%AD%E8%AE%B0-1-%E8%A8%80%E8%AF%AD/</url>
    <content><![CDATA[<p>​    说来奇怪，今天翻到了高中时候的读书笔记，自从上了大学倒没有记笔记的习惯了，这里暂且写一下占个地方也好，就当回忆一下黑历史了(笑)。</p>
<h2 id="1-谈小说的作用"><a href="#1-谈小说的作用" class="headerlink" title="1.谈小说的作用"></a>1.谈小说的作用</h2><blockquote>
<p>六经不能教，当以小说教之；正史不能入，当以小说入之。</p>
<p>语录不能渝，当以小说渝之；律例不能活，当以小说活之。</p>
</blockquote>
<p>​                                                                                                                                          ——(小说的作用，市民文学现状)</p>
]]></content>
      <categories>
        <category>读书札记</category>
      </categories>
      <tags>
        <tag>读书札记</tag>
      </tags>
  </entry>
  <entry>
    <title>WxWidgets学习笔记-2-应用程序类WxAPP和Frame窗口类学习</title>
    <url>/2020/01/28/WxWidgets%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BBWxAPP%E5%92%8CFrame%E7%AA%97%E5%8F%A3%E7%B1%BB%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h2 id="1-WxApp"><a href="#1-WxApp" class="headerlink" title="1.WxApp"></a>1.WxApp</h2><p>每一个wxWidgets程序都需要定义一个wxApp类的子类,并且<strong>需要创建并且只能创建一个</strong>这个类的实例,</p>
<p>实例控制着整个程序的执行,这个继承自wxApp的子类至少需要定义一个<strong>OnInit</strong>函数,</p>
<p>当运行代码的时候,将会调用这个函数(和一个典型的Win32程序中的main函数或者WinMain函数类似)。</p>
<h3 id="1-wxApp类"><a href="#1-wxApp类" class="headerlink" title="1.wxApp类"></a>1.wxApp类</h3><p>定义这个子类及其OnInit函数的代码如下所示:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> :</span> <span class="keyword">public</span> wxApp</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">OnInit</span><span class="params">()</span></span>;<span class="comment">//相当于Main函数 函数入口</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个Onlnit函数中,通常应该作的事情包括:</p>
<a id="more"></a>
<p>创建至少一个窗口实例(实例是C++中的关键词),对传入的命令行参数进行解析,为应用程序进行数据设置和其它的一些初始化的操作</p>
<p>如果这个函数返回真, wxWidgets将开始事件循环用来接收用户输入并且在必要的情况下处理这些输入。</p>
<p>如果OnInit函数返回假, wxWidgets将会释放它内部已经分配的资源,然后结束整个程序的运行。</p>
<h3 id="2-OnInit函数的实现"><a href="#2-OnInit函数的实现" class="headerlink" title="2.OnInit函数的实现"></a>2.OnInit函数的实现</h3><p>看一个最简单的OnInit函数的实现:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> MyApp::OnInit()</span><br><span class="line">&#123;</span><br><span class="line">    MyFrame* frame = <span class="keyword">new</span> MyFrame(wxT(”Minimal wxWidgets App”)); <span class="comment">//实例化一个Frame</span></span><br><span class="line">    frame-&gt;Show(<span class="literal">true</span>);<span class="comment">//展示一个Frame</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-wXT宏"><a href="#3-wXT宏" class="headerlink" title="3.wXT宏"></a>3.wXT宏</h3><p>wxT这个宏,在接下来的例子中,这个宏还会被频繁用到。</p>
<p>它的作用是让你的代码兼容Unicode模式。这个宏和另外一个T宏的作用是完全一样的。</p>
<p>使用这个宏也不会带来运行期的性能损失。</p>
<p>可能还会遇到另外一个类似的”-()”标记,这个是用来告诉wxWidgets将其中的字符串翻译成指定语言的版本</p>
<hr>
<h3 id="4-IMPLEMENT-APP宏"><a href="#4-IMPLEMENT-APP宏" class="headerlink" title="4.IMPLEMENT_APP宏"></a>4.IMPLEMENT_APP宏</h3><p>那么创建MyApp的实例的代码在哪里呢?</p>
<p>实际上,这是在wxWidgets内部实现的,不过你仍然需要告诉wxWidgets需要创建哪一个App类的实例,所以你还需要增加下面的一个宏:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">wxIMPLEMENT_APP(MyApp);</span><br></pre></td></tr></table></figure>
<p>如果没有实现这个类, wxWidgets就不知道怎样创建一个新的应用程序对象。</p>
<p>这个宏除了上述的功能以外,还会检查编译应用程序使用的库文件是否和当前的库文件相匹配(前面我们已经介绍了,你可以编译多个配置文件的wxWidgets库文件),如果没有这种检查,由此而产生的一些运行期的错误将很难被定位出原因。</p>
<h3 id="5-DECLARE-APP-MyAPP-宏"><a href="#5-DECLARE-APP-MyAPP-宏" class="headerlink" title="5.DECLARE_APP(MyAPP)宏"></a>5.DECLARE_APP(MyAPP)宏</h3><p>当wxWidgets创建这个MyApp类的实例的时候,会将创建的结果赋值给一个全局变量wxTheApp.</p>
<p>你当然可以在你的程序中使用这个变量,但是你可能不得不一遍又一遍的进行从wxApp到MyApp的类型强制转换。</p>
<p>增加下面的这一行声明以后,你就可以调用wxGetApp()函数,这个函数会返回一个到这个MyApp实例的引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DECLARE_APP(MyApp)</span><br></pre></td></tr></table></figure>
<h3 id="5-一点提示"><a href="#5-一点提示" class="headerlink" title="5.一点提示"></a>5.一点提示</h3><blockquote>
<p>即使没有声明DECLARE-APP,你仍然可以不用进行类型强制转化就直接对wxTheApp变量调用wxApp(注意,不是MyApp而是wxApp,它是MyApp的基类的方法,这可以避免在所有的头文件中包含MyApp的头文件,这对于那些库中的代码(而不是应用程序的代码)来说也更有意义,而且还可以缩短编译的时间。</p>
</blockquote>
<h2 id="2-WxFrame"><a href="#2-WxFrame" class="headerlink" title="2.WxFrame"></a>2.WxFrame</h2><p>一个Frame窗口是一个可以容纳别的窗口的顶层窗口,通常拥有一个标题栏和一个菜单栏。Frame类的定义可以放在MyApp类后。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span> :</span> <span class="keyword">public</span> wxFrame</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyFrame();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnExit</span><span class="params">(wxCommandEvent&amp; event)</span></span>;<span class="comment">//退出事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnAbout</span><span class="params">(wxCommandEvent&amp; event)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个窗口类有一个<strong>构造函数</strong>和两个用来把菜单命令和C++代码相连的<strong>事件处理函数</strong></p>
<h2 id="3-事件处理函数"><a href="#3-事件处理函数" class="headerlink" title="3.事件处理函数"></a>3.事件处理函数</h2><h3 id="1-时间表EVENT-TABLE"><a href="#1-时间表EVENT-TABLE" class="headerlink" title="1.时间表EVENT TABLE"></a>1.时间表EVENT TABLE</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BEGIN EVENT <span class="title">TABLE</span><span class="params">(MyFrame, wxFrame)</span> </span></span><br><span class="line"><span class="function">	EVT <span class="title">MENU</span><span class="params">(wxID_ABOUT, MyFrame::OnAbout)</span> </span></span><br><span class="line"><span class="function">	EVT <span class="title">MENU</span><span class="params">(wxID_EXIT, MyFrame::OnQuit)</span></span></span><br><span class="line"><span class="function">END EVENT <span class="title">TABLE</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>​            所谓事件表,是一组位于类的实现文件(.cpp文件)中的宏,用来告诉wxWidgets来自用户或者其它地方的事件应该怎样和类的成员函数对应起来。</p>
<p>​            前面展示的事件表表明,要把标识符分别为wxID_EXITwxID_ABOUT的菜单事件和MyFrame的成员函数OnAbout和OnQuit关联起来。这里的EVTMENU宏只是很多中事件宏中的一个,事件宏的作用是告诉wxWidgets哪种事件应该被关联到哪个成员函数。</p>
<p>​            这里的两个标识wxID_ABOUT和wxID_EXIT是wxWidgets预定义的宏,通常应该通过枚举,常量或者宏定义的方式定义你自己的标识符，下边是一个例子。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">   Menu_File_Quit = <span class="number">100</span>,<span class="comment">//窗口退出ID=100 </span></span><br><span class="line">   Menu_File_Open,<span class="comment">//打开ID=101</span></span><br><span class="line">   Menu_File_Save,<span class="comment">//保存102</span></span><br><span class="line"></span><br><span class="line">   Menu_Render_Start,<span class="comment">//渲染开始103</span></span><br><span class="line">   Menu_Render_Pause,<span class="comment">//停止104</span></span><br><span class="line">   Menu_Render_Resume<span class="comment">//重新开始105</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//事件表 类和基类</span></span><br><span class="line">BEGIN_EVENT_TABLE( wxraytracerFrame, wxFrame )</span><br><span class="line">   EVT_MENU( Menu_Render_Start, wxraytracerFrame::OnRenderStart )</span><br><span class="line">   EVT_MENU( Menu_Render_Pause, wxraytracerFrame::OnRenderPause )</span><br><span class="line">   EVT_MENU( Menu_Render_Resume, wxraytracerFrame::OnRenderResume )</span><br><span class="line">   EVT_MENU( Menu_File_Save, wxraytracerFrame::OnSaveFile )</span><br><span class="line">   EVT_MENU( Menu_File_Open, wxraytracerFrame::OnOpenFile )</span><br><span class="line">   EVT_MENU( Menu_File_Quit, wxraytracerFrame::OnQuit )</span><br><span class="line">   EVT_COMMAND(ID_RENDER_COMPLETED, wxEVT_RENDER,</span><br><span class="line">                     wxraytracerFrame::OnRenderCompleted)</span><br><span class="line">END_EVENT_TABLE()</span><br></pre></td></tr></table></figure>
<p>​    用上面的方法定义的事件表是一种静态的事件表,不可以在运行期改变。</p>
<h3 id="2-OnAbout和OnQuit函数"><a href="#2-OnAbout和OnQuit函数" class="headerlink" title="2.OnAbout和OnQuit函数"></a>2.OnAbout和OnQuit函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> MyFrame::OnAbout(wxCommandEvent&amp; event)</span><br><span class="line">&#123;</span><br><span class="line">	wxString msg; </span><br><span class="line">    msg.Printf(wxT(”Hello <span class="keyword">and</span> welcome to %s”), wxVERSION STRING);</span><br><span class="line">	wxMessageBox(msg, wxT(”About Minimal”), wxOK | wxICON INFORMATION, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> MyFrame::OnQuit(wxCommandEvent&amp; event) </span><br><span class="line">&#123;</span><br><span class="line">	Close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当用户点击关于菜单项的时候, MyFrame:OnAbout函数弹出一个消息框。这用到了wxWidgets提供的API wxMessageBox,它的四个参数分别代表消息内容,标题,窗口类型以及父窗口。</p>
<h3 id="3-wxMessageBox消息框"><a href="#3-wxMessageBox消息框" class="headerlink" title="3.wxMessageBox消息框"></a>3.wxMessageBox消息框</h3><h5 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范:"></a>使用规范:</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">wxMessageBox(msg, wxT(”About Minimal”), wxOK | wxICON INFORMATION, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<h5 id="解释"><a href="#解释" class="headerlink" title="解释:"></a>解释:</h5><table>
<thead>
<tr>
<th>wxMessageBox</th>
<th>内容</th>
<th>标题</th>
<th>窗口类型</th>
<th>父窗口</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>msg</td>
<td>wxT(”About Minimal”)</td>
<td>wxOK wxICON INFORMATION</td>
<td>this</td>
</tr>
</tbody>
</table>
<h3 id="4-OnQuit的解释"><a href="#4-OnQuit的解释" class="headerlink" title="4.OnQuit的解释"></a>4.OnQuit的解释</h3><p>​        当用户点击退出菜单项的时候, MyFrame:OnQuit函数被调用(你已经意识到了,这是事件表的功劳) 。它调用wxFrame类的Close函数来释放frame窗口。因为没有别的窗口存在了,所以就触发了应用程序的退出,</p>
<p>​        实际上, wxFrame类的Close函数并不直接关闭frame窗口,而是产生一个wxEVTCLOSE-WINDOW事件,这个事件默认的处理函数调用wxWindow:: Destroy函数释放了frame窗口。</p>
<p>​        用户还可以通过别的方法关掉应用程序,比如通过点击标题栏上的关闭按钮或者是通过系统菜单中的关闭菜单,在这种情况下, OnQuit函数是怎样被调用的呢?事实上,在这种情况, OnQuit函数并没有被调用。这时, wxWidgets会通过Close函数 (象OnQuit中的那样) ,给frame窗口发送一个wxEVTCLOSEWINDOW事件,这个事件默认的处理函数会释放掉frame窗口。</p>
<p>​        在你的应用程序中,可以通过拦截这个事件来改变这种默认的行为,比如有时候,你可能想问一问你的用户是不是真的要这样做.</p>
<p>​        另外,大多数的应用程序类还应该重载(重载是C++的关键词)一个OnExit函数,以便在任何时候程序退出时,执行清理和资源回收的动作。需要注意的是,这个函数只有在Onlnit函数返回真的时候才会被执行。当然,在我们这个小例子中就用不着定义这个函数了。</p>
<h2 id="4-Frame构造函数"><a href="#4-Frame构造函数" class="headerlink" title="4.Frame构造函数"></a>4.Frame构造函数</h2><p>最后,让我们来看看Frame窗口的构造函数,正是它实现了frame窗口的图标,菜单栏和状态条</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> ”mondrian.xpm” </span></span><br><span class="line">MyFrame::MyFrame(<span class="keyword">const</span> wxString&amp; title) </span><br><span class="line">	: wxFrame(<span class="literal">NULL</span>, wxID ANY, title)<span class="comment">//表1</span></span><br><span class="line">&#123;</span><br><span class="line">	SetIcon(wxIcon(mondrian xpm)); </span><br><span class="line">        </span><br><span class="line">	wxMenu ∗fileMenu = <span class="keyword">new</span> wxMenu; </span><br><span class="line">	wxMenu ∗helpMenu = <span class="keyword">new</span> wxMenu; </span><br><span class="line">		helpMenu−&gt;Append(wxID_ABOUT, wxT(”&amp;About...\tF1”), wxT(”Show about dialog”));</span><br><span class="line">		fileMenu−&gt;Append(wxID_EXIT, wxT(”E&amp;xit\tAlt−X”), wxT(”Quit <span class="keyword">this</span> program”));</span><br><span class="line">        </span><br><span class="line">	wxMenuBar ∗menuBar = <span class="keyword">new</span> wxMenuBar(); </span><br><span class="line">        menuBar−&gt;Append(fileMenu, wxT(”&amp;File”)); </span><br><span class="line">        menuBar−&gt;Append(helpMenu, wxT(”&amp;Help”)); </span><br><span class="line">        SetMenuBar(menuBar); </span><br><span class="line">        CreateStatusBar(<span class="number">2</span>); </span><br><span class="line">        SetStatusText(wxT(”Welcome to wxWidgets!”));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-MyFrame构造函数"><a href="#1-MyFrame构造函数" class="headerlink" title="1.MyFrame构造函数"></a>1.MyFrame构造函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">MyFrame::MyFrame(<span class="keyword">const</span> wxString&amp; title) </span><br><span class="line">	: wxFrame(<span class="literal">NULL</span>, wxID ANY, title)</span><br></pre></td></tr></table></figure>
<p>​    这个构造函数首先调用它的基类(wxFrame)的构造函数,使用的参数是父窗口(还没有父窗口,所以用NULL),窗口标识(wxIDANY标识让wxWidgets自己选择一个)和标题。这个基类的构造函数才真正创建了一个窗口的实例。</p>
<p>除了这样的调用方法,还有另外一种方法是直接在构造函数里面显式调用基类默认的构造函数(就是指不带任何参数的构造函数),然后调用wxFrame:Create函数来创建一个frame窗口的实例。</p>
<h3 id="2-SetIcon-图标设置"><a href="#2-SetIcon-图标设置" class="headerlink" title="2.SetIcon() 图标设置"></a>2.SetIcon() 图标设置</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SetIcon(wxIcon(mondrian xpm));</span><br></pre></td></tr></table></figure>
<p>小图片或者是图标在所有的平台上都可以用XPM格式来表示。XPM文件其实是一个ASCI编码的完全符合C++语法的文本文件,所以可以直接用C++的方式包含到代码中,然后将这个图标和frame窗口关联。</p>
<h2 id="5-WxMenu菜单栏和wxMenuBar菜单条"><a href="#5-WxMenu菜单栏和wxMenuBar菜单条" class="headerlink" title="5.WxMenu菜单栏和wxMenuBar菜单条"></a>5.WxMenu菜单栏和wxMenuBar菜单条</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">wxMenu ∗fileMenu = <span class="keyword">new</span> wxMenu; </span><br><span class="line">wxMenu ∗helpMenu = <span class="keyword">new</span> wxMenu; </span><br><span class="line">	helpMenu−&gt;Append(wxID_ABOUT, wxT(”&amp;About...\tF1”), wxT(”Show about dialog”));</span><br><span class="line">	fileMenu−&gt;Append(wxID_EXIT, wxT(”E&amp;xit\tAlt−X”), wxT(”Quit <span class="keyword">this</span> program”));</span><br><span class="line">       <span class="comment">//全局快捷键Alt−X</span></span><br><span class="line">wxMenuBar ∗menuBar = <span class="keyword">new</span> wxMenuBar(); <span class="comment">//菜单栏</span></span><br><span class="line">       menuBar−&gt;Append(fileMenu, wxT(”&amp;File”)); </span><br><span class="line">       menuBar−&gt;Append(helpMenu, wxT(”&amp;Help”)); </span><br><span class="line">       SetMenuBar(menuBar); </span><br><span class="line">       CreateStatusBar(<span class="number">2</span>); </span><br><span class="line">       SetStatusText(wxT(”Welcome to wxWidgets!”));</span><br></pre></td></tr></table></figure>
<p>​    接下来创建了菜单条。增加菜单项的Append函数的三个参数的意义分别为:菜单项标识,菜单上的文本以及一个稍微长一些的帮助字符串。这个帮助字符串会自动在菜单项被高亮显示的时候自动显示在状态栏上。菜单上的文本中由”&amp;”符号前导的字符将成为菜单的快捷操作符,在实际的显示中用下划线表示。而”\t”符号则前导一个全局的快捷键,这个快捷键可以在菜单项没有被打开的时候触发菜单功能。</p>
<p>​    这个构造函数所做的最后一件事是创建一个由两个区域组成的状态条并且在状态条的第一个区域写上欢迎的字样。</p>
<p>表1</p>
<table>
<thead>
<tr>
<th>wxFrame初始化声明</th>
<th>NULL</th>
<th>wxID ANY</th>
<th>title</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>父窗口NULL</td>
<td>窗口标识wxID_ANY让wxWidgets自己选择一个</td>
<td>标题</td>
</tr>
</tbody>
</table>
<p>表2</p>
<h3 id="1-Append"><a href="#1-Append" class="headerlink" title="1.Append()"></a>1.Append()</h3><h4 id="wxMenu使用规范"><a href="#wxMenu使用规范" class="headerlink" title="wxMenu使用规范:"></a>wxMenu使用规范:</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">wxMenu−&gt;Append(wxID_ABOUT(标识ID), wxT(”&amp;显示的名字...\t快捷键”), wxT(”帮助字符串”));</span><br></pre></td></tr></table></figure>
<h5 id="wxMenuBar使用规范"><a href="#wxMenuBar使用规范" class="headerlink" title="wxMenuBar使用规范:"></a>wxMenuBar使用规范:</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wxMenuBar ∗menuBar = new wxMenuBar(); //声明菜单栏</span><br><span class="line">menuBar−&gt;Append(wxMenu, wxT(”&amp;File”));</span><br></pre></td></tr></table></figure>
<p>wxMenu与wxMenuBar的附加函数</p>
<table>
<thead>
<tr>
<th>Append</th>
<th>菜单项标识</th>
<th>菜单上的文本</th>
<th>帮助字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>wxID_ABOUT</td>
<td>wxT(”&amp;About…\tF1”)</td>
<td>wxT(”Show about dialog”)</td>
</tr>
</tbody>
</table>
<h2 id="6-全部代码"><a href="#6-全部代码" class="headerlink" title="6.全部代码"></a>6.全部代码</h2><h3 id="main-h"><a href="#main-h" class="headerlink" title="main.h"></a>main.h</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Name: minimal.cpp</span></span><br><span class="line"><span class="comment">// Purpose: Minimal wxWidgets sample </span></span><br><span class="line"><span class="comment">// Author:Julian Smart </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> ”wx/wx.h”</span></span><br><span class="line"><span class="comment">// 应用程序类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> :</span> <span class="keyword">public</span> wxApp </span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>: </span><br><span class="line">		<span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">OnInit</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//主窗口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span> :</span> <span class="keyword">public</span> wxFrame</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="comment">//主窗口构造函数</span></span><br><span class="line">    	MyFrame(<span class="keyword">const</span> wxString&amp; title);</span><br><span class="line">    </span><br><span class="line">    	<span class="comment">//事件处理函数</span></span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">OnExit</span><span class="params">(wxCommandEvent&amp; event)</span></span>;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">OnAbout</span><span class="params">(wxCommandEvent&amp; event)</span></span>;</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">    	<span class="comment">//声明事件表</span></span><br><span class="line">    	DECLARE_EVENT_TABLE()   	</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宏定义	</span></span><br><span class="line">	DECLARE_APP(MyApp)<span class="comment">//有了这一行就可以使用MyApp&amp; wxGetApp()了</span></span><br><span class="line">	IMPLEMENT_APP(MyApp)<span class="comment">//告诉应用程序是哪个类wxWidgets</span></span><br></pre></td></tr></table></figure>
<h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a>main.cpp</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化程序</span></span><br><span class="line"><span class="keyword">bool</span> MyApp::OnInit()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//创建主窗口</span></span><br><span class="line">	MyFrame ∗frame = <span class="keyword">new</span> MyFrame(wxT(”Minimal wxWidgets App”));</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//显示主窗口</span></span><br><span class="line">	frame−&gt;Show(<span class="literal">true</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//开始事件处理循环</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//事件表</span></span><br><span class="line">	BEGIN_EVENT_TABLE(MyFrame, wxFrame) </span><br><span class="line">    	EVT_MENU(wxID_ABOUT, MyFrame::OnAbout) </span><br><span class="line">    	EVT_MENU(wxID_EXIT, MyFrame::OnExit)</span><br><span class="line">	END_EVENT_TABLE()</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="keyword">void</span> MyFrame::OnAbout(wxCommandEvent&amp; event) </span><br><span class="line">&#123;</span><br><span class="line">	wxString msg; </span><br><span class="line">	msg.Printf(wxT(”Hello <span class="keyword">and</span> welcome to %s”), </span><br><span class="line">               wxVERSION STRING);</span><br><span class="line">        </span><br><span class="line">	wxMessageBox(msg, wxT(”About Minimal”), </span><br><span class="line">                 wxOK | wxICON INFORMATION, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> MyFrame::OnExit(wxCommandEvent&amp; event) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 释放主窗口</span></span><br><span class="line">    Close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 最复杂的写最下边</span></span><br><span class="line">MyFrame::MyFrame(<span class="keyword">const</span> wxString&amp; title)</span><br><span class="line">       : wxFrame(<span class="literal">NULL</span>, wxID_ANY, title)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置窗口图标</span></span><br><span class="line">    SetIcon(wxIcon(mondrian_xpm));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建菜单条</span></span><br><span class="line">    wxMenu *fileMenu = <span class="keyword">new</span> wxMenu;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加“关于”菜单项</span></span><br><span class="line">    wxMenu *helpMenu = <span class="keyword">new</span> wxMenu;</span><br><span class="line">    helpMenu-&gt;Append(wxID_ABOUT, wxT(<span class="string">"&amp;About...\tF1"</span>),</span><br><span class="line">                     wxT(<span class="string">"Show about dialog"</span>));</span><br><span class="line"></span><br><span class="line">    fileMenu-&gt;Append(wxID_EXIT, wxT(<span class="string">"E&amp;xit\tAlt-X"</span>),</span><br><span class="line">                     wxT(<span class="string">"Quit this program"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将菜单项添加到菜单条中</span></span><br><span class="line">    wxMenuBar *menuBar = <span class="keyword">new</span> wxMenuBar();</span><br><span class="line">    menuBar-&gt;Append(fileMenu, wxT(<span class="string">"&amp;File"</span>));</span><br><span class="line">    menuBar-&gt;Append(helpMenu, wxT(<span class="string">"&amp;Help"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 然后将菜单条放置在主窗口上.…</span></span><br><span class="line">    SetMenuBar(menuBar);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个状态条来让一切更有趣些。</span></span><br><span class="line">    CreateStatusBar(<span class="number">2</span>);</span><br><span class="line">    SetStatusText(wxT(<span class="string">"Welcome to wxWidgets!"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类比Qt的话感觉就是</p>
<h2 id="2-Qt类比"><a href="#2-Qt类比" class="headerlink" title="2. Qt类比"></a>2. Qt类比</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQtGuiApp</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">	Q_OBJECT</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		MyQtGuiApp(QWidget *parent = Q_NULLPTR);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		Ui::MyQtGuiApp ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MyQtGuiApp.cpp</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QtGuiApp::QtGuiApp(QWidget *parent)</span><br><span class="line">	: QMainWindow(parent)</span><br><span class="line">	&#123;</span><br><span class="line">		ui.setupUi(<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WxWidgets图形化界面学习</category>
      </categories>
      <tags>
        <tag>图形界面</tag>
        <tag>WxWidgets</tag>
        <tag>GUI</tag>
        <tag>C++</tag>
        <tag>VisualStudio</tag>
      </tags>
  </entry>
  <entry>
    <title>WxWidgets学习笔记-1-环境搭建VisualStudio2019+WxWidgets</title>
    <url>/2020/01/28/WxWidgets%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BAVisualStudio2019-WxWidgets/</url>
    <content><![CDATA[<p>参考链接:<a href="https://www.youtube.com/watch?v=sRhoZcNpMb4" target="_blank" rel="noopener">Setting Up wxWidgets Using Visual Studio 2019</a></p>
<p><img src="/images/image-20200128155515862.png" alt="image-20200128155515862"></p>
<h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>解压，进入build-&gt;msw文件夹，VS2019打开wx_vc16.sln,VS2017打开wx_vc15.sln</p>
<a id="more"></a>
<p><img src="/images/image-20200128155548868.png" alt="image-20200128155548868"></p>
<p><img src="/images/image-20200128155700206.png" alt="image-20200128155700206"></p>
<h4 id="Build生成解决方案"><a href="#Build生成解决方案" class="headerlink" title="Build生成解决方案"></a>Build生成解决方案</h4><p>生成Debug Win32 x64 和Release win32 x64四个解决方案</p>
<p><img src="/images/image-20200128155905012.png" alt="image-20200128155905012"></p>
<h4 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h4><p><img src="/images/image-20200128160242905.png" alt="image-20200128160242905"></p>
<h4 id="新建解决方案打开属性管理器"><a href="#新建解决方案打开属性管理器" class="headerlink" title="新建解决方案打开属性管理器"></a>新建解决方案打开属性管理器</h4><p><img src="/images/image-20200128160737543.png" alt="image-20200128160737543"></p>
<p>右键添加现有属性表</p>
<p><img src="/images/image-20200128160804566.png" alt="image-20200128160804566"></p>
<p><img src="/images/image-20200128160835255.png" alt="image-20200128160835255"></p>
<h4 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h4><p><img src="/images/image-20200128161007701.png" alt="image-20200128161007701"></p>
<h4 id="连接器修改"><a href="#连接器修改" class="headerlink" title="连接器修改"></a>连接器修改</h4><p><img src="/images/image-20200128161230608.png" alt="image-20200128161230608"></p>
<h4 id="注意应用到所有配置所有平台"><a href="#注意应用到所有配置所有平台" class="headerlink" title="注意应用到所有配置所有平台"></a>注意应用到所有配置所有平台</h4><iframe width="560" height="315" src="https://www.youtube.com/embed/sRhoZcNpMb4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>



<h3 id="2020-6-26更新"><a href="#2020-6-26更新" class="headerlink" title="2020.6.26更新"></a>2020.6.26更新</h3><p>之前的教程没有分离出库文件和头文件而且还用了环境变量不方便移植，正确的做法应该是把文件夹里的Lib和inciude提取出来放到项目底下</p>
<h4 id="Linker-gt-system-gt-subsystem改为Windows"><a href="#Linker-gt-system-gt-subsystem改为Windows" class="headerlink" title="Linker-&gt;system-&gt;subsystem改为Windows"></a>Linker-&gt;system-&gt;subsystem改为Windows</h4><p><img src="/images/image-20200626160008561.png" alt="image-20200626160008561"></p>
<h4 id="预处理器添加WXUSINGDLL"><a href="#预处理器添加WXUSINGDLL" class="headerlink" title="预处理器添加WXUSINGDLL"></a>预处理器添加WXUSINGDLL</h4><p><img src="/images/image-20200626160127455.png" alt="image-20200626160127455"></p>
<h4 id="配置所用平台的目录"><a href="#配置所用平台的目录" class="headerlink" title="配置所用平台的目录"></a>配置所用平台的目录</h4><p><img src="/images/image-20200626160230367.png" alt="image-20200626160230367"></p>
<h4 id="Debug设置"><a href="#Debug设置" class="headerlink" title="Debug设置"></a>Debug设置</h4><p><img src="/images/image-20200626160309863.png" alt="image-20200626160309863"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(ProjectDir)3rdParty\wxWidgets\lib\vc_x64_dll\mswud</span><br><span class="line">$(ProjectDir)3rdParty\wxWidgets\include\</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20200626160832957.png" alt="image-20200626160832957"></p>
<h4 id="Release设置"><a href="#Release设置" class="headerlink" title="Release设置"></a>Release设置</h4><p><img src="/images/image-20200626160407253.png" alt="image-20200626160407253"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(ProjectDir)3rdParty\wxWidgets\lib\vc_x64_dll\mswu</span><br><span class="line">$(ProjectDir)3rdParty\wxWidgets\include\</span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20200626160448956.png" alt="image-20200626160448956"></p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/EI2taYkErRg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></content>
      <categories>
        <category>WxWidgets图形化界面学习</category>
      </categories>
      <tags>
        <tag>图形界面</tag>
        <tag>WxWidgets</tag>
        <tag>GUI</tag>
        <tag>C++</tag>
        <tag>VisualStudio</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Unity与Unreal4来可视化学习光线跟踪-1-前期准备</title>
    <url>/2020/01/28/%E4%BD%BF%E7%94%A8Unity%E4%B8%8EUnreal4%E6%9D%A5%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%85%89%E7%BA%BF%E8%B7%9F%E8%B8%AA-1-%E5%89%8D%E6%9C%9F%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h1 id="1-Unity的设置"><a href="#1-Unity的设置" class="headerlink" title="1.Unity的设置"></a>1.Unity的设置</h1><p><img src="/images/image-20200128135530584.png" alt="image-20200128135530584"></p>
<h4 id="1-删除直射光，右键Delete"><a href="#1-删除直射光，右键Delete" class="headerlink" title="1.删除直射光，右键Delete"></a>1.删除直射光，右键Delete</h4><a id="more"></a>
<h4 id="2-关闭SkyBox天空盒"><a href="#2-关闭SkyBox天空盒" class="headerlink" title="2.关闭SkyBox天空盒"></a>2.关闭SkyBox天空盒</h4><p>在Windows-&gt;Rendering-&gt;Lighting Setting关闭SkyBox天空盒 ，点选None</p>
<p><img src="/images/image-20200128140116172.png" alt="image-20200128140116172"></p>
<h4 id="3-环境光设为Color调成黑色"><a href="#3-环境光设为Color调成黑色" class="headerlink" title="3.环境光设为Color调成黑色"></a>3.环境光设为Color调成黑色</h4><p><img src="/images/image-20200128140238786.png" alt="image-20200128140238786"></p>
<h4 id="4-环境光反射调为Custom去除反射"><a href="#4-环境光反射调为Custom去除反射" class="headerlink" title="4.环境光反射调为Custom去除反射"></a>4.环境光反射调为Custom去除反射</h4><p><img src="/images/image-20200128140331577.png" alt="image-20200128140331577"></p>
<h4 id="5-将Camera的底色调节为黑色"><a href="#5-将Camera的底色调节为黑色" class="headerlink" title="5.将Camera的底色调节为黑色"></a>5.将Camera的底色调节为黑色</h4><p><img src="/images/image-20200128140530148.png" alt="image-20200128140530148"></p>
<p>现在场景里只剩下一个摄像机</p>
<h1 id="2-Unreal的设置-建立空白场景"><a href="#2-Unreal的设置-建立空白场景" class="headerlink" title="2.Unreal的设置-建立空白场景"></a>2.Unreal的设置-建立空白场景</h1><p>file-&gt;new level -&gt;选择Empty Level</p>
<p><img src="/images/image-20200128135242842.png" alt="image-20200128135242842"></p>
<p>建立什么都没有的Unreal场景</p>
<p><img src="/images/image-20200128135309816.png" alt="image-20200128135309816"></p>
<h1 id="3-SkyBox装回去"><a href="#3-SkyBox装回去" class="headerlink" title="3.SkyBox装回去"></a>3.SkyBox装回去</h1><p><img src="/images/image-20200129200039714.png" alt="image-20200129200039714"></p>
<p><img src="/images/image-20200129200339935.png" alt="image-20200129200339935"></p>
<p>参考连接:<a href="https://www.bilibili.com/video/av41903795" target="_blank" rel="noopener">[傅老師/Unreal4] 從Unity3D來學Unreal4引擎</a></p>
<p>参考视频:</p>
<iframe width="800" height="600" src="//player.bilibili.com/player.html?aid=41903795&cid=73572522&page=1" scrolling="yes" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>
]]></content>
      <categories>
        <category>光线跟踪演示</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Unreal Engine</tag>
        <tag>Ray Tracer</tag>
        <tag>光线跟踪演示</tag>
      </tags>
  </entry>
  <entry>
    <title>从零开始的光线跟踪-1-C++GUi 的框架实现Qt和WxWidget双版本</title>
    <url>/2020/01/27/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84%E5%85%89%E7%BA%BF%E8%B7%9F%E8%B8%AA-1-C-GUi-%E7%9A%84%E6%A1%86%E6%9E%B6%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="1-参考书籍"><a href="#1-参考书籍" class="headerlink" title="1.参考书籍"></a>1.参考书籍</h1><p>实现的参考书籍是光线跟踪算法技术，清华大学出版社，下面这本</p>
<a id="more"></a>
<p><img src="/images/image-202001272337026112.png" alt="image-20200127233702611"></p>
<p>英文版标题为Ray Tracing from the Ground Up，封面如下所示：</p>
<p><img src="/images/image-20200127234054434.png" alt="image-20200127234054434"></p>
<h1 id="2-项目开源地址"><a href="#2-项目开源地址" class="headerlink" title="2.项目开源地址"></a>2.项目开源地址</h1><p>这次我打算使用VisualStudio+Qt5与VisualStudio+WxWidget 两个版本实现 同时使用Codeblock+wxSmith可视化插件作为辅助说明理解，一方面是学习光线跟踪，一方面是学习C++ GUI的实现，幸好在Github上已经有前辈实现了Qt的版本可以参考先说一下要实现的代码在Github和书的官方网页可以找到，我也会把写完的代码放到我的Github界面供参考用。</p>
<p>因为QtDesigner的存在和Codeblock里的wxSmith 拖控件实在是太适合我这样的懒人了(不是..)</p>
<p>首先是VisualStudio+WxWidget的环境搭建</p>
<p>先说一下比较烦人的事情，就是..VisualStudio的版本问题，我这里开发使用的是最新版的VisualStudio2019专业版，因为它是向下兼容的，比如VS2017可以打开2010的项目，但是反过来就不可以，所以理论上来说我这个项目只VS2019可以打开…所以想白嫖的可以先下个VS2019(笑)</p>
]]></content>
      <categories>
        <category>光线跟踪</category>
      </categories>
      <tags>
        <tag>GUI</tag>
        <tag>VisualStudio</tag>
        <tag>Qt</tag>
        <tag>程序设计</tag>
        <tag>WxWidget</tag>
        <tag>Codeblock</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt学习笔记-11-Qt+VisualStudio点击按钮或目录打开对话框QDialog</title>
    <url>/2020/01/27/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-11-Qt-VisualStudio%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%88%96%E7%9B%AE%E5%BD%95%E6%89%93%E5%BC%80%E5%AF%B9%E8%AF%9D%E6%A1%86QDialog/</url>
    <content><![CDATA[<p>之前创建的是QWidget</p>
<p><img src="/images/image-20200127132043210.png" alt="image-20200127132043210"></p>
<p>这次要创建的是对话框，虽然看起来很像但是其实不一样QWidget和QDialog是不一样的应该吧..</p>
<p><img src="/images/image-20200127132110870.png" alt="image-20200127132110870"></p>
<p><img src="/images/image-20200127132059000.png" alt="image-20200127132059000"></p>
<p>先新建一个ui窗口</p>
<p><img src="/images/image-20200127132249254.png" alt="image-20200127132249254"></p>
<p>改一下名字改为MyDialog</p>
<p><img src="/images/image-20200127132340412.png" alt="image-20200127132340412"></p>
<p>基类从QWidget改为QDialog试一下</p>
<p><img src="/images/image-20200127132412770.png" alt="image-20200127132412770"></p>
<p>目录中会多出3个文件</p>
<p><img src="/images/image-20200127132546447.png" alt="image-20200127132546447"></p>
<p>参考:<a href="https://blog.csdn.net/rxs0011/article/details/89481631" target="_blank" rel="noopener">VS2015下用Qt Designer创建对话框</a></p>
]]></content>
  </entry>
  <entry>
    <title>Qt学习笔记-10-Qt+VisualStudio点击按钮或目录Action打开新窗口</title>
    <url>/2020/01/27/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-10-Qt-VisualStudio%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E6%88%96%E7%9B%AE%E5%BD%95Action%E6%89%93%E5%BC%80%E6%96%B0%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h4 id="1-新建UI文件"><a href="#1-新建UI文件" class="headerlink" title="1.新建UI文件"></a>1.新建UI文件</h4><p>总之先新建两个UI文件</p>
<p><img src="/images/image-20200127130344280.png" alt="image-20200127130344280"></p>
<h4 id="2-添加按钮-动作-和槽函数"><a href="#2-添加按钮-动作-和槽函数" class="headerlink" title="2.添加按钮(动作)和槽函数"></a>2.添加按钮(动作)和槽函数</h4><p><img src="/images/image-20200127130455905.png" alt="image-20200127130455905"></p>
<p>我这里是点击Information就弹出新的窗口 QtSon</p>
<h4 id="3-添加代码"><a href="#3-添加代码" class="headerlink" title="3.添加代码"></a>3.添加代码</h4><p>在主函数窗口QtGuiApplication1.h里添加一个槽函数来响应Information这个QAction，同时包含QtSon的头文件声明一个</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"QtSon.h"</span></span></span><br><span class="line">	......</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">			QtSon* son;</span><br><span class="line">	......</span><br><span class="line">    ......</span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">			<span class="function"><span class="keyword">void</span> <span class="title">QtSonslot</span><span class="params">()</span></span>;</span><br><span class="line">	......</span><br></pre></td></tr></table></figure>
<p>在QtGuiApplication1.cpp里连接和实现它</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QtGuiApplication1::QtGuiApplication1(QWidget *parent)</span><br><span class="line">	: QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line">    ui.setupUi(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//连接</span></span><br><span class="line"> 	connect(ui.actionInformation, SIGNAL(triggered()), <span class="keyword">this</span>, SLOT(QtSonslot()));   </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//实现</span></span><br><span class="line"><span class="keyword">void</span> QtGuiApplication1::QtSonslot()</span><br><span class="line">&#123;</span><br><span class="line">    son = <span class="keyword">new</span> QtSon();<span class="comment">//实例化</span></span><br><span class="line">    son-&gt;show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-运行结果"><a href="#4-运行结果" class="headerlink" title="4.运行结果"></a>4.运行结果</h4><p><img src="/images/image-20200127131222754.png" alt="image-20200127131222754"></p>
<p>参考链接:<a href="https://blog.csdn.net/weixin_41991128/article/details/86602385" target="_blank" rel="noopener">Qt5+VS2017点击按钮打开新窗口</a></p>
]]></content>
      <categories>
        <category>Qt图形化界面学习</category>
      </categories>
      <tags>
        <tag>图形界面</tag>
        <tag>GUI</tag>
        <tag>C++</tag>
        <tag>VisualStudio</tag>
        <tag>Qt</tag>
        <tag>QDialog</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt学习笔记-9-在VisualStudio里快速创建Qt工程的.h与C++文件</title>
    <url>/2020/01/26/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9-%E5%9C%A8VisualStudio%E9%87%8C%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BAQt%E5%B7%A5%E7%A8%8B%E7%9A%84-h%E4%B8%8EC-%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<p>新建了一个UI文件，在VisualStudio里新建了一个UI文件的步骤如下所示</p>
<p><img src="/images/image-20200126234404158.png" alt="image-20200126234404158"></p>
<a id="more"></a>
<p><img src="/images/image-20200126234455208.png" alt="image-20200126234455208"></p>
<p>Qt里的样子</p>
<p><img src="/images/image-20200126234522558.png" alt="image-20200126234522558"></p>
<p>新建了一个窗口之后不是要建立.h和.cpp文件嘛，看到一篇博客，说是手动创建.h和C++文件，当时我就满头问号？？？</p>
<p>这么麻烦的吗？后来找了找根本不用这样 只需要在Form Files右键添加-&gt;Add Qt class-&gt;选择Qt GUI Class就会出来新的.h和.cpp文件了</p>
<p><img src="/images/image-20200127122258643.png" alt="image-20200127122258643"></p>
<p>添加一个Qt GUI Class然后直接“Next”—&gt;”Finish”不用改其他参数。</p>
<p><img src="/images/image-20200127122324571.png" alt="image-20200127122324571"></p>
<p>目前的文件结构如下</p>
<p><img src="/images/image-20200127122403813.png" alt="image-20200127122403813"></p>
<p>然后右键点击Ui文件编译</p>
]]></content>
      <categories>
        <category>Qt图形化界面学习</category>
      </categories>
      <tags>
        <tag>图形界面</tag>
        <tag>GUI</tag>
        <tag>C++</tag>
        <tag>VisualStudio</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt学习笔记-8-使用QtDesigner生成的ui_QtGui*.h函数里的Qmenu</title>
    <url>/2020/01/26/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8-%E4%BD%BF%E7%94%A8QtDesigner%E7%94%9F%E6%88%90%E7%9A%84ui-QtGui-h%E5%87%BD%E6%95%B0%E9%87%8C%E7%9A%84Qmenu/</url>
    <content><![CDATA[<p>起因是这样的，用QtDesigner设计了一个界面，想调用里面的Menu 这里的话就是MenuShowMessageBox</p>
<p><img src="/images/image-20200126232558887.png" alt="image-20200126232558887"></p>
<p>想要做一个Connect触发事件，编译了一下UI文件，然后生成了ui_QtGuiApplication1.h的头文件</p>
<a id="more"></a>
<p><img src="/images/image-20200126232721624.png" alt="image-20200126232721624"></p>
<p>点进去看的话，已经有了这样一个Qmenu那接下来就是怎么在主文件里引用了，看了半天都没有博客讲..</p>
<p><img src="/images/image-20200126232928079.png" alt="image-20200126232928079"></p>
<p>试了半天发现要这样写 ui.menu_6或者什么的，我这里是ui.menuShowMessageBox,这样就可以直接调用Connect .UI文件生成的头文件里的控件了</p>
<p><img src="/images/image-20200126233049411.png" alt="image-20200126233049411"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">connect(ui.menuShowMessageBox, SIGNAL(triggered()), <span class="keyword">this</span>, SLOT(showmessagebox()));</span><br></pre></td></tr></table></figure>
<h4 id="可以参考的文章"><a href="#可以参考的文章" class="headerlink" title="可以参考的文章:"></a>可以参考的文章:</h4><p><a href="https://blog.csdn.net/imred/article/details/73730213" target="_blank" rel="noopener">使用Qt Designer生成的ui文件的几种方式</a></p>
<p><a href="https://www.cnblogs.com/xihong2014/p/6528137.html" target="_blank" rel="noopener">在Qt中如何使用QtDesigner创建的UI文件（一） （转）</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_6fe2f8c50102x5cz.html" target="_blank" rel="noopener">Qt学习笔记：QMenuBar()、QMenu()和QAction()的使用</a></p>
]]></content>
      <categories>
        <category>Qt图形化界面学习</category>
      </categories>
      <tags>
        <tag>图形界面</tag>
        <tag>GUI</tag>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>QMenu</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt学习笔记-7-QMessageBox消息弹框</title>
    <url>/2020/01/26/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7-QMessageBox%E6%B6%88%E6%81%AF%E5%BC%B9%E6%A1%86/</url>
    <content><![CDATA[<p>先来看一下最熟悉的 QMessageBox::information。我们在以前的代码中这样使用过：</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMessageBox::information(<span class="literal">NULL</span>, <span class="string">"Title"</span>, <span class="string">"Content"</span>, QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);</span><br></pre></td></tr></table></figure>
<h4 id="效果如下"><a href="#效果如下" class="headerlink" title="效果如下"></a>效果如下</h4><p><img src="/images/image-20200126163407867.png" alt="image-20200126163407867"></p>
<h4 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> StandardButton QMessageBox::information ( </span><br><span class="line">    QWidget * parent, <span class="comment">//父组件</span></span><br><span class="line">    <span class="keyword">const</span> QString &amp; title, <span class="comment">//对话框的标题</span></span><br><span class="line">    <span class="keyword">const</span> QString &amp; text, <span class="comment">//对话框显示的内容</span></span><br><span class="line">    StandardButtons buttons = Ok, <span class="comment">//声明对话框放置的按钮，默认是只放置一个 OK 按钮，</span></span><br><span class="line">    StandardButton defaultButton = NoButton );<span class="comment">//默认选中的按钮，默认值是 NoButton，也就是哪个按钮都不选中</span></span><br></pre></td></tr></table></figure>
<p>首先，它是 static 的，所以我们能够使用类名直接访问到，</p>
<p>第一个参数 parent，说明它的父组件；</p>
<p>第二个参数 title，也就是对话框的标题；</p>
<p>第三个参数 text，是对话框显示的内容；</p>
<p>第四个参数 buttons，声明对话框放置的按钮，默认是只放置一个 OK 按钮，这个参数可以使用或运算，例如我们希望有一个 Yes 和一个 No 的按钮，可以使用 QMessageBox::Yes | QMessageBox::No，所有的按钮类型可以在 QMessageBox 声明的 StandarButton 枚举中找到；</p>
<p>第五个参数 defaultButton 就是默认选中的按钮，默认值是 NoButton，也就是哪个按钮都不选中。</p>
<p>在用 QtCreator 写的时候，可以在输入QMessageBox::information 之后输入(，稍等一下，QtCreator 就会帮我们把函数签名显示在右上方了</p>
<p>参考链接:</p>
<p><a href="https://blog.csdn.net/rxs0011/article/details/89481631" target="_blank" rel="noopener">MessageBox使用</a></p>
<p><a href="https://www.w3cschool.cn/learnroadqt/mr5j1j4d.html" target="_blank" rel="noopener">Qt标准对话框之MeaasgeBox</a></p>
]]></content>
      <categories>
        <category>Qt图形化界面学习</category>
      </categories>
      <tags>
        <tag>图形界面</tag>
        <tag>GUI</tag>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>QMessageBox</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt学习笔记-6-Qt parent 参数</title>
    <url>/2020/01/26/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6-Qt-parent-%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>程序写的多了，你会发现几乎所有的Qt类的构造函数都会有一个 parent 参数。这个参数通常是QObject 或者是 QWidget 类型的。很多情况下它都会有一个初始值0，因此，即便你不去给它复制也没有丝毫的问题。于是，稍微偷懒一下，就会不自觉的忽略了这个参数。那么，这个参数到底是干什么用的呢？</p>
<p>其实，这个参数有很多用处。就像它的名字一样，这个参数指定了组件的父组件。对于一个对话框来说，对话框一般是不作为顶层容器出现的，因此在任务栏上一般是没有对话框的位置的。怎么指定这个对话框不是顶层容器呢？有父组件的组件不就不是顶层容器了吗？因此，只要你指定对话框的 parent 属性，任务栏就不会出现它的身影。当然，如果你不指定，这个对话框就成为顶层容器了，任务栏会给它留个位置的——<strong>利用这个特性，就可以实现特殊对话框可以在任务栏出现的效果，比如“关于”对话框的出现。</strong></p>
<p>另外比较通用，也是很重要的作用是，parent 参数指明了组件的父组件，这样，当父组件 delete 时，Qt 可以保证所有子组件——也就是 parent 指针指向这个组件的所有组件——都会被正确的 delete掉。这是 Qt 能够帮助我们管理一部分内存的原因所在。Qt 是通过遍历 parent 属性来防止了这一部分<strong>内存泄漏</strong>的。因此，必要情况下还是不要忘记设置这个 parent 属性。当然，如果你不声明这个属性，当整个程序关闭时，操作系统会回收内存——因此我们所说的内存泄漏一般是指我们自己写的应用程序的内部，而不会影响到整个操作系统——当然，如果你实现太可恶，操作系统也会受不了自动关掉你的程序的:-)</p>
]]></content>
      <categories>
        <category>Qt图形化界面学习</category>
      </categories>
      <tags>
        <tag>图形界面</tag>
        <tag>GUI</tag>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>QtParent</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo部署到github出现Host key verification failed的解决方案</title>
    <url>/2020/01/26/hexo%E9%83%A8%E7%BD%B2%E5%88%B0github%E5%87%BA%E7%8E%B0Host-key-verification-failed%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<p>因为ssh key有问题，连接不上服务器</p>
<h4 id="1、重新在git设置一下身份的名字和邮箱"><a href="#1、重新在git设置一下身份的名字和邮箱" class="headerlink" title="1、重新在git设置一下身份的名字和邮箱"></a>1、重新在git设置一下身份的名字和邮箱</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"yourname"</span></span><br><span class="line"></span><br><span class="line">git config --global user.email <span class="string">"your@email.com"</span></span><br></pre></td></tr></table></figure>
<p>注：yourname是你要设置的名字，your@email是你要设置的邮箱。</p>
<a id="more"></a>
<h4 id="2、删除-ssh文件夹下的known-hosts"><a href="#2、删除-ssh文件夹下的known-hosts" class="headerlink" title="2、删除.ssh文件夹下的known_hosts"></a>2、删除.ssh文件夹下的known_hosts</h4><p>直接搜索该文件夹</p>
<h4 id="3、git输入命令"><a href="#3、git输入命令" class="headerlink" title="3、git输入命令"></a>3、git输入命令</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"your@email.com"</span>（请填你设置的邮箱地址）</span><br></pre></td></tr></table></figure>
<p>接着出现：</p>
<blockquote>
<p>Generating public/private rsa key pair.</p>
<p>Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):</p>
</blockquote>
<p>直接按下回车</p>
<p>然后系统会自动在.ssh文件夹下生成两个文件，id_rsa和id_rsa.pub，用记事本打开id_rsa.pub</p>
<p>将全部的内容复制</p>
<h4 id="4-打开https-github-com-，登陆你的账户，进入设置"><a href="#4-打开https-github-com-，登陆你的账户，进入设置" class="headerlink" title="4.打开https://github.com/，登陆你的账户，进入设置"></a>4.打开<a href="https://github.com/，登陆你的账户，进入设置" target="_blank" rel="noopener">https://github.com/，登陆你的账户，进入设置</a></h4><p>进入ssh设置</p>
<p><img src="/images/20160712221858092.png" alt="img"></p>
<p><img src="/images/20160712221921074.png" alt="img"></p>
<p>在key中将刚刚复制的粘贴进去</p>
<p><img src="/images/20160712222026735.png" alt="img"></p>
<p>点击add ssh key，ok！</p>
<h4 id="5、在git中输入命令："><a href="#5、在git中输入命令：" class="headerlink" title="5、在git中输入命令："></a>5、在git中输入命令：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>
<p>然后会跳出一堆话。。 输入命令：yes 回车 提示成功</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>博客</tag>
        <tag>部署</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt学习笔记(5)--Qt标准对话框之QFileDialog</title>
    <url>/2020/01/26/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5-Qt%E6%A0%87%E5%87%86%E5%AF%B9%E8%AF%9D%E6%A1%86%E4%B9%8BQFileDialog/</url>
    <content><![CDATA[<p>所谓标准对话框，其实就是 Qt 内置的一些对话框，比如文件选择、颜色选择等等。</p>
<p>QFileDialog 是 Qt 中用于文件打开和保存的对话框。</p>
<p>之前写的openAction只是弹出了一个消息对话框,用于告知这个信号槽已经联通，现在要写真正的打开代码了！</p>
<a id="more"></a>
<p>修改 MainWindow 的 open 函数：</p>
<h4 id="写法1"><a href="#写法1" class="headerlink" title="写法1"></a>写法1</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//#include &lt;QFileDialog&gt;</span></span><br><span class="line"><span class="keyword">void</span> MainWindow::open() </span><br><span class="line">&#123; </span><br><span class="line">        QString path = QFileDialog::getOpenFileName(<span class="keyword">this</span>, tr(<span class="string">"Open Image"</span>), <span class="string">"."</span>, tr(<span class="string">"Image Files(*.jpg *.png)"</span>)); </span><br><span class="line">        <span class="keyword">if</span>(path.length() == <span class="number">0</span>) &#123; </span><br><span class="line">                QMessageBox::information(<span class="literal">NULL</span>, tr(<span class="string">"Path"</span>), tr(<span class="string">"You didn't select any files."</span>)); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                QMessageBox::information(<span class="literal">NULL</span>, tr(<span class="string">"Path"</span>), tr(<span class="string">"You selected "</span>) + path); </span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之前要先include QFileDialog ！然后运行一下！点击打开按钮，就会弹出打开对话框，然后选择文件或者直接点击取消，会有相应的消息提示。</p>
<h4 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h4><p><img src="/images/image-20200126012258457.png" alt="image-20200126012258457"></p>
<p><img src="/images/image-20200126012327743.png" alt="image-20200126012327743"></p>
<h4 id="写法2"><a href="#写法2" class="headerlink" title="写法2"></a>写法2</h4><p>QFileDialog 提供了很多静态函数，用于获取用户选择的文件。这里我们使用的是 getOpenFileName(), 也就是“获取打开文件名”。不过，这个函数的参数蛮长的，而且类型都是 QString，并不好记。考虑到这种情况，Qt 提供了另外的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QFileDialog *fileDialog = <span class="keyword">new</span> QFileDialog(<span class="keyword">this</span>); </span><br><span class="line">        fileDialog-&gt;setWindowTitle(tr(<span class="string">"Open Image"</span>)); </span><br><span class="line">        fileDialog-&gt;setDirectory(<span class="string">"."</span>); </span><br><span class="line">        fileDialog-&gt;setFilter(tr(<span class="string">"Image Files(*.jpg *.png)"</span>)); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fileDialog-&gt;exec() == QDialog::Accepted) &#123; </span><br><span class="line">                QString path = fileDialog-&gt;selectedFiles()[<span class="number">0</span>]; </span><br><span class="line">                QMessageBox::information(<span class="literal">NULL</span>, tr(<span class="string">"Path"</span>), tr(<span class="string">"You selected "</span>) + path); </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                QMessageBox::information(<span class="literal">NULL</span>, tr(<span class="string">"Path"</span>), tr(<span class="string">"You didn't select any files."</span>)); </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>不过，这两种写法虽然功能差别不大，但是弹出的对话框却并不一样。getOpenFileName()函数在Windows 和 MacOS X 平台上提供的是<strong>本地的对话框</strong>，而 QFileDialog 提供的始终是 <strong>Qt 自己绘制的对话框</strong>(还记得前面说过，Qt 的组件和 Swing 类似，也是自己绘制的，而不都是调用系统资源API)。</p>
<h4 id="getOpenFileName-函数的用法"><a href="#getOpenFileName-函数的用法" class="headerlink" title="getOpenFileName()函数的用法"></a>getOpenFileName()函数的用法</h4><p>为了说明 QFileDialog::getOpenFileName()函数的用法，还是先把函数声明放在这里：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString QFileDialog::getOpenFileName (</span><br><span class="line">          QWidget * parent = <span class="number">0</span>, <span class="comment">//用于指定父组件。注意，Qt组件构造函数都有个 parent 参数，并提供一个默认值0；</span></span><br><span class="line">          <span class="keyword">const</span> QString &amp; caption = QString(),<span class="comment">//对话框的标题</span></span><br><span class="line">          <span class="keyword">const</span> QString &amp; dir = QString(),<span class="comment">//对话框显示时默认打开的目录"."代表程序运行目录"/"代表盘符的根目录</span></span><br><span class="line">          <span class="keyword">const</span> QString &amp; filter = QString(),<span class="comment">//对话框的后缀名过滤器</span></span><br><span class="line">          QString * selectedFilter = <span class="number">0</span>,<span class="comment">//默认选择的过滤器</span></span><br><span class="line">          Options options = <span class="number">0</span> )<span class="comment">//对话框的一些参数设定，比如只显示文件夹等等</span></span><br></pre></td></tr></table></figure>
<p>第一个参数 parent，用于指定父组件。注意，很多 Qt 组件的构造函数都会有这么一个 parent 参数，并提供一个默认值0；</p>
<p>第二个参数 caption，是对话框的标题；</p>
<p>第三个参数 dir，是对话框显示时默认打开的目录，”.” 代表程序运行目录，”/“ 代表当前盘符的根目录(Windows，Linux下/就是根目录了)，也可以是平台相关的，比如”C:\”等；</p>
<p>第四个参数 filter，是对话框的后缀名过滤器，比如我们使用”Image Files(.jpg .png)”就让它只能显示后缀名是 jpg 或者 png 的文件。如果需要使用多个过滤器，使用”;;”分割，比如”JPEG Files(.jpg);;PNG Files(.png)”；</p>
<p>第五个参数 selectedFilter，是默认选择的过滤器；</p>
<p>第六个参数 options，是对话框的一些参数设定，比如只显示文件夹等等，它的取值是 enum QFileDialog::Option，每个选项可以使用 | 运算组合起来。</p>
<h4 id="选择多个文件"><a href="#选择多个文件" class="headerlink" title="选择多个文件"></a>选择多个文件</h4><p>如果我要想选择多个文件怎么办呢？Qt 提供了 getOpenFileNames()函数，其返回值是一个QStringList。你可以把它理解成一个只能存放 QString 的 List，也就是 STL 中的list。</p>
<p>好了，我们已经能够选择打开文件了。保存也是类似的，QFileDialog 类也提供了保存对话框的函数getSaveFileName</p>
]]></content>
      <categories>
        <category>Qt图形化界面学习</category>
      </categories>
      <tags>
        <tag>图形界面</tag>
        <tag>GUI</tag>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>QFileDialog</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt学习笔记(4)--Qt状态栏--statusBar()</title>
    <url>/2020/01/26/Qt%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4-Qt%E7%8A%B6%E6%80%81%E6%A0%8F-statusBar/</url>
    <content><![CDATA[<p>状态栏位于主窗口的最下方，提供一个显示工具提示等信息的地方。当窗口不是最大化的时候，状态栏的右下角会有一个可以<strong>调节大小的控制点</strong>；</p>
<p>当窗口最大化的时候，这个控制点会自动消失。Qt 提供了一个 <strong>QStatusBar</strong> 类来实现状态栏。</p>
<h4 id="QMainWindow-里默认的StatusBar-与setStatusBar-函数"><a href="#QMainWindow-里默认的StatusBar-与setStatusBar-函数" class="headerlink" title="QMainWindow 里默认的StatusBar()与setStatusBar()函数"></a>QMainWindow 里默认的StatusBar()与setStatusBar()函数</h4><a id="more"></a>
<p>QMainWindow 类里面就有一个 statusBar()函数，用于实现状态栏的调用。类似menuBar()函数，如果不存在状态栏，该函数会自动创建一个，如果已经创建则会返回这个状态栏的指针。如果你要替换掉已经存在的状态栏，需要使用 QMainWindow 的 setStatusBar()函数。</p>
<h4 id="状态栏显示的信息"><a href="#状态栏显示的信息" class="headerlink" title="状态栏显示的信息"></a>状态栏显示的信息</h4><p>在 Qt 里面，状态栏显示的信息有三种类型：临时信息、一般信息和永久信息。</p>
<p><img src="/images/image-20200126010246533.png" alt="image-20200126010246533"></p>
<h5 id="1-临时信息"><a href="#1-临时信息" class="headerlink" title="1.临时信息"></a>1.临时信息</h5><p>临时显示的信息，比如 QAction 的提示等，也可以设置自己的临时信息，比如程序启动之后显示 Ready，一段时间后自动消失——这个功能可以使用 QStatusBar 的 <strong>showMessage()</strong>函数来实现；</p>
<h5 id="2-一般信息"><a href="#2-一般信息" class="headerlink" title="2.一般信息"></a>2.一般信息</h5><p>一般信息可以用来显示页码之类的；</p>
<h5 id="3-永久信息"><a href="#3-永久信息" class="headerlink" title="3.永久信息"></a>3.永久信息</h5><p>永久信息是不会消失的信息，比如可以在状态栏提示用户 Caps Lock 键被按下之类。</p>
<h4 id="QStatusBar继承自QWidget"><a href="#QStatusBar继承自QWidget" class="headerlink" title="QStatusBar继承自QWidget"></a>QStatusBar继承自QWidget</h4><p>QStatusBar 继承自 QWidget，因此它可以添加其他的 QWidget。比如下面我们在 QStatusBar 上添加一个 QLabel。</p>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>首先在 class 的声明中添加一个私有的 QLabel 属性：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span>: </span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line">        QAction *openAction; </span><br><span class="line">        QLabel *msgLabel;</span><br><span class="line">		<span class="comment">//......</span></span><br></pre></td></tr></table></figure>
<p>然后在其构造函数中添加：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//...</span></span><br><span class="line">   msgLabel = <span class="keyword">new</span> QLabel; </span><br><span class="line">   msgLabel-&gt;setMinimumSize(msgLabel-&gt;sizeHint()); <span class="comment">//创建一个QLabel的对象,设置最小大小为本身的建议大小</span></span><br><span class="line">   msgLabel-&gt;setAlignment(Qt::AlignHCenter); <span class="comment">//设置显示规则是水平居中(HCenter)。</span></span><br><span class="line"></span><br><span class="line">   statusBar()-&gt;addWidget(msgLabel);<span class="comment">//将这个 label 添加到状态栏</span></span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>将鼠标移动到工具条或者菜单的QAction上，状态栏就会有相应的提示：</p>
<p><img src="/images/watermark,type_ZmFu.png" alt="img"></p>
<h4 id="如何使状态栏边框消失"><a href="#如何使状态栏边框消失" class="headerlink" title="如何使状态栏边框消失"></a>如何使状态栏边框消失</h4><p>但是 当没有任何提示时，状态栏会有一个短短的竖线：</p>
<p>其实，这是 QLabel 的边框。当没有内容显示时，QLabel 只显示出自己的一个边框。但是，很多情况下我们<br>并不希望有这条竖线，于是，我们对 statusBar()进行如下设置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">statusBar()-&gt;setStyleSheet(QString(<span class="string">"QStatusBar::item&#123;border: 0px&#125;"</span>));</span><br></pre></td></tr></table></figure>
<p>简单来说，就是把 QStatusBar 的子组件的 border 设置为0，也就是没有边框</p>
<h4 id="如何使状态栏右下角控制点消失"><a href="#如何使状态栏右下角控制点消失" class="headerlink" title="如何使状态栏右下角控制点消失"></a>如何使状态栏右下角控制点消失</h4><p>QStatusBar 右下角的大小控制点可以通过setSizeGripEnabled()函数来设置是否存在</p>
<p><strong>由于 QStatusBar 可以添加多个 QWidget，因此，我们可以构建出很复杂的状态栏。</strong></p>
<h4 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h4><h4 id="QtGuiApplication1-h"><a href="#QtGuiApplication1-h" class="headerlink" title="QtGuiApplication1.h"></a>QtGuiApplication1.h</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> QtGuiApplication1_H </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QtGuiApplication1_H </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtWidgets/QMainWindow&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ui_QtGuiApplication1.h"</span></span></span><br><span class="line"></span><br><span class="line">			<span class="class"><span class="keyword">class</span> <span class="title">QAction</span>;</span><span class="comment">//QAction 类的前向声明</span></span><br><span class="line">			<span class="class"><span class="keyword">class</span> <span class="title">QLabel</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QtGuiApplication1</span> :</span> <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">	Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	QtGuiApplication1(QWidget *parent = Q_NULLPTR);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Ui::QtGuiApplication1Class ui;</span><br><span class="line"></span><br><span class="line">			QAction* openAction;<span class="comment">//打开命令</span></span><br><span class="line">			QLabel* msgLabel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">			<span class="function"><span class="keyword">void</span> <span class="title">open</span><span class="params">()</span></span>;<span class="comment">//openAction的事件 Action-Slots</span></span><br><span class="line">	            <span class="comment">//为 QAction 添加事件响应。</span></span><br><span class="line">	            <span class="comment">//点击 QAction 会发出 triggered()信号，</span></span><br><span class="line">	            <span class="comment">//因此声名一个 slot，然后 connect 这个信号。</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MAINWINDOW_H</span></span></span><br></pre></td></tr></table></figure>
<h4 id="QtGuiApplication1-cpp"><a href="#QtGuiApplication1-cpp" class="headerlink" title="QtGuiApplication1.cpp"></a>QtGuiApplication1.cpp</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"QtGuiApplication1.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QAction&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMenu&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QMenuBar&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QKeySequence&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QToolBar&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qmessagebox.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;qlabel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QtGuiApplication1::QtGuiApplication1(QWidget *parent)</span><br><span class="line">	: QMainWindow(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------------openAction--------------</span></span><br><span class="line"></span><br><span class="line">    openAction = <span class="keyword">new</span> QAction(tr(<span class="string">"&amp;Open"</span>), <span class="keyword">this</span>); </span><br><span class="line"></span><br><span class="line">    openAction-&gt;setShortcut(QKeySequence::Open);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    openAction-&gt;setStatusTip(tr(<span class="string">"Open a file."</span>)); </span><br><span class="line">     </span><br><span class="line">    openAction-&gt;setIcon(QIcon(<span class="string">":/QtGuiApplication1/Resources/open.png"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//链接</span></span><br><span class="line">    connect(openAction, SIGNAL(triggered()), <span class="keyword">this</span>, SLOT(open()));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//---------------------------------------------------状态栏msgLabel--------- //please include first #include &lt;qlabel.h&gt;</span></span><br><span class="line">    msgLabel = <span class="keyword">new</span> QLabel;</span><br><span class="line">    msgLabel-&gt;setMinimumSize(msgLabel-&gt;sizeHint()); <span class="comment">// 建议大小</span></span><br><span class="line">    msgLabel-&gt;setAlignment(Qt::AlignHCenter);<span class="comment">//显示规则是水平居中(HCenter)</span></span><br><span class="line"></span><br><span class="line">    statusBar()-&gt;addWidget(msgLabel);<span class="comment">//加到界面里</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------菜单栏QMenu-----------------------</span></span><br><span class="line">    </span><br><span class="line">    QMenu* file = menuBar()-&gt;addMenu(tr(<span class="string">"&amp;File"</span>));<span class="comment">//QMainWindow 有一个 menuBar()函数，会返回菜单栏，也就是最上面的那一条。 #include &lt;QtGui/QMenuBar&gt; #include &lt;QtGui/QMenu&gt; </span></span><br><span class="line">    <span class="comment">//如果不存在会自动创建，如果已经存在就返回那个菜单栏的指针。</span></span><br><span class="line">    <span class="comment">//直接使用返回值添加一个菜单，也就是 addMenu，参数是一个 QString，也就是显示的菜单名字。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    file-&gt;addAction(openAction);<span class="comment">//然后使用这个 QMenu 指针添加这个 QAction。 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//------------------------------------------------------------工具栏QToolBar---------------</span></span><br><span class="line">    QToolBar* toolBar = addToolBar(tr(<span class="string">"&amp;File"</span>));<span class="comment">//使用addToolBar 函数的返回值添加了一个工具条，并且把这个 QAction 添加到了上面。 #include &lt;QtGui/QMenu&gt; </span></span><br><span class="line">    toolBar-&gt;addAction(openAction);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//ui.setupUi(this);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Slot槽里的实现写在这里</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> QtGuiApplication1::open()</span><br><span class="line">&#123;</span><br><span class="line">    QMessageBox::information(<span class="literal">NULL</span>, tr(<span class="string">"Open"</span>), tr(<span class="string">"Open a file"</span>)); <span class="comment">//Please add #include &lt;qmessagebox.h&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Qt图形化界面学习</category>
      </categories>
      <tags>
        <tag>图形界面</tag>
        <tag>GUI</tag>
        <tag>C++</tag>
        <tag>Qt</tag>
        <tag>QstatusBar</tag>
      </tags>
  </entry>
  <entry>
    <title>光线跟踪算法技术阅读笔记-一.光线跟踪器和程序设计</title>
    <url>/2019/12/25/%E5%85%89%E7%BA%BF%E8%B7%9F%E8%B8%AA%E7%AE%97%E6%B3%95%E6%8A%80%E6%9C%AF%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E4%B8%80-%E5%85%89%E8%B7%9F%E8%B8%AA%E5%99%A8%E5%92%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h2 id="相关书籍"><a href="#相关书籍" class="headerlink" title="相关书籍"></a>相关书籍</h2><p>C++ : </p>
<h2 id="光线跟踪V1-版本①-最简单的框架"><a href="#光线跟踪V1-版本①-最简单的框架" class="headerlink" title="光线跟踪V1(版本①):最简单的框架"></a>光线跟踪V1(版本①):最简单的框架</h2><p>根据书的顺序把源程序列出来，一个光线跟踪最简单最基本的场景</p>
<p><img src="/images/光线跟踪最基本场景.png" alt="光线跟踪最基本场景"></p>
<h3 id="Ray-h-光线-工具类"><a href="#Ray-h-光线-工具类" class="headerlink" title="Ray.h 光线_工具类"></a>Ray.h 光线_工具类</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _RAY_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _RAY_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"Point3D.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">"Vector3D.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ray</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		Point3D o;<span class="comment">//origin 光线发射点</span></span><br><span class="line">		Vector3D d;<span class="comment">// direction 朝向 用向量定义 </span></span><br><span class="line">		Ray(<span class="keyword">void</span>); <span class="comment">//default constructor  默认构造函数 </span></span><br><span class="line">		Ray(<span class="keyword">const</span> Point3D &amp;origin, <span class="keyword">const</span> Vector3D &amp;dir);<span class="comment">//constructor 构造函数重写 </span></span><br><span class="line">		Ray(<span class="keyword">const</span> Ray&amp; ray);<span class="comment">// copy constructor //复制构造函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		Ray&amp;<span class="comment">//assignment operator 赋值运算符</span></span><br><span class="line">			<span class="keyword">operator</span>=(<span class="keyword">const</span> Ray&amp; rhs);</span><br><span class="line">		~Ray(<span class="keyword">void</span>);<span class="comment">//destructor 析构函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>光线跟踪</category>
      </categories>
      <tags>
        <tag>程序设计</tag>
        <tag>阅读笔记</tag>
        <tag>命名规范</tag>
        <tag>光线跟踪器</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity_Shader入门精要一书中的扩展阅读网址</title>
    <url>/2019/12/24/Unity-Shader%E5%85%A5%E9%97%A8%E7%B2%BE%E8%A6%81%E4%B8%80%E4%B9%A6%E4%B8%AD%E7%9A%84%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB%E7%BD%91%E5%9D%80/</url>
    <content><![CDATA[<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章:"></a>第二章:</h2><p><a href="https://developer.nvidia.com/gdc-2003" target="_blank" rel="noopener">GDC 2003</a></p>
<p>[2] 批处理 Wloka M. Batch, Batch, Batch: What does it really mean?[C]//Presentation at game developers conference 2003. </p>
<p>相关的中文文章:</p>
<p><a href="https://blog.csdn.net/fandyvon/article/details/88740062" target="_blank" rel="noopener">[转]理解批次</a> </p>
<p><a href="https://blog.csdn.net/zangle260/article/details/76285809" target="_blank" rel="noopener">小型三维引擎设计实现-怎样通过减少对驱动程序的调用来提高性能</a></p>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>学习笔记</tag>
        <tag>Shader</tag>
        <tag>Unity</tag>
        <tag>网址</tag>
        <tag>批处理</tag>
        <tag>Batch</tag>
        <tag>GDC</tag>
      </tags>
  </entry>
  <entry>
    <title>Unity Shader 学习笔记-基础篇-1</title>
    <url>/2019/12/24/Unity%20Shader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%9F%BA%E7%A1%80%E7%AF%87-1/</url>
    <content><![CDATA[<h2 id="1-一个基础的Unity-Shader结构"><a href="#1-一个基础的Unity-Shader结构" class="headerlink" title="1.一个基础的Unity Shader结构"></a>1.一个基础的Unity Shader结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//起名与控制出现的位置 Shader-&gt;Unlit-&gt;S1</span><br><span class="line">Shader &quot;Unlit/S1&quot;</span><br><span class="line">&#123;	</span><br><span class="line">    /**************************************************************/</span><br><span class="line">    Properties</span><br><span class="line">    &#123;</span><br><span class="line">        //属性的变量名字 (&quot;显示在面板上的名字&quot;，类型)= 值</span><br><span class="line">        _MainTex (&quot;Texture&quot;, 2D) = &quot;white&quot; &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        //所有属性的例子</span><br><span class="line">        // Numbers and sliders</span><br><span class="line">        _Int (&quot; Int&quot;, Int)= 2 //整形</span><br><span class="line">        _Float (&quot;Float&quot;, Float)=1.5 //浮点数</span><br><span class="line">        _Range(&quot;Range&quot;, Range(0.0, 5.0))=3.0 //范围</span><br><span class="line">        // Colors and Vectors</span><br><span class="line">        _Color (&quot;Color&quot;, Color)=(1, 1,1,1) //颜色</span><br><span class="line">        _Vector (&quot;Vector&quot;, Vector)=(2,3,6, 1)//向量</span><br><span class="line">        // Textures</span><br><span class="line">        _2D(&quot;2D&quot;,2D)=&quot;&quot;&#123;&#125; </span><br><span class="line">        _Cube (&quot;Cube&quot;, Cube)=&quot;white&quot;&#123;&#125;//内置纹理</span><br><span class="line">        _3D(&quot;3D&quot;,3D)=&quot;back&quot;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    /************************************************************/</span><br><span class="line">    </span><br><span class="line">    SubShader</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">        Tags &#123; &quot;RenderType&quot;=&quot;Opaque&quot; &#125;</span><br><span class="line">        /*一些Pass</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        */</span><br><span class="line">        LOD 100</span><br><span class="line">	    //pass过多会影响性能</span><br><span class="line">        Pass</span><br><span class="line">        &#123;	//定义名称提高复用性 UsePass&quot;MyShader/MYPASSNAME&quot; Unity会把Pass名称转为大写</span><br><span class="line">            Name &quot;MyPassName&quot;</span><br><span class="line">            CGPROGRAM</span><br><span class="line">            #pragma vertex vert</span><br><span class="line">            #pragma fragment frag</span><br><span class="line">            // make fog work</span><br><span class="line">            #pragma multi_compile_fog</span><br><span class="line"></span><br><span class="line">            #include &quot;UnityCG.cginc&quot;</span><br><span class="line"></span><br><span class="line">            struct appdata</span><br><span class="line">            &#123;</span><br><span class="line">                float4 vertex : POSITION;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            struct v2f</span><br><span class="line">            &#123;</span><br><span class="line">                float2 uv : TEXCOORD0;</span><br><span class="line">                UNITY_FOG_COORDS(1)</span><br><span class="line">                float4 vertex : SV_POSITION;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            sampler2D _MainTex;</span><br><span class="line">            float4 _MainTex_ST;</span><br><span class="line"></span><br><span class="line">            v2f vert (appdata v)</span><br><span class="line">            &#123;</span><br><span class="line">                v2f o;</span><br><span class="line">                o.vertex = UnityObjectToClipPos(v.vertex);</span><br><span class="line">                o.uv = TRANSFORM_TEX(v.uv, _MainTex);</span><br><span class="line">                UNITY_TRANSFER_FOG(o,o.vertex);</span><br><span class="line">                return o;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            fixed4 frag (v2f i) : SV_Target</span><br><span class="line">            &#123;</span><br><span class="line">                // sample the texture</span><br><span class="line">                fixed4 col = tex2D(_MainTex, i.uv);</span><br><span class="line">                // apply fog</span><br><span class="line">                UNITY_APPLY_FOG(i.fogCoord, col);</span><br><span class="line">                return col;</span><br><span class="line">            &#125;</span><br><span class="line">            ENDCG</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-SubShader的RenderSetup和tags"><a href="#1-1-SubShader的RenderSetup和tags" class="headerlink" title="1.1 SubShader的RenderSetup和tags"></a>1.1 SubShader的RenderSetup和tags</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SubShader </span><br><span class="line">&#123;</span><br><span class="line">	//可选的 </span><br><span class="line">	[Tags]</span><br><span class="line">	</span><br><span class="line">	//可选的</span><br><span class="line">	[RenderSetup]</span><br><span class="line">	</span><br><span class="line">	Pass&#123; </span><br><span class="line">	&#125;</span><br><span class="line">	//other Passes</span><br></pre></td></tr></table></figure>
<p>SubShader_RenderSetup <strong>渲染设置</strong>参数 例如双面渲染或者Cull剔除背面对正面进行渲染</p>
<p><img src="/images/1577523747076.png" alt="1577523747076"></p>
<p>SubShader_Tags 如何渲染 只有在SubShader里的tag </p>
<table>
<thead>
<tr>
<th style="text-align:center">状态名称</th>
<th style="text-align:center">设置指令</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Cull</td>
<td style="text-align:center">Cull Back Front \</td>
<td style="text-align:center">Off</td>
<td>设置剔除模式:剔除背面/正面/关闭剔除</td>
</tr>
<tr>
<td style="text-align:center">ZTest</td>
<td style="text-align:center">ZTestLessGreaterLEqualGEqualEqualNotEqualAlways</td>
<td style="text-align:center">设置深度测试时使用的函数</td>
</tr>
<tr>
<td style="text-align:center">ZWrite</td>
<td style="text-align:center">ZWrite On Off</td>
<td style="text-align:center">开启/关闭深度写入</td>
</tr>
<tr>
<td style="text-align:center">Blend</td>
<td style="text-align:center">Blend SrcFactor DstFactor</td>
<td style="text-align:center">开启并设置混合模式</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Tags &#123; <span class="string">"TagNamel"</span> = <span class="string">"Valuel"</span> <span class="string">"TagName2"</span> =<span class="string">"Value2"</span> )</span><br></pre></td></tr></table></figure>
<h3 id="1-2-SubShader里的Pass块"><a href="#1-2-SubShader里的Pass块" class="headerlink" title="1.2 SubShader里的Pass块"></a>1.2 SubShader里的Pass块</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Unity Shader</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>学习笔记</tag>
        <tag>Shader</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title>色彩课作业存档</title>
    <url>/2019/02/11/%E8%89%B2%E5%BD%A9%E8%AF%BE%E4%BD%9C%E4%B8%9A%E5%AD%98%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="相对明度练习-纸雕"><a href="#相对明度练习-纸雕" class="headerlink" title="相对明度练习-纸雕"></a>相对明度练习-纸雕</h1>]]></content>
      <categories>
        <category>色彩课</category>
      </categories>
      <tags>
        <tag>Krenz</tag>
        <tag>DLC</tag>
        <tag>homework</tag>
        <tag>色彩课</tag>
      </tags>
  </entry>
  <entry>
    <title>Krenz透视课作业存档</title>
    <url>/2018/11/03/%E9%80%8F%E8%A7%86%E8%AF%BE%E4%BD%9C%E4%B8%9A%E5%AD%98%E6%A1%A3/</url>
    <content><![CDATA[<p><img src="/images/存档2.jpg" alt="透视课LV1作业1.1"></p>
<p>1.画的时候在砖的地方遇到了问题，本来以为很简单，但是砖块我画成平面了，完全不立体hh<br>2.留待以后说不定什么时候就可以用来上色玩了呢233<br>3.感谢皓辰和WEIYE助教<br>4.留档，之后想到什么再说</p>
<h1 id="LV8-Krenz透视课-第八堂课-主题-带景人物基础作业-Molers-Homework"><a href="#LV8-Krenz透视课-第八堂课-主题-带景人物基础作业-Molers-Homework" class="headerlink" title="LV8 Krenz透视课-第八堂课-主题:带景人物基础作业-Molers_Homework"></a>LV8 Krenz透视课-第八堂课-主题:带景人物基础作业-Molers_Homework</h1><p><img src="/images/8.1.jpg" alt="透视课LV8作业8.1"></p>
<p>1.五官,手,没有满意,线条也是粗略的加了一层轮廓没有考虑更深一层的线稿轮廓<br>2.小动物不会,直接抓型来着<br>3.丰富物件只能硬加,图案都是贴上去的<br>4.带景人物还好,只是人物增加的话会增加难度,没有规律(之后上构成课可能会解决)<br>5.帽子,褶皱有待加强<br>题外话:画的特别慢</p>
]]></content>
      <categories>
        <category>透视课</category>
      </categories>
      <tags>
        <tag>透视课</tag>
        <tag>Krenz</tag>
        <tag>DLC</tag>
        <tag>homework</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/11/01/Hello-World-0/</url>
    <content><![CDATA[<p>我的第一篇Hexo文章测试<br>添加Tags和Categories可以进行分类</p>
<p>代码测试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello Hexo World"</span>);</span><br></pre></td></tr></table></figure>
<p>本地图片测试 没有出现下标</p>
<p><img src="/images/images test.jpg" alt="image test"></p>
<p>图床链接测试</p>
]]></content>
      <categories>
        <category>Test</category>
      </categories>
      <tags>
        <tag>Test</tag>
      </tags>
  </entry>
</search>
